---
title: "Preparing Biodiversity Rasters directly from sources used by Laurance et al. 2014"
output: html_notebook
editor_options: 
  chunk_output_type: console
---
This document outlines methods for preparing biodiversity rasters from sources used by Laurance et al. 2014. Details on the Laurance et al. 2014 global roadmap data layers can be found [here](http://www.global-roadmap.org/technical-details/).

# Set up
## Utilities
See: scripts/1_Start.Rmd 



```{r other-helpful}
# Other helpful files
aaeac <- sf::st_crs("+proj=aea +lat_1=20 +lat_2=-23 +lat_0=0 +lon_0=25 +x_0=0 +y_0=0 +ellps=WGS84 +datum=WGS84 +units=m +no_defs") # Africa Albers Equal Area Conic projection.
# could probably also use raster::crs
CRSobj <- CRS("+proj=aea +lat_1=20 +lat_2=-23 +lat_0=0 +lon_0=25 +x_0=0 +y_0=0 +ellps=WGS84 +towgs84=0,0,0,0,0,0,0 +units=m +no_defs") # set CRS object for model runs, noting that this must be a CRS object for sp*, not a crs object

crs_longlat <- sf::st_crs("+proj=longlat +datum=WGS84 +no_defs")

load(file = fp(p_ZA,"parks_roads.rda")) # includes roads (a SpatialLinesDataFrame), pas (SpatialPolygonsDataFrame, a shapefile that includes both national parks and GMAs), and zambia (SpatialPolygonsDataFrame, outline of Zambia)
msk_shp <- readOGR(fp(p_datnew,"msk.shp")) %>% 
  spTransform(CRS("+proj=aea +lat_1=20 +lat_2=-23 +lat_0=0 +lon_0=25 +x_0=0 +y_0=0 +ellps=WGS84 +datum=WGS84 +units=m +no_defs"))
msk_sf <- st_read(fp(p_datnew,"msk.shp")) %>% st_transform(aaeac)
msk_sf_noholes <- smoothr::fill_holes(msk_sf, threshold = units::set_units(10000, km^2)) # a method to fill holes. could also use spatialEco::remove.holes() on sp* type data.
msk_sf_buff <- st_buffer(msk_sf, units::set_units(100, km))

msk_sf_ll <- st_transform(msk_sf, crs_longlat)
msk_sf_ll_noholes <- st_transform(msk_sf_noholes, crs_longlat)
msk_sf_ll_buff <- st_buffer(msk_sf_ll, units::set_units(1, degree))
plot(msk_sf_ll_buff)
plot(msk_sf_ll)
plot(msk_sf_ll_noholes)

msk_sf_ll_4deg_buff <- msk_sf_ll %>% st_buffer(units::set_units(4, degree))

msk <- raster(fp(p_datnew,"msk.tif")) # the actual high resolution msk, created directly from the csv in "bd_new_prep.Rmd"
msk_filled <- msk
msk_filled[is.na(msk_filled)] <- 0 # replace NAs with 0s
plot(msk_filled)


# basemaps ------------------------------------------------------------------------------------
load(fp(p_basemaps,"basemaps.RData"), verbose = TRUE)
```

```{r load-files}
# vertebrate files -------------------------------------------------------------------------------------
# valid sf files, made valid, and prepped for use in small ranged species analyses
load(file = fp(p_iucn_dev,"mam_valid_prepped.RData"), verbose = TRUE)
load(file = fp(p_iucn_dev,"bird_valid_prepped.RData"), verbose = TRUE)
load(file = fp(p_iucn_dev,"amp_valid_prepped.RData"), verbose = TRUE)
load(file = fp(p_iucn_dev,"rep_valid_prepped.RData"), verbose = TRUE)

# vert zambia sf files, prepped and valid
load(file = fp(p_iucn_dev, "mam_zambia.RData"), verbose = TRUE) # includes mam_zambia, which has had area added, been prepped, and then clipped to zambia
load(file = fp(p_iucn_dev, "bird_zambia.RData"), verbose = TRUE) # includes bird_zambia, which has had area added, been prepped, and then clipped to zambia
load(file = fp(p_iucn_dev, "amp_zambia.RData"), verbose = TRUE) # includes amp_zambia, which has had area added, been prepped, and then clipped to zambia
load(file = fp(p_iucn_dev, "rep_zambia.RData"), verbose = TRUE) # includes rep_zambia, which has had area added, been prepped, and then clipped to zambia


# vertebrate lists - important -----------------
load(file = fp(p_iucn_dev, "vert_lists.RData"), verbose = TRUE) # updated jan. 31 2020 
# note: these lists were created using the function cc_make_raster8 on January 31st, 2020. 

# summary tables
load(file = fp(p_datnew, "1_IUCN_dev/vert_valid_summaries.RData"), verbose = TRUE) # mam_valid_summary,  bird_valid_summary, amp_valid_summary, rep_valid_summary
load(file = fp(p_datnew, "1_IUCN_dev/vert_zambia_summaries.RData"), verbose = TRUE) # mam_zambia_summary,  bird_zambia_summary, amp_zambia_summary, rep_zambia_summary


load(file = fp(p_iucn_dev, "mam_list.RData"))  # updated jan. 31 2020 
load(file = fp(p_iucn_dev, "bird_list.RData"))  # updated jan. 31 2020 
load(file = fp(p_iucn_dev, "amp_list.RData"))  # updated jan. 31 2020 
load(file = fp(p_iucn_dev, "rep_list.RData"))  # updated jan. 31 2020 

# load-vert-bricks -------------------------------------------------------------------------------
load(file = fp(p_datnew, "vert_bricks.Rdata"), verbose = TRUE)

# load-vert-bricks ----------------------------------------------------------------------------
# create layer names object
layer_names <- c("mam", "bird", "amp", "rep", "sum", "sum_norm", "norm_sum", "mam_10", "bird_10", "amp_10", "rep_10", "norm_sum_10", "mam_110", "bird_110", "amp_110", "rep_110", "norm_sum_110")

richness_names <- c("all_richness", "endemism_richness", "endemism_zam_richness", "threat_richness", "threat_weighted_richness", "small_richness", "small_zam_richness", "small_threat_richness")

# load in as a list of all rasters
vert_r <- list(
  all_richness = brick(paste0(p_iucn_dev, "/", richness_names[1], ".tif")),
  endemism_richness = brick(paste0(p_iucn_dev, "/", richness_names[2], ".tif")),
  endemism_zam_richness = brick(paste0(p_iucn_dev, "/", richness_names[3], ".tif")),
  threat_richness = brick(paste0(p_iucn_dev, "/", richness_names[4], ".tif")),
  threat_weighted_richness = brick(paste0(p_iucn_dev, "/", richness_names[5], ".tif")),
  small_richness = brick(paste0(p_iucn_dev, "/", richness_names[6], ".tif")),
  small_zam_richness = brick(paste0(p_iucn_dev, "/", richness_names[7], ".tif")),
  small_threat_richness = brick(paste0(p_iucn_dev, "/", richness_names[8], ".tif"))
  )

# rename layers
for(i in seq_along(vert_r)) {
  names(vert_r[[i]]) <- layer_names
}

# plants ------------------------------------------------------------------------
plants_zambia_r <- raster(fp(p_plants_dev, "plants_zambia_r.tif"))


# habitats rasters -----------------------------------------------------------------------------
load(file = fp(p_datnew,"habitat_rasters_zambia.RData"), verbose = TRUE)

ecoregions_weighted_rarity <- raster(fp(p_ecoreg_dev, "ecoregions_weighted_rarity.tif"))




# load plants ----------------------------------------------------------------------------
load(file = "/Users/christophercrawford/Google Drive/_Projects/Zambia/agroEcoTradeoff/external/data_new/2_plants_dev/plants_list.RData", verbose = TRUE)
load(file = fp(p_plants_dev, "plants_valid.RData"), verbose = TRUE) # this includes plants, which has been made valid.

load(file = fp(p_plants_dev, "plants_zambia.RData"), verbose = TRUE)

load(file = fp(p_plants_dev, "plants_zambia_4deg_buff.RData"), verbose = TRUE)

plants_zambia_r <- raster(fp(p_plants_dev, "plants_zambia_r.tif"))


# habitats files --------------------------------------------------------------------------------------
# sf files, polygons
load(fp(p_datnew,"habitat_polys.RData"), verbose = TRUE) # all valid. includes: hotspots_sf, global and africa; ibas and ebas, global and Africa; ecoregions, global and Africa; # hbwa global and africa; frontier forests global and africa

load(file = fp(p_datnew,"habitat_rasters_zambia.RData"), verbose = TRUE)

load(file = fp(p_datnew,"habitat_lists.RData"), verbose = TRUE) # hotspots_list, iba_list, eba_list, iba_eba_list, ecoregions_list, hbwa_list, frontier_forests_list.


# final zambia rasters:
load(file = fp(p_datnew,"final-rasters-zambia.RData"), verbose = TRUE)


# 
#
#
#
#
# old
# 
#
#
#
# birds ---------
# load(file = fp(p_iucn_dev, "bird_valid_prepped.RData"), verbose = TRUE) 
# These files contain vertebrate_sf files (i.e. bird_valid, 7.22 gb), but prepped for use in small species, etc. This entailed joining the table of red list categories, changing some of the column names, adding a column for area, totalling area for parts of the range we're using, and adding a column ranking the range size to allow things to be subset for small ranged species analyses.

# old files ----------------------------------------------------------------------------------
# load(fp(p_iucn_dev,"mam_sf_valid_files.RData"), verbose = TRUE) # includes mam_sf_valid, and the vector and df of reasons they weren't valid before I ran st_make_valid
# load(fp(p_iucn_dev,"bird_files.RData"), verbose = TRUE) #(bird_threat_sf, bird_threat_made_valid, bird_terr_threat, bird_america_threat, bird_africa_threat, bird_zambia_threat)

# load(file = "/Users/christophercrawford/Google Drive/_Projects/Zambia/agroEcoTradeoff/external/data_new/1_IUCN_dev/bird_valid.RData", verbose = TRUE) # this has "bird_valid", an sf object made by splitting bird_sf into three files, and running cc_make_valid on each in parallel, the using rbind to put them back together. it's 6.9 gb.

# load(fp(p_iucn_dev,"amphibian_valid_files.RData"), verbose = TRUE) # amp_sf_valid
# load(fp(p_iucn_dev, "reptile_valid_files.RData"), verbose = TRUE) # rep_sf_valid

# vert file combos ------------------------------------------
# load(file = fp(p_datnew,"vertebrate-files.RData"), verbose = TRUE) # mam_pre_merge, bird_pre_merge, amp_pre_merge, rep_pre_merge, vert_merge, vert_list, vert_zambia_threat_richness.
# load(file = fp(p_datnew,"vertebrate-rasters-zambia.RData"), verbose = TRUE) # mam_zambia_threat_richness, bird_zambia_threat_richness, amp_zambia_threat_richness, rep_zambia_threat_richness
# load(file = fp(p_datnew,"vertebrate-lists-zambia.RData"), verbose = TRUE) # mam_list, bird_list, amp_list, rep_list
```

## basemaps
```{r epsg-projections}
epsg <- rgdal::make_EPSG()
names(epsg)
epsg %>% filter(str_detect(note, regex("Lambert", ignore_case = TRUE))) 
epsg %>% filter(code == 102022)

aaeac <- st_crs("+proj=aea +lat_1=20 +lat_2=-23 +lat_0=0 +lon_0=25 +x_0=0 +y_0=0 +ellps=WGS84 +datum=WGS84 +units=m +no_defs") # Africa Albers Equal Area Conic projection
crs_saaeac <- st_crs("+proj=aea +lat_1=-5 +lat_2=-42 +lat_0=-32 +lon_0=-60 +x_0=0 +y_0=0 +ellps=aust_SA +units=m +no_defs")  # South 
crs_salcc <- st_crs("+proj=lcc +lat_1=-5 +lat_2=-42 +lat_0=-32 +lon_0=-60 +x_0=0 +y_0=0 +ellps=aust_SA +units=m +no_defs") # South America Lambert Conformal Conic
crs_naaeac <- st_crs("+proj=aea +lat_1=20 +lat_2=60 +lat_0=40 +lon_0=-96 +x_0=0 +y_0=0 +datum=NAD83 +units=m +no_defs")
crs_robinson <- st_crs("+proj=robin +lon_0=0 +x_0=0 +y_0=0 +datum=WGS84 +units=m +no_def")
crs_miller <- st_crs("+proj=mill +lat_0=0 +lon_0=0 +x_0=0 +y_0=0 +R_A +datum=WGS84 +units=m +no_defs")
crs_brazil <- epsg %>% filter(code == 5530) # brazil polygonic
crs_mollweide <- st_crs("+proj=moll +lon_0=0 +x_0=0 +y_0=0")
crs_us <- CRS(filter(epsg, code == 2163)$prj4) # US National Atlas Equal Area: EPSG - 2163
crs_mercator <- st_crs("+proj=merc +a=6378137 +b=6378137 +lat_ts=0.0 +lon_0=0.0 +x_0=0.0 +y_0=0 +k=1.0 +units=m +nadgrids=@null +wktext  +no_defs")

polyconic <- st_crs("+proj=poly +lat_0=0 +lon_0=0 +x_0=0 +y_0=0 +a=6371000 +b=6371000 +units=m +no_defs")

crs_moll_americas <- st_crs("+proj=moll +lon_0=-90 +x_0=0 +y_0=0")

americas %>% 
  st_transform(crs_moll_americas) %>% 
  st_geometry %T>% plot()

equal_earth <- "+proj=eqearth"
str_view(epsg$note, "equal")

help("rnaturalearth")


```

```{r glwd}
# Global Lakes and Wetlands Database

glwd <- st_read(fp(p_dat_water, "GLWD/GLWD-level1/glwd_1.shp"))
st_crs(glwd)
# Set projection to: "Geographic, degrees longitude and latitude" via Lehner & Döll 2004, GLWD Documentation, July 2004
wgs <- epsg %>% 
  filter(code == 4326) # WGS longlat
st_crs(glwd) <- crs_longlat # or, wgs$prj4


glwd_africa <- glwd %>%
  st_intersection(africa) %>% st_cast("MULTIPOLYGON")

glwd_zambia <- glwd %>%
  st_intersection(msk_sf_ll_noholes) %>% st_cast("MULTIPOLYGON") %>%
  st_transform(aaeac)


# clip, reproject, rasterize, etc. --------------------------------------------------------
glwd_zambia_list <- glwd %>%
  cc_make_raster(input_sf = ., clip_area = msk_sf_ll_noholes, prep_zambia = FALSE, run_filter = FALSE)

glwd_zambia <- glwd_zambia_list$reprojected_sf
glwd_zambia_r <- glwd_zambia_list$output_raster

glwd_africa_r <- glwd %>%
  st_intersection(st_union(africa)) %>% st_cast("MULTIPOLYGON") %>%
  st_transform(aaeac) %>%
  fasterize(., msk_extend, fun = 'max') # then rasterize.

glwd_africa_r <- cc_write_reload_raster(glwd_africa_r, "glwd_africa_r", p_basemaps)


# erase glwd from a raster ------------------------------------------------------------------- 
test_r <- hotspots_list$output_raster %>% 
  raster::mask(mask = crop(glwd_zambia_r, extent(.)), inverse = TRUE)
plot(test_r)


# extras ------------------------------------------------------------------

tanganyika <- glwd %>% # filter out Lake Tanganyika
  filter(str_detect(LAKE_NAME, 'Tanganyika'))
plot(st_geometry(tanganyika))

# plot
glwd %>%
  st_transform(aaeac) %>%
  st_simplify(dTolerance = units::set_units(1, degree), preserveTopology = TRUE) %>%
  st_geometry() %T>% plot()

plot(st_geometry(glwd), xlim = msk_shp@bbox[1, ], ylim = msk_shp@bbox[2, ], border = "red")
plot(msk_shp, add = T)

ext <- drawExtent()
plot(st_geometry(glwd), xlim = ext[1:2], ylim = ext[3:4], border = "red")
plot(msk_shp, add = T)

# or...
plot(st_geometry(glwd), xlim = st_bbox(msk_shp)[c(1, 3)], ylim = st_bbox(msk_shp)[c(2, 4)])

st_bbox(msk_shp)[c(1, 3)]


```

```{r world-basemaps}
save(world, africa, americas, zambia_sf, usa, north_america,  # basemaps
     file = fp(p_basemaps,"basemaps.RData"))
load(fp(p_basemaps,"basemaps.RData"), verbose = TRUE)



# ------------------------------------------------------
# maps
# ------------------------------------------------------
install.packages("maps")
library(maps)
world_map <- st_as_sf(map("world", plot = FALSE, fill = TRUE))
states <- st_as_sf(map("state", plot = FALSE, fill = TRUE))
plot(world_map)
st_bbox(world_map)
plot(states)

# ------------------------------------------------------
# maptools and wrld_simpl
# ------------------------------------------------------
library(maptools)
data(wrld_simpl)
class(wrld_simpl)
plot(wrld_simpl)
bbox(wrld_simpl)
plot(spTransform(wrld_simpl, CRS=("+proj=moll +lon_0=0 +x_0=0 +y_0=0")))
plot(wrld_simpl)
names(wrld_simpl)
wrld_simpl$SUBREGION
plot(spTransform(wrld_simpl, CRS=aaeac))
# question for Lyndon - why the heck does this happen? Is there anything that I can do to prevent it? Adding vertices does not seem to help. 

# ------------------------------------------------------
# rnaturalearth and rnaturalearthdata
# ------------------------------------------------------
library(rnaturalearth)
library(rnaturalearthdata)
help(rnaturalearth)
world <- ne_countries(scale = "medium", returnclass = "sf") # can set returnclass to sf or sp.
usa <- ne_countries(scale = "medium", country = "United States of America", returnclass = "sf") # can set returnclass to sf or sp.
north_america <- ne_countries(scale = "medium", continent = "North America", returnclass = "sf") # can set returnclass to sf or sp.

plot(st_transform(north_america, crs_us)$geometry)
plot(st_transform(usa, crs_us)$geometry)

plot(world$geometry)
names(world)
st_bbox(world)
plot(world["continent"])
plot(filter(world, name == "Zambia")) # plotting just Zambia

# graticules
box <- ne_download(scale = 'medium', type = "wgs84_bounding_box", 
                          category = "physical", 
                          #destdir = tempdir(), 
                          load = TRUE, returnclass = "sf")

# ------------------------------------------------------
# americas (world)
# ------------------------------------------------------
levels(as.factor(world$continent))
americas <- world %>%
  filter(continent %in% c("North America", "South America")) # select countries in Africa

plot(st_transform(americas$geometry, crs_moll_americas), border = "red")#, add = T)

americas_u <- st_union(americas)

plot(americas$geometry, add = T)
plot(americas_u, border = "blue")

americas_igh <- world %>%
  filter(continent == c("North America", "South America")) %>% # select countries in Africa
  st_transform("+proj=igh") # transform to Albers Equal Area projection

# ------------------------------------------------------
# africa (world)
# ------------------------------------------------------
africa <- world %>%
  filter(continent == "Africa") # select countries in Africa
plot(st_geometry(africa))
plot(africa$geometry)
plot(st_transform(africa$geometry, aaeac), border = "red", add = T)
plot(msk_shp)

africa_u <- st_union(africa)

plot(africa$geometry, add = T)
plot(africa_u, border = "blue")

plot(st_transform(africa_u, aaeac), border = "blue")
plot(msk_shp, add = T, col = "red")

africa_aaeac <- world %>%
  filter(continent == "Africa") %>% # select countries in Africa
  st_transform(aaeac) # transform to Albers Equal Area projection

plot(st_geometry(africa_aaeac))

africa1 <- st_read(fp(p_datnew, "Africa.shp")) %>%
  st_transform(aaeac)
plot(africa1$geometry, border = "blue")
plot(africa_aaeac$geometry, add = T, border = "red")

plot(st_transform(africa_u, aaeac), border = "blue")

# ------------------------------------------------------
# zambia
# ------------------------------------------------------
zambia_sf <- world %>%
  filter(name == "Zambia") # just Zambia

plot(zambia_sf$geometry)
st_crs(zambia_sf)

# ------------------------------------------------------
# china
# ------------------------------------------------------
china_sf <- world %>%
  filter(name == "China") # 
plot(china_sf$geometry)
plot(china_sf$geometry)
st_crs(china_sf)

# ------------------------------------------------------
# Asia
# ------------------------------------------------------
asia_sf <- world %>%
  filter(continent == "Asia")

plot(asia_sf$geometry)


# ------------------------------------------------------
# raster:getData()
# ------------------------------------------------------
# getData('ISO3') # ZMB is the Zambia country code
Z_latlong <- getData('GADM', country='ZMB', level=0, path='') # load in Zambia from the GADM database
Z <- spTransform(Z_latlong, crs(msk_shp)) # reprojecting to aea
plot(msk_shp)
plot(Z, add = T, col= "red")

# the below attempt to download world boundaries does not work.
world <- getData('countries') # downloading data form UC Davis, all the countries in the world at a higher resolution than the wrld_simpl dataset included in maptools package.
# this doens't work!!!! 

```

### reprojection playground exploration
There is a persistent error involved with reprojecting polygons that straddle the 180 degree longitude (the international date line). Some of the vertices end up getting placed on one side of the map, away from the others, and when they are connected, they create bands that straddle the globe. Some suggested solutions for this were to: 
1. crop the polygons that straddle the date line so that they are only at 179.99 or something.
2. Make sure that the bounding box of the map is only from -180 to 180 degrees longitude. (x min to x max).
3. Add more vertices to the map (via `sf::st_segmentize()`), to avoid really long segments that can sometimes be messed up.
```{r}
# with the US National Atlas projection
states %>% 
  st_transform(us_crs$prj4) %>%
  st_geometry() %T>%
  plot()

world %>%
  st_transform(crs(msk_shp)) %>%
  st_geometry() %T>%
  plot()

plot(st_transform(world, us_crs$prj4))
plot(st_transform(world, "+proj=cea"))


plot(st_transform(filter(world, ID == "Zambia"), us_crs$prj4)) # lol

# with the Zambia projection:
proj4string(msk_shp)
crs(msk_shp)
st_crs(msk_shp)
plot(st_transform(states, crs(msk_shp)))
plot(st_transform(world, crs(msk_shp)))
plot(st_geometry(st_transform(filter(world, ID == "Zambia"), crs(msk_shp))))
plot(pas, add = T)

```


```{r reprojection-errors}
# first, we'll try to fix the banding error, specifically with the hotspots_sf shapefile, filtered to just micronesia
micronesia <- filter(hotspots_sf, NAME == "Polynesia-Micronesia")
st_is_valid(micronesia, reason = TRUE)
st_bbox(micronesia)

tic(); plot(micronesia$geometry); toc()
micronesia$geometry %>% # note the banding error
  st_transform(aaeac) %T>%
  plot() 

# 0. simplifying micronesia
micro_simpl <- st_simplify(micronesia, dTolerance = 0.1, preserveTopology = TRUE) # it throws an error, but seems to work fine. (?)
tic(); plot(micro_simpl$geometry); toc() # this speeds plotting up significantly
micro_simpl$geometry %>%  # banding error remains
  st_transform(aaeac) %T>%
  plot()


# 1. trying to crop to -180 and 180
micro_crop <- st_crop(micronesia, extent(-180.00000, 180.00000, -90, 90))
plot(micro_crop$geometry)
micro_crop$geometry %>% # note the banding error
  st_transform(aaeac) %T>%
  plot(border = "red") 

# 2. trying to add more vertices
micro_seg <- st_segmentize(micronesia, units::set_units(100000, m)) 
micro_crop_seg <- st_segmentize(micro_crop, units::set_units(100, m))
object_size(micronesia)
object_size(micro_simpl)
object_size(micro_crop)
object_size(micro_seg)

tic(); plot(micronesia$geometry); toc()
tic(); plot(micro_seg$geometry); toc() # wow, even just adding more vertices creates a banding problem. 
plot(st_transform(micro_seg$geometry, aaeac), border = "blue") # still doesn't work.
plot(st_transform(micronesia$geometry, aaeac), border = "red")

micronesia$geometry

mapview(micronesia)
mapview(hotspots_sf)
hotspots_sf[41,] %>%
  st_geometry() %T>%
  plot()

micronesia %>%
  st_geometry() %T>%
  plot()

hotspots_sf %>%
  st_geometry() %>%
#  st_transform(crs(msk_shp)) %T>%
#  st_transform("+proj=igh") %T>%
  st_transform("+proj=moll +lon_0=0 +x_0=0 +y_0=0") %T>%
  plot()

plot(spTransform(wrld_simpl, CRS=("+proj=moll +lon_0=0 +x_0=0 +y_0=0")))

test_hotspots <- st_read("/Users/christophercrawford/Desktop/Test/hotspots.shp")

test_hotspots %>%
  st_geometry() %>%
#  st_transform(crs(msk_shp)) %T>%
#  st_transform("+proj=igh") %T>%
#  st_transform("+proj=moll +lon_0=0 +x_0=0 +y_0=0") %T>%
  plot()
# ------------------------------------------------------
# Cropping the edge
# ------------------------------------------------------
world %>%
  st_transform(crs(msk_shp)) %>%
  st_geometry() %T>%
  plot()

st_bbox(world)

plot(st_transform(world, us_crs$prj4))
plot(st_transform(world, "+proj=cea")) # equal area cylindrical
plot(st_transform(world, "+proj=igh")) # interrupted goode homolosine
plot(st_transform(world, "+proj=robin")) #
plot(st_transform(world, "+proj=moll +lon_0=0 +x_0=0 +y_0=0 +ellps=WGS84 +units=m +no_defs")) # mollweide
plot(st_transform(world, "+proj=eqearth +wktext")) # work around for equal earth 


# ok - crop the edge
MEco <- sf::st_crop(MEco,c(ymin = -89.99, ymax = 89.99, xmin=-179.99, xmax=179.99))

w <- crop(wmap, extent(-180, 180,-90,90))
w_robin <- spTransform(w, CRS("+proj=robin"))
plot(w_robin)

library(sp)
library(maps)
library(maptools)
worldmap <- map("world", plot=F)
plot(worldmap, type = "l")
class(worldmap)
worldmapLines <- map2SpatialLines(worldmap, proj4string=CRS("+proj=longlat +datum=WGS84"))

plot(worldmapLines)
bbox(worldmapLines)
worldM <- spTransform(worldmapLines, CRS("+proj=moll +lon_0=0 +x_0=0 +y_0=0 +ellps=WGS84 +units=m +no_defs"))
plot(worldM)

library(raster)
w1 <- crop(worldmapLines, extent(-180, 180,-90,90))
plot(worldmapLines)
plot(w1)
w2 <- crop(worldmapLines, extent(180.00000001, 191,-90,90))
plot(w2)
bbox(w2)

w2 <- raster::shift(w2, -360)
w <- bind(w1, w2)
plot(w)
x <- spTransform(w, CRS("+proj=moll +lon_0=0 +x_0=0 +y_0=0 +ellps=WGS84 +units=m +no_defs"))
z <- spTransform(w, crs(msk_shp))
plot(x)
plot(w)
plot(z)
x_sf <- st_as_sf(x)
st_is_valid(x_sf)
plot(x_sf)

# trying it in sf
hotspots_sf %>% 
  st_transform(aaeac) %>%
  st_geometry() %T>%
  plot()

st_bbox(hotspots_sf)
hotspots_aaeac <- st_transform(hotspots_sf, aaeac)
plot(st_geometry(hotspots_aaeac))

micronesia
st_crs(hotspots_sf)
hotspots_sf_crop_170 <- st_crop(hotspots_sf, extent(-180.00000, 160.00000, -90, 90))

st_bbox(hotspots_sf_crop)
hotspots_sf_crop_170 %>% 
  st_transform(crs(msk_shp)) %>%
#  st_transform("+proj=igh") %>%
  st_geometry() %T>%
  plot()


plot(st_geometry(st_transform(hotspots_sf ,crs(msk_shp))))
plot(st_geometry(st_transform(box ,crs(msk_shp))), add = T, border = "red")

hotspots_sf_crop_170
st_bbox(hotspots_sf_crop_170)

plot(st_geometry(hotspots_sf_crop_170))

# trying to reproject world again
plot(world)
st_bbox(world_valid)

world %>%
  #st_transform("+proj=moll") %>%
  st_geometry() %T>%
  plot()

st_is_valid(world, reason = TRUE)
world_valid <- st_make_valid(world)
plot(world_valid)
w1 <- st_crop(world_valid, extent(-180, 180,-90,90))
plot(w1)
w2 <- st_crop(world_valid, extent(180.00000001, 191,-90,90))
plot(w2)

w2 <- extent(-180, 180,-90,90)
w2 <- raster::shift(w2, -360)
w <- bind(w1, w2)
plot(w)
x <- spTransform(w, CRS("+proj=moll +lon_0=0 +x_0=0 +y_0=0 +ellps=WGS84 +units=m +no_defs"))
plot(x)
st_bbox(bird_threat_sf)
```


### worldRaster
```{r}
### the example world raster, following methods described by Amy Whitehead, from https://amywhiteheadresearch.wordpress.com/2014/05/01/shp2raster/
library(biomod2)
worldRaster <- raster(system.file("external/bioclim/current/bio3.grd", package = "biomod2"), resolution = c(1, 1))
worldRaster[!is.na(worldRaster)] <- 0
plot(worldRaster, col = "grey")

### reprojecting
worldRaster_aea_coarse <- projectRaster(worldRaster, crs = crs(msk)) # without fussing with the resolution
plot(worldRaster_aea_coarse)
# use this one for creating a base raster

worldRaster_aea <- projectRaster(worldRaster, crs = crs(msk), res = c(1000, 1000)) # this time, resetting the resolution to 1000 x 1000 m, i.e. 1 x 1 km.
# this results in the following errors:
# Warning messages:
# 1: In rgdal::rawTransform(projto_int, projfrom, nrow(xy), xy[, 1],  :
#   2069694 projected point(s) not finite
# Do not use this one.
rm(worldRaster_aea)

res(worldRaster)
res(worldRaster_aea_coarse)

extent(worldRaster)
extent(worldRaster_aea_coarse)

###############
# other methods for changing resolution, including aggregate() and disaggregate()
wR <- disaggregate(worldRaster, fact = 3) # making this higher resolution.
res(wR)
plot(wR)
```


### Other basemaps (unused)
```{r}
library(maptools)
data(wrld_simpl)
class(wrld_simpl)
plot(wrld_simpl)
bbox(wrld_simpl)
plot(spTransform(wrld_simpl, CRS=("+proj=moll +lon_0=0 +x_0=0 +y_0=0")))

install.packages("rnaturalearth", "rnaturalearthdata")
library(rnaturalearth)
library(rnaturalearthdata)
world <- ne_countries(scale = "medium", returnclass = "sf") # can set returnclass to sf or sp.
names(world)
plot(world["continent"])
plot(filter(world, name == "Zambia")) # plotting just Zambia

africa_aaeac <- world %>%
  filter(continent == "Africa") %>% # select countries in Africa
  st_transform(crs(msk_shp)) # transform to Albers Equal Area projection

plot(st_geometry(africa_aaeac))
# Africa <- dplyr::summarize(Africa, )

# just the continent of Africa
Africa <- st_read(fp(p_datnew, "Africa.shp")) %>%
  st_transform(crs(msk_shp))

plot(Africa)

world$economy
plot(world["economy"]) # way to plot sf objects. need to specify which of the attributes you plot. 
plot(world)
names(world)

# getData('ISO3') # ZMB is the Zambia country code
Z_latlong <- getData('GADM', country='ZMB', level=0, path='') # load in Zambia from the GADM database
Z <- spTransform(Z_latlong, crs(msk_shp)) # reprojecting to aea
plot(msk_shp)
plot(Z, add = T, col= "red")

# the below attempt to download world boundaries does not work.
world <- getData('countries') # downloading data form UC Davis, all the countries in the world at a higher resolution than the wrld_simpl dataset included in maptools package.


```

From Vijay Ramesh // SCCS-NY
```{r}
# Multiple options of loading data: from SCCS workshop on using R for spatial analysis. See (/Users/christophercrawford/Google Drive/R/R_GIS/SCCS_2017/3_UsingRasterData_SCCS.R)
# 1. Downloading layers for the entire globe at a coarse resolution

r_clim <- getData('worldclim',var='bio', res= 2.5)
# ?getData # Explore getData in detail to see what datasets one can download
r_clim

plot(r_clim$bio1, main = "Annual Mean Temperature", ext = ext1) # note there are a bunch of variables (19) here... maybe just plot one of them?
crs(r_clim)
1/res(r_clim$bio1)[1]
110*res(r_clim$bio1)[1]
ext1 <- drawExtent(show=T, col = "red")
ext1

r_clim_hi <- getData('worldclim',var='bio', res=0.5, lon=30, lat=-15)
plot(r_clim_hi$bio1_37)


# 2. Downloading a tile based on the location of your interest
# Simply add in a lat/lon for a location you want to look at (you generally get a MUCH bigger tile encompassing your location)

env<-getData(name="worldclim", var="bio", res=0.5, download=T, lat=10, lon=75)
plot(env) # Visualizing the 19 bioclimatic layers 
env

# Below section is optional depending on the need to stitch multiple tiles (if your locations don't fall within a single tile)
# Merge function from the raster package can be used to stitch multiple tiles if needed
# Try below example if you would like to see how merge works
# Downloaded multiple tiles for a different region of the world 
env1<-getData(name="worldclim", var="bio", res=0.5, download=T, lat=36, lon=-78)
env2<-getData(name="worldclim", var="bio", res=0.5, download=T, lat=36, lon=-100)
env3<-getData(name="worldclim", var="bio", res=0.5, download=T, lat=20, lon=-78)
env4<-getData(name="worldclim", var="bio", res=0.5, download=T, lat=20, lon=-100)

# Merge the four tiles into one rasterstack called envall
# Or simply use the mosaic function in the raster package

env12<-merge(env1, env2)
enva123<-merge(env12, env3)
envall<-merge(env123, env4)
```

Reprojecting these other various world rasters
```{r}
# world clim map
plot(r_clim$bio1, main = "Annual Mean Temperature") # note there are a bunch of variables (19) here... maybe just plot one of them?
crs(r_clim)

r_clim_bio1 <- r_clim$bio1

msk
stopifnot(proj4string(r_clim) == proj4string(msk))
r_clim_aea <- projectRaster(r_clim, crs = crs(msk)) 
# this throws a lot of errors...might not work well as a stack?
proj4string(msk)
crs(msk)

plot(r_clim_aea$bio1, main = "Annual Mean Temperature") # seems to plot ok?
plot(msk_shp, add = T)

r_clim_bio1_aea <- projectRaster(r_clim_bio1, crs = crs(msk))
# again, throws error: 
# Warning message:
# In rgdal::rawTransform(projto_int, projfrom, nrow(xy), xy[, 1],  :
#   480134 projected point(s) not finite
# Note, from here: https://gis.stackexchange.com/questions/204533/re-projecting-raster-in-r-gives-warning-that-projected-points-not-finite
# "In general data is lost and distorted during reprojection of rasters from longlat to equal area projections. This can be problematic for global analysis. If you can get your data in vector format, it is better to reproject using that format instead."
plot(r_clim_bio1_aea, main = "Annual Mean Temperature", ext = msk_shp@bbox) # seems to plot ok?
plot(msk_shp, add = T)



```

gdal stuff
```{r}
Sys.which('gdal_polygonize.py')
# the empty string means that R doesn't know where to find the gdal python script. So, the idea was that I had to update the PATH variable (check what is listed by going into a terminal and typing 'echo $PATH'. But, I did that, using the method on this page: https://tilemill-project.github.io/tilemill/docs/guides/gdal/, and it didn't work. So, back to the drawing board. 
# In lots of functions, I can specify where to find the python script, which is what I did in recreating lyndon's polygonize function script. 
```

## Laurance layers
```{r load-laurance-layers}
# the original Laurance data, cropped to Africa
s1_Af <- raster(fp(p_datnew, "Laurance/s1_Af.tif"))
s2_Af <- raster(fp(p_datnew, "Laurance/s2_Af.tif"))
s3_Af <- raster(fp(p_datnew, "Laurance/s3_Af.tif"))
s4_Af <- raster(fp(p_datnew, "Laurance/s4_Af.tif"))
s5_Af <- raster(fp(p_datnew, "Laurance/s5_Af.tif"))
s6_Af <- raster(fp(p_datnew, "Laurance/s6_Af.tif"))
s7_Af <- raster(fp(p_datnew, "Laurance/s7_Af.tif"))
s8_Af <- raster(fp(p_datnew, "Laurance/s8_Af.tif"))

# the _Af rasters cropped by the 10km buffer, using gdalwarp() to crop and reproject at the same time.
s1_ZA <- raster(fp(p_datnew, "s1_ZA.tif"))
s2_ZA <- raster(fp(p_datnew, "s2_ZA.tif"))
s3_ZA <- raster(fp(p_datnew, "s3_ZA.tif"))
s4_ZA <- raster(fp(p_datnew, "s4_ZA.tif"))
s5_ZA <- raster(fp(p_datnew, "s5_ZA.tif"))
s6_ZA <- raster(fp(p_datnew, "s6_ZA.tif"))
s7_ZA <- raster(fp(p_datnew, "s7_ZA.tif"))
s8_ZA <- raster(fp(p_datnew, "s8_ZA.tif"))

# resampled rasters (raster::resample())
s1_ZA_resample <- raster(fp(p_datnew, "s1_ZA_resample.tif"))
s2_ZA_resample <- raster(fp(p_datnew, "s2_ZA_resample.tif"))
s3_ZA_resample <- raster(fp(p_datnew, "s3_ZA_resample.tif"))
s4_ZA_resample <- raster(fp(p_datnew, "s4_ZA_resample.tif"))
s5_ZA_resample <- raster(fp(p_datnew, "s5_ZA_resample.tif"))
s6_ZA_resample <- raster(fp(p_datnew, "s6_ZA_resample.tif"))
s7_ZA_resample <- raster(fp(p_datnew, "s7_ZA_resample.tif"))
s8_ZA_resample <- raster(fp(p_datnew, "s8_ZA_resample.tif"))

# process using focal and masks to get a filled and cleaned raster, which was then normalized, producing the final versions:
s1_ZA_clean <- raster(fp(p_datnew,"s1_ZA_clean.tif"))
s2_ZA_clean <- raster(fp(p_datnew,"s2_ZA_clean.tif"))
s3_ZA_clean <- raster(fp(p_datnew,"s3_ZA_clean.tif"))
s4_ZA_clean <- raster(fp(p_datnew,"s4_ZA_clean.tif"))
s5_ZA_clean <- raster(fp(p_datnew,"s5_ZA_clean.tif"))
s6_ZA_clean <- raster(fp(p_datnew,"s6_ZA_clean.tif"))
s7_ZA_clean <- raster(fp(p_datnew,"s7_ZA_clean.tif"))
s8_ZA_clean <- raster(fp(p_datnew,"s8_ZA_clean.tif"))

# these ones are the resulting final versions, which had been smoothed over, to fix the mismatch
s1 <- raster(fp(p_datnew, "s1.tif"))
s2 <- raster(fp(p_datnew, "s2.tif"))
s3 <- raster(fp(p_datnew, "s3.tif"))
s4 <- raster(fp(p_datnew, "s4.tif"))
s5 <- raster(fp(p_datnew, "s5.tif"))
s6 <- raster(fp(p_datnew, "s6.tif"))
s7 <- raster(fp(p_datnew, "s7.tif"))
s8 <- raster(fp(p_datnew, "s8.tif"))
```

explore  layers:
```{r explore-laurance-layers}
s1_Af # the original Laurance data, cropped to Africa
s4_Af

s1_ZA # the _Af rasters cropped by the 10km buffer, using gdalwarp() to crop and reproject at the same time.
s4_ZA

s1_ZA_resample # resampled rasters (raster::resample())
s4_ZA_resample

s1_ZA_clean # process using focal and masks to get a filled and cleaned raster, which was then normalized, producing the final versions:
s4_ZA_clean

s1 # these ones are the resulting final versions, which had been smoothed over, to fix the mismatch
s4

par(mfrow=c(2,2))
dev.off()

plot(s1)

plot(s4_ZA, ext = ext3)
plot(msk_shp, add = T)
ext3 <- drawExtent(show = T, col = "blue")

plot(s4_ZA_resample, ext = ext3)
plot(msk_shp, add = T)

plot(s4_ZA_clean, ext = ext3)
plot(msk_shp, add = T)

plot(s4, ext = ext3)
plot(msk_shp, add = T)
```

### layer descriptions
Sub Layer 1 - Integrated Biodiversity Layer
**s1.** IUCN Red-Listed threatened terrestrial vertebrate species (birds, mammals, amphibians) per pixel (1km2) (species richness). [Original data sources: @IUCN2012, BirdLife International, @Stuart2004, @Schipper2008]. [Supplementary Figure 1](http://www.globa l-roadmap.org/s/s1.jpg)

**s2.** Plant species per pixel (plant species richness). Estimated number of plant species per ecoregion globally, adjusted for ecoregion area (no. species 10,000-km-2). [Original data source: @Kier2005]. [Supplementary Figure 2](http://www.global-roadmap.org/s/s2.jpg)

**s3.** Integrated biodiversity layer, the mean of s1 and s2 (each rescaled between 0 and 1). [Supplementary Figure 3](http://www.global-roadmap.org/s/s3.jpg)

Sub layer 2 – Key Habitats and Wilderness 
**s4.** Biodiversity hotspots - 35 Conservation International hotspots. [Original data source: Conservation International]. [Source: @Myers2000, @Zachos2011]. [Supplementary Figure 4](http://www.global-roadmap.org/s/s4.jpg).

**s5.** Key bird habitats, combining Important Bird Areas and Endemic Bird Areas from BirdLife International. [Sources: @Butchart2012, @Stattersfield1998]. [Supplementary Figure 5](http://www.global-roadmap.org/s/s5.jpg)

**s6.** Distribution of WWF's The Global 200 terrestrial ecoregions across Earth’s land surface. [Source: @Olson2001]. [Supplementary Figure 6](http://www.global-roadmap.org/s/s6.jpg)

**s7.** Key wilderness and biodiversity areas. [Source: @Mittermeier2003, @Bryant1997]. [Supplementary Figure 7](http://www.global-roadmap.org/s/s7.jpg)

**s8.** Integrated key habitats and wilderness layer: s4-7 each weighted by 0.25 and combined. [Supplementary Figure 8](http://www.global-roadmap.org/s/s8.jpg)
    + `s4*0.25 + s5*0.25 + s6*0.25 + s7*0.25`

Plotting tips n stuff
```{r}
plot(msk_shp)
plot(one)
length(one@data)
length(m$category)
head(m)

names(m@data) # attribute headers
# writeOGR(pas, dsn = fp(p_basedat,"ZA-pas.shp"), layer="pas", driver="ESRI Shapefile") # in case you want to write a shapefile to a file.

# subset National Parks and GMAs and plot them together
nparks <- pas[pas$type == "npark", ]
gmas <- pas[pas$type == "gma", ]
plot(msk_shp)
plot(nparks, col = "light green", add=TRUE)
plot(gmas, col = "brown", add=TRUE)
# pas@data # to view the attribute table
text(pas, pas$npark_name, cex=1)
text(pas, pas$gma_name, cex=1)
legend("bottomright", legend=levels(pas$type), fill=c("brown","light green"))

head(pas@data)
length(pas@data)
names(pas@data)
levels(pas$type)
summary(pas$type)


# or, just plot it classified.
col_pas <- c("brown","light green")
col_pas_all <- c("brown","light green")[pas$type] # this sets up the colors based on a particular attribute, in this case, "type" . See levels(pas$type) to view the order in which the colors will be assigned to the values. 
plot(msk_shp)
plot(pas, col = col_pas_all, add=T)
legend("bottomright", legend=levels(pas$type), fill = col_pas)

# others:
plot(msk_shp)
plot(pas,add=T)



# here's two ways to tell if the data are in the same projection or not. this is critical!
ifelse(proj4string(zambia) == proj4string(msk),"Match", "Don't Match")
stopifnot(proj4string(zambia) == proj4string(msk))

```

## sf sandbox
```{r}
nc <- st_read(system.file("shape/nc.shp", package="sf"))
plot(st_geometry(nc))
st_geometry(nc) %>% class()
st_geometry(nc) %>% attributes()

library(viridis)
library(rvest)

ggplot(nc) +
  geom_sf(aes(fill = AREA)) +
  scale_fill_viridis("Area") +
  ggtitle("Area of counties in North Carolina") +
  theme_bw()


```


```{r IUCN RedList}
redlist_assessments_lc <- read_csv("/Users/christophercrawford/Google Drive/_Projects/data/Bd/IUCN_RedList/RedList_LC_Plants+Animals_allregions/assessments.csv")
redlist_assessments_nonlc <- read_csv("/Users/christophercrawford/Google Drive/_Projects/data/Bd/IUCN_RedList/RedList_NonLC_Plants+Animals_allregions/assessments.csv")
redlist_assessments <- rbind(redlist_assessments_lc, redlist_assessments_nonlc)

redlist_summary_lc <- read_csv("/Users/christophercrawford/Google Drive/_Projects/data/Bd/IUCN_RedList/RedList_LC_Plants+Animals_allregions/simple_summary.csv")
redlist_summary_nonlc <- read_csv("/Users/christophercrawford/Google Drive/_Projects/data/Bd/IUCN_RedList/RedList_NonLC_Plants+Animals_allregions/simple_summary.csv")
redlist_summary <- rbind(redlist_summary_lc, redlist_summary_nonlc)

names(redlist_assessments)
names(redlist_summary)
View(redlist_assessments)
View(redlist_summary)


# What's the key?
redlist_summary %>% count(scientificName) %>% filter(n > 1) # two entries for Crocidura canariensis
redlist_assessments %>% count(scientificName) %>% filter(n > 1) # two entries for Crocidura canariensis

redlist_summary %>% count(internalTaxonId) %>% filter(n > 1) # two entries for 5560 (which is Crocidura canariensis, the Canary shrew)
redlist_assessments %>% count(internalTaxonId) %>% filter(n > 1) # same as above. 


# join the two tables
redlist_summary_w_assessments <- 
  redlist_summary %>% # by = c("key x" = "key y"), or by = "key"
  left_join(redlist_assessments, by = "scientificName")

names(redlist_summary_w_assessments)

select(filter(redlist_summary_w_assessments, assessmentId.x!=assessmentId.y), assessmentId.x, assessmentId.y, scientificName)
redlist_summary_w_assessments %>% count(internalTaxonId.y) %>% filter(n > 1) # same as above. 

all(as.character(bird_table_join1[['SCINAME']]) == as.character(bird_table_join1[['ScientificName']])) # this works because I've changed the factors to characters 

# filter out birds, and then filter out non-marine systems
as_tibble(redlist_summary_w_assessments)
summary(as.factor(redlist_summary_w_assessments$className))
redlist_aves <- filter(redlist_summary_w_assessments, className == "AVES")
redlist_aves %>% count(internalTaxonId.x) %>% filter(n > 1) # all unique
glimpse(redlist_aves)

summary(as.factor(redlist_aves$systems))
systems <- unique(redlist_aves$systems)
redlist_aves %>% filter(systems == "Marine") %>% 

systems <- systems[1:4, , -8, ]
redlist_terr <- filter(redlist_assessments, systems %in% c())
```


# 1. Threatened Vertebrate Richenss Raster
Data sources: 
Mammals, Reptiles, Amphibians: IUCN Redlist
Birds: BirdLife International

General Steps:

- Review source data
- Load in data
- Explore data
- Separate out species by IUCN threat classification (we want all threatened species, so, all but LC).
- Select only terrestrial species
- Create raster by overlaying polygons, counting the number of co-occuring species.
- use `raster::aggregate` to convert raster to a coarser scale (lower resolution)

Note: the mammals shapefile looks like it might just have the CR species, not just all of them. The Terrestrial mammals shp looks like it has all of the categories.

One of the things I've been exploring is how to work with very large files in R. Loading the set of range polygons for all mammal species is tough - it's something like 13000 polygons, for 5700 species. This is a 2.4 gb file! Loading the shapefile in using `readOGR()` reads the shapefile as a SpatialPolygonsDataFrame (a `Spatial` object, sometimes called a Spatial* object). If I read it in with `sf`, then 

## I. mammals
Exploration
```{r mam-start}
# Load preped rdata  ----------------------------------------------------------


# ----------------------------------
mam_sf <- st_read(fp(p_mam,"MAMMALS.shp"))
# Faster than reading in shapefiles as spatial* objects using readOGR(), and loads the file in as an sf object. readOGR (for shapefiles, points, and lines) produces Spatial* objects, and sf produces "simple feasture collections" which in this case is geometry type multipolygon. Using the function read_sf() is basically the same, but it doesn't provide the output.

glimpse(mam_sf) # to examine the file. similar to: 
str(mam_sf)
as_tibble(mam_sf) # converting to a tibble to view more easily. This is similar to head(), but a little easier to read.
head(mam_sf)

class(mam_sf) # basic exploring the data
names(mam_sf) # the variables
length(mam_sf$category) #how many records? 13,086
unique(mam_sf$island)

st_geometry(mam_sf)

# how many records have origins or seasonal codes outside the ones I use?
mam_valid # 13086
nrow(mam_valid) # 13086

mam_valid %>% filter(presence == 1) %>% nrow() # 12080, only records with Code 1 (Extant) 
mam_valid %>% filter(origin %in% c(1, 2)) %>% nrow() # 12778, only native species (Code 1) and reintroduced (Code 2)
mam_valid %>% filter(seasonal %in% c(1, 2, 3)) %>% nrow() # 13048, selecting "Resident" (1), "Breeding" (2), and "Non-breeding Season" (3) ranges. Other categories include: Passage (4), and Seasonal Occurrence Uncertain (5).
```

```{r mam-valid-par}
tic("full script")
library(sf)
library(lwgeom)
library(dplyr)
library(tictoc)
library(parallel)
library(pryr)

tic("load data")
dat <- st_read(dsn = "/Users/christophercrawford/Google Drive/_Projects/data/Bd/IUCN_RedList/MAMMALS/MAMMALS.shp")
toc(log = TRUE)

tic("add row number")
dat <- dat %>%
  mutate(key = row_number()) %>%
  select(key, everything())
toc(log = TRUE)

print("dat object size")
object_size(dat)

# see cc_functions.R for cc_make_valid()
tic("run in parallel")
dat <- mclapply(seq(1, nrow(dat), by = 100), function(i) cc_make_valid(dat[i:(i+99), ]), mc.cores = 8)
toc(log = TRUE) #1512 seconds (25 minutes)

print("dat object size par list")
object_size(dat)
print("length of dat par list")
length(dat)
dat[[1]]

tic("recombine")
dat <- do.call("rbind", dat)
toc(log = TRUE)

print("object size post recombination")
object_size(dat)
toc(log = TRUE)

nrow(dat)

# drop NA geometries:
nrow(dat)
dat <- filter(dat, !is.na(id_no))
nrow(dat)

mam_valid <- dat
tic("write dat_par file")
save(mam_valid, file = "/Users/christophercrawford/Google Drive/_Projects/Zambia/agroEcoTradeoff/external/data_new/1_IUCN_dev/mam_valid_par.RData")
toc(log = TRUE)

toc(log = TRUE)


tic.log(format = TRUE)
```


```{r mam-prep}
# ------------------------------------------------------------
# code to prepare the sf file for the creation of 1) small-ranged species richness, 2) weighted endemism richness, and 3) threat-weighted species richness. This involves calculating polygon areas, summing to determine the total range area (excluding parts of the range we aren't considering), ordering the species by range size and giving the rank order (normalized to between 0-1). This also involves calculating the inverse of the global range size and the threat category weight.
# ------------------------------------------------------------

# Mammals -------
load(file = "/Users/christophercrawford/Google Drive/_Projects/Zambia/agroEcoTradeoff/external/data_new/1_IUCN_dev/mam_valid_par.RData", verbose = TRUE) # includes mam_valid (1.62 gb), which was made in the chunk "mam-valid-par". This is the one I used going forward.


#####
# add a new column for area -------------
tic("add area") ### note that I had to change "geometry" to "Shape" for birds
mam_valid <- mam_valid %>%
  mutate(., area_km2 = st_area(.["geometry"]) %>% units::set_units(km^2)) # area, caluclated from polygons in long lat projection
toc() # 62.259 sec for mam_valid


# ----------------------------------------------------------
# subset to only those ranges used in analysis, including removing the Extinct or Extinct in the Wild species ("EW", "EX")
# then, group by species, and calculate the sum of the various polygons, i.e. the total range area for each species. 
mam_valid_summary <- mam_valid %>%   # assign dat to a new object, to then be modified
  st_drop_geometry() %>%
  filter(presence == 1) %>%   # only records with Code 1 (Extant)
  filter(origin %in% c(1, 2)) %>%     # only native species (Code 1) and reintroduced (Code 2)
  filter(seasonal %in% c(1, 2, 3)) %>%   # selecting "Resident" (1), "Breeding" (2), and "Non-breeding Season" (3) ranges. Other categories include: Passage (4), and Seasonal Occurrence Uncertain (5).
  filter(marine == "False") %>%   # removing all marine species
  filter(!category %in% c("EW", "EX")) %>% # remove Extinct or Extinct in the Wild species ("EW", "EX")
  group_by(binomial) %>%
  dplyr::summarize(total_range_area = sum(area_km2, na.rm = TRUE), n_polygons = n())

nrow(mam_valid_summary) # 5527 species, odd number of rows (5529 minus 2 EX or EW species: Elaphurus davidianus, and Melomys rubicola)

  
### what are the summary statistics? What is the median, 1st quartile, etc?
quantile(mam_valid_summary$total_range_area, probs = c(0.25, 0.5, 0.75)) 
# 1st quartile: 17449.38 km2 (old pre dropping EW EX: 17400.28 km2)
# 2nd quartile: 170,594.24 km2 (old pre dropping EW EX: 170568.45 km2
# 3rd quartile: 1,089,500.88 km2 (old pre dropping EW EX: 1088892.35 km2

# ------------------------------------------------------------
# add column to put the species in order of range size, counting upwards from the smallest range, and add a second column dividing by the total number of species
mam_valid_summary <- mam_valid_summary %>%
  arrange(total_range_area) %>%
  mutate(range_size_quantile = row_number()/max(row_number()))
  
nrow(mam_valid_summary) # 5527, odd, so do <, not <=
tail(mam_valid_summary)

mam_valid_summary %>% 
  filter(range_size_quantile < 0.5) %>% # do <= if nrow is even, and < if nrow is odd.
  arrange(desc(total_range_area)) %>%
  nrow() # 2763
nrow(mam_valid_summary)/2

# ------------------------------------------------------------
# join total range area back to original sf object
names(mam_valid_summary)
mam_valid <- mam_valid %>% # by = c("key x" = "key y")
  left_join(mam_valid_summary, by = c("binomial" = "binomial"))

# ------------------------------------------------------------
# calculate inverse_range_glob & 
# threat status weight (based on Damania & Wheeler 2015, Veach et al. 2017):
# ---- weights, from Mooers et al. 2008, following Isaacs et al. 2007: 
# ---- Critically endangered (CR) = 1; Endangered (EN) = 1/2; Vulnerable (VU) = 1/4; Near Threatened (NT) = 1/8; Least Concern (LC) = 1/16. Data deficient (DD) = NA.
# ---- Veach et al 2017 use the following weights: Critically endangered = 8; Endangered = 6; Vulnerable = 4; Near Threatened = 2; Least Concern = 1; Data Deficient = 4 (Pouzols et al., 2014)

mam_valid <- mam_valid %>% 
  mutate(inverse_range_glob = 1/total_range_area) %>% 
  mutate(threat_weight = 
           ifelse(category == "CR", 1,    # if CR then 1, if not, then ->
           ifelse(category == "EN", 1/2,  # if EN then 1/2, if not, then ->
           ifelse(category == "VU", 1/4,  # if VU then 1/4, if not, then ->
           ifelse(category == "NT", 1/8,  # if NT then 1/8, if not, then ->
           ifelse(category == "LC", 1/16, # if LC then 1/16, if not, then ->
           ifelse(category == "DD", 1/4, NA))))))) # if DD then 1/4 (a middle ground, conservative estimate). If not, then -> NA. This means that EW, EX are all set to NA.

# testing to make sure things look good. 
names(mam_valid)
mam_valid %>% 
  st_drop_geometry() %>%
  .[1:20, c(3, 23, 31:33, 35:36)]

### Now you can use it to filter to only "small-ranged species," those species with total range areas of less than the median (or the 1st quartile, whatever method you decide)

mam_valid %>% 
  filter(range_size_quantile < 0.5) %>% # do <= if nrow is even, and < if nrow is odd.
  arrange(desc(total_range_area)) %>%
  nrow()

nrow(mam_valid)
object_size(mam_valid)


# ------------------------------------------------------------
# save the file
save(mam_valid, file = "/Users/christophercrawford/Google Drive/_Projects/Zambia/agroEcoTradeoff/external/data_new/1_IUCN_dev/mam_valid_prepped.RData") # contains mam_valid (1.62 gb), but prepped for use in small species, etc. This entailed joining the table of red list categories, changing some of the column names, adding a column for area, totalling area for parts of the range we're using, and adding a column ranking the range size to allow things to be subset for small ranged species analyses.


#####
# >>>> now, it's ready to be put through cc_make_raster
#####
```

```{r missing_sp}
mam_valid %>% filter(binomial == "Loxodonta africana") %>% st_geometry() %T>% plot()


mam_valid %>% filter(binomial == "Lynx pardinus") %>% st_geometry() %T>% plot()
mam_valid %>% filter(binomial == "Hylobates muelleri") %>% st_geometry() %T>% plot()

iucn <- read_csv(file = "/Users/christophercrawford/Google Drive/_Projects/data/Bd/IUCN_RedList/RedList_NonLC_Plants+Animals_allregions/assessments.csv")

names(iucn)
iucn %>% filter(scientificName == "Loxodonta africana")
iucn %>% filter(scientificName == "Lynx pardinus")
iucn %>% filter(scientificName == "Hylobates muelleri")

```


```{r mam-clip}
# load prepped mam_valid
load("/Users/christophercrawford/Google Drive/_Projects/Zambia/agroEcoTradeoff/external/data_new/1_IUCN_dev/mam_valid_prepped.RData", verbose = TRUE)

# --------------------------------------------------------
# clip to Zambia
mam_zambia <- mam_valid %>%
  st_intersection(., st_union(msk_sf_ll_noholes)) %>%
  st_collection_extract(., "POLYGON") # extract only polygons


# -------------------------------------------------------------
# calculate area of clipped polygons in Zambia (calculated in long lat projection)
mam_zambia <- mam_zambia %>%
  mutate(area_zambia_km2 = st_area(.["geometry"]) %>% units::set_units(km^2)) 


# -------------------------------------------------------------
# subset to only those ranges used in analysis, then 
# group by species and sum across polygons to get species' total range area in Zambia

mam_zambia_summary <- mam_zambia %>%   # assign dat to a new object, to then be modified
  st_drop_geometry() %>%
  filter(presence == 1) %>%   # only records with Code 1 (Extant)
  filter(origin %in% c(1, 2)) %>%     # only native species (Code 1) and reintroduced (Code 2)
  filter(seasonal %in% c(1, 2, 3)) %>%   # selecting "Resident" (1), "Breeding" (2), and "Non-breeding Season" (3) ranges. Other categories include: Passage (4), and Seasonal Occurrence Uncertain (5).
  filter(marine == "False") %>%   # removing all marine species, except for bird species
  filter(!category %in% c("EW", "EX")) %>% # remove Extinct or Extinct in the Wild species ("EW", "EX")
  group_by(binomial) %>%
  dplyr::summarize(total_zambia_range_area = sum(area_zambia_km2, na.rm = TRUE), n_polygons = n())

nrow(mam_zambia_summary) # 252 species, even number of rows

  
# what are the summary statistics? What is the median, 1st quartile, etc?
quantile(mam_zambia_summary$total_zambia_range_area, probs = c(0.25, 0.5, 0.75)) 
# update for each taxonomic group
# 1st quartile: 35,382.12 km2 (global: 17449.38 km2)
# 2nd quartile: 360,085.19 km2 (global: 170,594.24 km2)
# 3rd quartile: 642,749.46 km2 (global: 1,089,500.88 km2)


# ------------------------------------------------------------
# add column to put the species in order of range size, 
# counting upwards from the smallest range, and add a second column 
# dividing by the total number of species
mam_zambia_summary <- mam_zambia_summary %>%
  arrange(total_zambia_range_area) %>%
  mutate(range_size_quantile_zambia = row_number()/max(row_number()))
  
nrow(mam_zambia_summary) # 252
tail(mam_zambia_summary)

median(mam_zambia_summary$total_zambia_range_area)

mam_zambia_summary %>% 
  filter(range_size_quantile_zambia <= 0.5) %>% # do <= if nrow is even, and < if nrow is odd.
  arrange(desc(total_zambia_range_area)) #%>%
  nrow() # 125
nrow(mam_zambia_summary)/2

# ------------------------------------------------------------
# join total Zambia range area back to clipped sf object
names(mam_zambia_summary)
mam_zambia <- mam_zambia %>% # by = c("key x" = "key y")
  left_join(mam_zambia_summary, by = c("binomial" = "binomial"))



# -------------------------------------------------------------
# calculate the inverse of the range in Zambia
mam_zambia <- mam_zambia %>%
  mutate(inverse_range_zam = 1/total_zambia_range_area) 


# -------------------------------------------------------------
save(mam_zambia, file = "/Users/christophercrawford/Google Drive/_Projects/Zambia/agroEcoTradeoff/external/data_new/1_IUCN_dev/mam_zambia.RData") # includes mam_zambia, which has had area added, been prepped, and then clipped to zambia





# -------------------------------------------------------------
# extras

msk_sf_ll_4deg_buff

mam_zambia_4deg_buff <- mam_valid %>%
  st_intersection(., st_union(msk_sf_ll_4deg_buff)) %>%
  st_collection_extract(., "POLYGON")
plot(mam_zambia_4deg_buff$geometry)
save(mam_zambia_4deg_buff, file = "/Users/christophercrawford/Google Drive/_Projects/Zambia/agroEcoTradeoff/external/data_new/1_IUCN_dev/mam_zambia_4deg_buff.RData") # includes mam_zambia, which has had area added, been prepped, and then clipped to zambia

```


Endemism-weighted richness, in which each species is given a weight based on how much of its total range is contained within a particular cell. These values are then summed, so that species with a greater portion of their range in that cell contribute to the richness value. 
Steps:

1. For each species, calculate 1/total range area. (using mutate to create a new column in the new summed file, `mam_terr_all_area_sum`). Then, multiply this by the area of the grid cell. 1 km2 in this base case, but also create a column for 110*110 = 12,100 km2. 
2. Relate this back to mam_sf, so that each geometry has the associated value for each species. Check by recalculating the sum using the summarize function on this new rarity value (it should be one).
3. Run the fasterize() function, using the `field` argument to identify the column of values to use as the polygon value. This should be the 1/range value. Then, set the `fun` argument to "sum," so that each cell is given a value of the sum of all polygon values (1/range) for all the species that occur in that cell.
```{r endemism_richness_tester}
# load in the clipped polygon file
mam_zambia
mam_test <- mam_zambia

# there are no mammal, bird, reptile, or amphibian "EW" or "EX" species in Zambia
mam_zambia %>%
  filter(., !category %in% c("EW", "EX")) %>%
  nrow()

# Data deficient species: 
# 20 mammals: Mus neavei, Plerotes anchietae, Lemniscomys roseveari, Scotoecus albofuscus     Lophuromys machangui, Fukomys vandewoestijneae, Fukomys vandewoestijneae, Graphiurus monardi, Graphiurus angolensis, Pipistrellus grandidieri, Rhinolophus sakejiensis  Nycteris major           Epomophorus anselli      Crocidura pitmani        Paraxerus lucifer, Laephotis angolensis     Neoromicia melckorum     Elephantulus fuscus      Tadarida ventralis       Neoromicia melckorum
# 2 birds: Macronyx grimwoodi Pogoniulus makawai
# 2 ampbibians: Hemisus wittei       Hemisus barotseensis
# 2 reptiles: Zygaspis kafuensis, Trachylepis bayonii

nrow(mam_valid_summary) # 5527 mammal species globally (odd)
nrow(mam_zambia_summary) # 252 mammal species in Zambia (even)

mam_list_test <- cc_make_raster8(input_sf = mam_zambia, 
                                  run_clip = FALSE, run_extract = FALSE,
                                  clip_area = msk_sf_ll_noholes,
                                  odd_n_global = TRUE, odd_n_zam = FALSE)
# --------------------------------------------------------------------
# first, filter to just the ranges we'll include in our analysis
mam_test_all <- mam_zambia %>%
  filter(presence == 1,
         origin %in% c(1, 2), 
         seasonal %in% c(1, 2, 3),
         marine == "False", 
         !category %in% c("EW", "EX"))

# --------------------------------------------------------------------
# fasterize based on the inverse_range column -------------
# testers:
mam_test_all_richness <- mam_test_all %>%
  st_transform(aaeac) %>%
  fasterize(., raster = msk_filled, field = NULL, fun = 'sum')

mam_test_endemism_richness <- mam_test_all %>%
  st_transform(aaeac) %>%
  fasterize(., raster = msk_filled, field = 'inverse_range_glob', fun = 'sum')

mam_test_endemism_zam_richness <- mam_test_all %>%
  st_transform(aaeac) %>%
  fasterize(., raster = msk_filled, field = 'inverse_range_zam', fun = 'sum') 

mam_test_threat_richness <- mam_test_all %>% 
  filter(category %in% c("CR", "EN", "VU")) %>% 
  st_transform(aaeac) %>%
  fasterize(., raster = msk_filled, field = NULL, fun = 'sum')

mam_test_threat_weighted_richness <- mam_test_all %>%
  st_transform(aaeac) %>%
  fasterize(., raster = msk_filled, field = 'threat_weight', fun = 'sum')

mam_test_small_richness <- mam_test_all %>% 
  filter(range_size_quantile <= 0.5) %>%
  st_transform(aaeac) %>%
  fasterize(., raster = msk_filled, field = NULL, fun = 'sum')

mam_test_small_zam_richness <- mam_test_all %>% 
  filter(range_size_quantile_zambia <= 0.5) %>%
  st_transform(aaeac) %>%
  fasterize(., raster = msk_filled, field = NULL, fun = 'sum')
  
mam_test_small_threat_richness <- mam_test_all %>% 
  filter(category %in% c("CR", "EN", "VU") | range_size_quantile < 0.5) %>%
  st_transform(aaeac) %>%
  fasterize(., raster = msk_filled, field = NULL, fun = 'sum')

plot(mam_test_endemism_richness)
plot(mam_test_endemism_zam_richness)
plot(mam_test_threat_richness)
plot(mam_test_threat_weighted_richness)
plot(mam_test_small_richness)
plot(mam_test_small_zam_richness)
plot(mam_test_small_threat_richness)
  
plot(mam_test_glob_r)
plot(mam_test_zam_r, zlim = c(0.0,0.005))
hist(mam_test_zam_r)
plot(normalize(log(mam_test_zam_r)))
quantile(mam_test_zam_r)

plot(bd_inputs_brick$m3_vert_small)
plot(bd_inputs_brick[[1:4]], zlim = c(0,1))
plot(normalize(log(mam_test_glob_r)))
plot(normalize(mam_test_glob_r))


hist(bd_inputs_brick$m3_vert_small)




# --------------------------------------------------------------------


par(mfrow = c(2,2))
mam_endemism_richness_percentiles <- cc_percentilize(mam_test_endemism_richness)
plot(mam_test_endemism_richness); plot(mam_endemism_richness_percentiles)
mam_endemism_zam_richness_percentiles <- cc_percentilize(mam_test_endemism_zam_richness)
plot(mam_test_endemism_zam_richness); plot(mam_endemism_zam_richness_percentiles)

hist(mam_test_endemism_zam_richness)
hist(mam_test_endemism_zam_richness, xlim = c(0, 0.001), breaks = 10000)
dev.off()

# testing percentiles
mam_test_dt <- as.data.table(mam_test_glob_r, na.rm = TRUE)
setnames(mam_test_dt, old = "layer", new = "endemism_rich")
mam_test_dt[, key := 1:.N] # .N is the number of rows in the data.table # set a key with the original row order
setorder(mam_test_dt, endemism_rich) # change the order of the data.table, permanently. Use setorder(conv_10p_bd_dt, key) # to change it back
mam_test_dt[, percentile := 1:.N]

mam_test_percentile <- dt_to_raster(mam_test_dt, CRSobj)

plot(normalize(mam_test_percentile$percentile))
hist(mam_test_percentile$endemism_rich, xlim = c(0, 0.0004), breaks = 200)

# two other things to test
# 1. Does it matter if we use the percentilized version of this, vs. the un-normalized version?
# 2. Does this match 1 - convprob_r (the conversion probabilities raster)? The conversion probablities raster should show the order in which cells are chosen for conversion. So, if 100% weight is on Biodiversity, then this should be the reverse order of the biodiversity input raster, which is given by 1 - percentiles


```



```{r mam-list8-final}
nrow(mam_valid_summary) # 5527 mammal species globally (odd)
nrow(mam_zambia_summary) # 252 mammal species in Zambia (even)

mam_list <- cc_make_raster8(input_sf = mam_zambia, 
                             run_clip = FALSE, run_extract = FALSE,
                             clip_area = msk_sf_ll_noholes,
                             odd_n_global = TRUE, odd_n_zam = FALSE)

names(mam_list)
# this includes a bunch of layers:
# "clipped_sf", "filtered_all", "filtered_threat", "filtered_small", "filtered_small_zam", "filtered_threat_small", "reprojected_all", "reprojected_threat", "reprojected_small", "reprojected_small_zam", "reprojected_threat_small", "brick"
# "brick" includes 8 rasters:
# "all_richness", "endemism_richness", "endemism_zam_richness", "threat_richness", "threat_weighted_richness", "small_richness", "small_zam_richness", "small_threat_richness"
names(mam_list$brick)

dev.off()
par(mfrow = c(2, 2))
# eight key rasters:
levelplot(mam_list$brick[[1:4]], col.regions = terrain.colors(50, rev = TRUE), main = "title") # beware, this plots only with one scale. 
mam_list$brick
object_size(mam_list)

plot(mam_list$brick$all_richness)
plot(mam_list$brick$endemism_richness)
plot(mam_list$brick$endemism_zam_richness)
plot(mam_list$brick$threat_richness)
plot(mam_list$brick$threat_weighted_richness)
plot(mam_list$brick$small_richness)
plot(mam_list$brick$small_zam_richness)
plot(mam_list$brick$small_threat_richness)


save(mam_list, file = "/Users/christophercrawford/Google Drive/_Projects/Zambia/agroEcoTradeoff/external/data_new/1_IUCN_dev/mam_list.RData")

mam_brick <- writeRaster(mam_list$brick, filename = fp(p_iucn_dev, "mam_brick.tif"), overwrite = TRUE)
names(mam_brick) <- names(mam_list$brick)

```




### Extras: General Species Richness Extras and Unused methods:
Note: See 2_BD_input_prep.Rmd for my initial code, with some potentially useful notes. 

This is important! Plotting stuff with lots of features is hard and takes a long time for the Mac Quartz device (the interactive one that RStudio uses in the IDE). A very good way to speed up plotting is to simplify the geometry, by removing vertices. You can do this with sf objects using the `st_simplify()` function. The dTolerance option sets how simplified to make this. I'm not totally sure what it means, but perhaps it is measured in meters. For things in the Africa Albers Equal Area Conic (aaeac, same as for msk_shp) projection, dTolerance = 1000 seems to make things very speedy and still pretty detailed (even when looking at it at the scale of Zambia). 

```{r speed-up-plotting}
mam_simpl <- st_simplify(mam_terr_all, dTolerance = 0.1, preserveTopology = TRUE)
glimpse(simpl)

tic(); beaver <- filter(mam_terr_all, binomial == "Castor canadensis"); toc() #
tic(); plot(st_geometry(filter(mam_terr_all, binomial == "Loxodonta africana"))); toc() # 1.504 sec
tic(); plot(st_geometry(filter(mam_terr_all, binomial == "Castor canadensis"))); toc() # slow...unsimplified. 22.971 seconds.
#tic(); plot(st_geometry(filter(mam_terr_all, binomial == "Lepus timidus"))); # slow...unsimplified. 401 seconds.
401.675/60; toc()

tic(); plot(msk); toc()
tic(); plot(msk_shp); toc()
tic(); plot(st_geometry(filter(mam_simpl, binomial == "Loxodonta africana"))); toc() # nice! much faster. 0.182 sec for simp (tol = 0.01). 0.147 sec for mam_simpl (tol = 0.1)
tic(); plot(st_geometry(filter(mam_simpl, binomial == "Castor canadensis"))); toc() # damn way faster! 0.88 sec for simp (tol = 0.01). 0.04 sec for mam_simpl (tol = 0.1)
tic(); plot(st_geometry(filter(mam_simpl, binomial == "Lepus timidus"))); toc() # zomg so fast. 2.783 sec for simp (tol = 0.01). 0.09 sec for mam_simpl (tol = 0.1)
```

Trying out summary tables from tibbles
```{r}
t<- mam_sf %>%
  as_tibble(mam_sf) %>%
  count(binomial) %>%
  arrange(desc(n)) %>%
  as.data.frame() %>%
  print()

ta <- mam_sf %>%
  group_by(binomial) %>%
  dplyr::summarize(num_poly = n()) %>%
  print()

```

initial-testing
```{r}
mam_terr_threat <- mam_sf %>%   # assign mam_sf to a new object, to then be modified
  filter(presence == 1) %>%   # only records with Code 1 (Extant)
  filter(origin == 1) %>%     # only native species (Code 1)
  filter(marine == "False") %>%   # removing all marine species
  filter(category %in% c("CR", "EN", "VU")) %>%   # choosing threatened species, removing LC [Least Concern], EX [Extinct], EW [Extinct in the Wild], NT [Near Threatened], & DD [Data Deficient]
  #filter(SHAPE_Area < median(mam_sf$SHAPE_Area))   # selecting only "small-ranged" species
  st_transform(crs(msk_shp))   # reproject shapefiles to Albers Equal Area projection

# method for clipping two sf objects 
zam_clip <- st_intersection(mam_terr_threat, msk_sf) # this returns the geometries where the two sf objects overlap.

glimpse(mam_terr_threat)
mam_zambia_terr_threat <- st_crop(mam_terr_threat, st_bbox(msk_shp)) # crop to the bounding box of msk_shp
glimpse(mam_zambia_terr_threat)
as_tibble(mam_zambia_terr_threat)
mam_zambia_terr_threat$binomial <- droplevels(mam_zambia_terr_threat$binomial)
levels(mam_zambia_terr_threat$binomial) # 19 threatened species in Zambia
plot(st_geometry(mam_zambia_terr_threat))
class(mam_zambia_terr_threat)
st_geometry(mam_zambia_terr_threat) # the geometry type is "GEOMETRY," but the fasterize() function only works on geometry types of POLYGON or MULTIPOLYGON.
mam_zambia_terr_threat <- st_cast(mam_zambia_terr_threat, "MULTIPOLYGON") # this changes the geometry type of the sf object mam_zambia_terr_threat.

# trying a raster of just the Zambia species:
a <- rasterize(mam_zambia_terr_threat, 
               raster(mam_zambia_terr_threat, res = 1000),
               field = "binomial",
               fun = function (x, ...) length(unique(na.omit(x))))
b <- fasterize(mam_zambia_terr_threat, raster(mam_zambia_terr_threat, res = 1000), fun = 'sum')

plot(a, ext = extent(msk_shp), col = viridis(100))
plot(b, ext = extent(msk_shp), col = viridis(100))
plot(a - b, col = viridis(100)) # all looks good.

plot(msk_shp, add = F, border = "red")
elephants <- filter(mam_sf, binomial == "Loxodonta africana")
elephants # yeah if I remove all records that have subspecies, then I lose lots of polygons. I need to figure out a way to make sure that there are not overlapping subspecies. 
plot(st_geometry(elephants))
plot(st_geometry(st_transform(
  filter(mam_sf, binomial == "Loxodonta africana"), crs(msk_shp))), add = T)
plot(st_geometry(filter(mam_zambia_terr_threat, binomial == "Loxodonta africana")), add = T, col = "blue")
# something weird is going on here...maybe it's because i'm filtering out the subspecies?

# what threatened species are there in Zambia? 
levels(mam_zambia_terr_threat$binomial) # 19 threatened species in Zambia:
levels(droplevels(mam_zambia_terr_threat$subspecies)) # 7 threatened mammal species subspecies in Zambia

Zam_mam_names <- levels(mam_zambia_terr_threat$binomial) # 19 threatened species in Zambia:
plot(st_geometry(msk_sf),                     main = Zam_mam_names[1], border = "black", add = F); plot(st_geometry(filter(mam_terr_threat, binomial == Zam_mam_names[1])), add = T, col = adjustcolor("red", 0.4))
# only 10 of them actually exist in Zambia

msk_shp
msk_sf <- st_as_sf(msk_shp)
plot(st_geometry(msk_sf))

######
# learning to clip 
zam_clip <- st_intersection(mam_terr_threat, msk_sf) # this returns the geometries where the two sf objects overlap.
zam_clip$binomial
zam_clip$binomial <- droplevels(zam_clip$binomial)
Zam_mam_names0 <- levels(zam_clip$binomial) # 11 threatened species in Zambia


plot(st_geometry(zam_clip))

Zam_mam_names1[1]
plot(st_geometry(msk_sf), main = Zam_mam_names0[1], border = "black", add = F); plot(st_geometry(filter(zam_clip, binomial == Zam_mam_names0[1])), add = T, col = adjustcolor("red", 0.4))

c <- rasterize(zam_clip, 
               raster(zam_clip, res = 1000),
               field = "binomial",
               fun = function (x, ...) length(unique(na.omit(x))))

st_geometry(zam_clip)
zam_clip <- st_cast(zam_clip, "MULTIPOLYGON") # this changes the geometry type of the sf object mam_zambia_terr_threat.
d <- fasterize(zam_clip, raster(zam_clip, res = 1000), fun = 'sum')
plot(c, col=viridis(100))
plot(d, col=viridis(100))



```

Rescaling (applicable to all): testing various methods of scaling:

There are three methods I used to rescale the resolution of the rasters so that they are appropriate for use. 
1. (The method I use): aggregating from the global scale, 1 km resolution map, using the function `aggregate()`
2. (Alt 1): directly in fasterize, by changing the resolution of the raster that is being written into.
3. (Alt 2): aggregating directly from the masked Zambia raster, at 1 km resolution.

This chunk just summarizes the results of those tests below:
rescaling
```{r}
# 1. (The method I use): aggregating from the global scale, 1 km resolution map, using the function `aggregate()` - results from above:
plot(mam_zambia_terr_threat_richness, col = viridis(100))
plot(mam_zambia_terr_threat_richness_10km, col = viridis(100))
plot(mam_zambia_terr_threat_richness_110km, col = viridis(100))

# 2. (Alt 1): changing the resolution in fasterize() directly in the function, by changing the resolution of the raster that is being written into:
plot(mam_zambia_terr_threat_richness, col = viridis(100))
plot(mam_zambia_terr_threat_richness_10km_alt1, col = viridis(100))
plot(mam_zambia_terr_threat_richness_110km_alt1, col = viridis(100))

# 3. (Alt 2): aggregating directly from the masked Zambia raster, at 1 km resolution:
plot(mam_zambia_terr_threat_richness, col = viridis(100))
plot(mam_zambia_terr_threat_richness_10km_alt2, col = viridis(100))
plot(mam_zambia_terr_threat_richness_110km_alt2, col = viridis(100))


plot(mam_zambia_terr_threat_richness_110km -
       mam_zambia_terr_threat_richness_110km_alt1, col = viridis(100))
plot(mam_zambia_terr_threat_richness_110km -
       mam_zambia_terr_threat_richness_110km_alt2, col = viridis(100))
plot(mam_zambia_terr_threat_richness_110km_alt1 -
       mam_zambia_terr_threat_richness_110km_alt2, col = viridis(100))

# thoughts at the end of this exercise: which option is better? Hard to say. Ask Lyndon. 
# But, my guess is that aggregating from the 1km global map might make the most sense. 
# The other two options are to aggregate directly from the Zambia map, or to burn  onto a coarser raster in the fasterize().
```

Here are the methods for the two alternative methods.
Alt 1: Using `fasterize()` on a coarser resolution raster.
```{r}
##### 10 km x 10 km

####################
# mammal terrestrial threatened species richness, at 10 km x 10 km resolution:
####################
mam_terr_threat_richness_10km_alt1 <- mam_sf %>%   # assign mam_sf to a new object, to then be modified
  filter(presence == 1) %>%   # only records with Code 1 (Extant)
  filter(origin == 1) %>%     # only native species (Code 1)
  filter(marine == "False") %>%   # removing all marine species
  filter(category %in% c("CR", "EN", "VU")) %>%   # choosing threatened species
  st_transform(crs(msk_shp)) %>%   # reproject shapefiles to Albers Equal Area projection
  fasterize(., raster(., res = 1000*10), fun = 'sum') # change resolution here to make coarser

plot(mam_terr_threat_richness_10km_alt1, ext = extent(msk_shp), col = viridis(100))
plot(msk_shp, add = T, border = "red")

####################
# Save global file
####################
writeRaster(mam_terr_threat_richness_10km_alt1, fp(p_iucn_dev,"mam_terr_threat_richness_10km_alt1.tif"), overwrite=TRUE)
rm(mam_terr_threat_richness_10km_alt1)
mam_terr_threat_richness_10km_alt1 <- raster(fp(p_iucn_dev,"mam_terr_threat_richness_10km_alt1.tif"))

####################
# Mask to Zambia for tradeoff model
####################
mam_terr_threat_richness_10km_alt1 <- disaggregate(mam_terr_threat_richness_10km_alt1, fact = 10) # has to be disaggregated, so that there are 10 x 10 cells in each cell, all with the same value. This is so that it can be masked, and so there is a value for each cell to be run through the tradeoff model.
mam_zambia_terr_threat_richness_10km_alt1 <- crop(mam_terr_threat_richness_10km_alt1, extent(msk)) # crop to (almost) the right extent
mam_zambia_terr_threat_richness_10km_alt1@extent <- extent(msk) # still slightly off, so forcing the extents to be the same
mam_zambia_terr_threat_richness_10km_alt1 <- raster::mask(mam_zambia_terr_threat_richness_10km_alt1, msk) # masking, in order to set all cells in hotspots_r to NA where msk is NA.

plot(mam_zambia_terr_threat_richness_10km_alt1, col = viridis(100))

####################
# Save final Zambia file
####################
writeRaster(mam_zambia_terr_threat_richness_10km_alt1, fp(p_iucn_dev,"mam_zambia_terr_threat_richness_10km_alt1.tif"), overwrite=TRUE)
rm(mam_zambia_terr_threat_richness_10km_alt1)
mam_zambia_terr_threat_richness_10km_alt1 <- raster(fp(p_iucn_dev,"mam_zambia_terr_threat_richness_10km_alt1.tif"))




##### 110 km x 110 km

####################
# mammal terrestrial threatened species richness, at 110 km x 110 km resolution:
####################
mam_terr_threat_richness_110km_alt1 <- mam_sf %>%   # assign mam_sf to a new object, to then be modified
  filter(presence == 1) %>%   # only records with Code 1 (Extant)
  filter(origin == 1) %>%     # only native species (Code 1)
  filter(marine == "False") %>%   # removing all marine species
  filter(category %in% c("CR", "EN", "VU")) %>%   # choosing threatened species

  #filter(island == "Madagascar") %>%   # subset
  #filter(SHAPE_Area < median(mam_sf$SHAPE_Area))   # selecting only "small-ranged" species
  st_transform(crs(msk_shp)) %>%   # reproject shapefiles to Albers Equal Area projection
  fasterize(., raster(., res = 1000*110), fun = 'sum') # change resolution here to make coarser

plot(mam_terr_threat_richness_110km_alt1, ext = extent(msk_shp), col = viridis(100))
plot(msk_shp, add = T, border = "red")

####################
# Save global file
####################
writeRaster(mam_terr_threat_richness_110km_alt1, fp(p_iucn_dev,"mam_terr_threat_richness_110km_alt1.tif"), overwrite=TRUE)
rm(mam_terr_threat_richness_110km_alt1)
mam_terr_threat_richness_110km_alt1 <- raster(fp(p_iucn_dev,"mam_terr_threat_richness_110km_alt1.tif"))

####################
# Mask to Zambia for tradeoff model
####################
mam_terr_threat_richness_110km_alt1 <- disaggregate(mam_terr_threat_richness_110km_alt1, fact = 110) # has to be disaggregated, so that there are 110 x 110 cells in each cell, all with the same value. This is so that it can be masked, and so there is a value for each cell to be run through the tradeoff model.
mam_zambia_terr_threat_richness_110km_alt1 <- crop(mam_terr_threat_richness_110km_alt1, extent(msk)) # crop to (almost) the right extent
mam_zambia_terr_threat_richness_110km_alt1@extent <- extent(msk) # still slightly off, so forcing the extents to be the same
mam_zambia_terr_threat_richness_110km_alt1 <- raster::mask(mam_zambia_terr_threat_richness_110km_alt1, msk) # masking, in order to set all cells in hotspots_r to NA where msk is NA.

plot(mam_zambia_terr_threat_richness_110km_alt1, col = viridis(100))

####################
# Save final Zambia file
####################
writeRaster(mam_zambia_terr_threat_richness_110km_alt1, fp(p_iucn_dev,"mam_zambia_terr_threat_richness_110km_alt1.tif"), overwrite=TRUE)
rm(mam_zambia_terr_threat_richness_110km_alt1)
mam_zambia_terr_threat_richness_110km_alt1 <- raster(fp(p_iucn_dev,"mam_zambia_terr_threat_richness_110km_alt1.tif"))
```

Alt 2: Aggregating from the Zambia cropped file.
```{r}
####################
# Aggregate to 10km x 10km
####################
mam_zambia_terr_threat_richness_10km_alt2 <- aggregate(mam_zambia_terr_threat_richness, fact = 10)
mam_zambia_terr_threat_richness_10km_alt2 <- disaggregate(mam_zambia_terr_threat_richness_10km_alt2, fact = 10)
mam_zambia_terr_threat_richness_10km_alt2 <- crop(mam_zambia_terr_threat_richness_10km_alt2, extent(msk)) # crop to (almost) the right extent
#test_10km_dis@extent <- extent(msk) # still slightly off, so forcing the extents to be the same
mam_zambia_terr_threat_richness_10km_alt2 <- raster::mask(mam_zambia_terr_threat_richness_10km_alt2, msk) # mask, i.e. set all cells in hotspots_r to NA where msk is NA.

plot(mam_zambia_terr_threat_richness_10km_alt2, col = viridis(100))
plot(mam_zambia_terr_threat_richness_10km_alt, col = viridis(100))

writeRaster(mam_zambia_terr_threat_richness_10km_alt2, fp(p_iucn_dev,"mam_zambia_terr_threat_richness_10km_alt2.tif"), overwrite=TRUE)
rm(mam_zambia_terr_threat_richness_10km_alt2)
mam_zambia_terr_threat_richness_10km_alt2 <- raster(fp(p_iucn_dev,"mam_zambia_terr_threat_richness_10km_alt2.tif"))

####################
# Aggregate to 110km x 110km
####################
mam_zambia_terr_threat_richness_110km_alt2 <- aggregate(mam_zambia_terr_threat_richness, fact = 110)
mam_zambia_terr_threat_richness_110km_alt2 <- disaggregate(mam_zambia_terr_threat_richness_110km_alt2, fact = 110)
mam_zambia_terr_threat_richness_110km_alt2 <- crop(mam_zambia_terr_threat_richness_110km_alt2, extent(msk)) # crop to (almost) the right extent
#test_110km_dis@extent <- extent(msk) # still slightly off, so forcing the extents to be the same
mam_zambia_terr_threat_richness_110km_alt2 <- raster::mask(mam_zambia_terr_threat_richness_110km_alt2, msk) # mask, i.e. set all cells in hotspots_r to NA where msk is NA.

plot(mam_zambia_terr_threat_richness, col = viridis(100))
plot(mam_zambia_terr_threat_richness_110km, col = viridis(100))
plot(mam_zambia_terr_threat_richness_110km_alt, col = viridis(100))
plot(mam_zambia_terr_threat_richness_110km_alt2, col = viridis(100))

writeRaster(mam_zambia_terr_threat_richness_110km_alt2, fp(p_iucn_dev,"mam_zambia_terr_threat_richness_110km_alt2.tif"), overwrite=TRUE)
rm(mam_zambia_terr_threat_richness_110km_alt2)
mam_zambia_terr_threat_richness_110km_alt2 <- raster(fp(p_iucn_dev,"mam_zambia_terr_threat_richness_110km_alt2.tif"))
```



Small Extras: testing grounds
small-mam-testing
```{r}
# area - I don't really trust the SHAPE_Area measurements - 
summary(mam_sf$SHAPE_Area)
#    Min.  1st Qu.   Median     Mean  3rd Qu.     Max. 
#    0.00     0.05     0.83   125.11    15.97 38144.89
ggplot(data = filter(mam_sf, SHAPE_Area < 0.83)) + 
  geom_histogram(mapping = aes(x = SHAPE_Area), bins = 100)

ggplot(data = mam_sf) + 
  geom_histogram(mapping = aes(x = log10(SHAPE_Area)), bins = 50)

quantile(mam_sf$SHAPE_Area)[2] # 25%
quantile(mam_sf$SHAPE_Area)[3] # 50%, median
median(mam_sf$SHAPE_Area)

small_ranges <- filter(mam_sf, SHAPE_Area < median(mam_sf$SHAPE_Area))
glimpse(small_ranges)
summary(small_ranges$SHAPE_Area)

##################
##### extras #####
##################
# alternative method, if needed.
# dropping the geometry to try:
mam_terr_all_drop <- st_drop_geometry(mam_terr_all_area)
mam_terr_all_drop_area <- mam_terr_all_drop %>%
  group_by(binomial) %>% 
  dplyr::summarize(total_area = sum(area_km2, na.rm = TRUE), n_polygons = n()) %>%
  print()

quantile(mam_terr_all_drop_area$total_area, 0.25)
small_mam_names_sf_drop <- filter(mam_terr_all_drop_area , total_area < quantile(mam_terr_all_area_sum$total_area, 0.5))


##### arrange species in order of largest to smallest ranges:
arrange(mam_terr_all_area_sum, desc(total_area))

# to filter the filtered mammals sf object to a specific species and then plot the results
mam_terr_all_area %>% 
  filter(binomial == "Canis lupus") %>%
  st_simplify(dTolerance = 0.1, preserveTopology = TRUE) %>%
  st_geometry() %T>%
  plot()

epsg <- make_EPSG()
names(epsg)
epsg %>% filter(code == 2343)
epsg %>%
  filter(str_detect(prj4, 'aea')) # might be able to use the US National Atlas Equal Area: EPSG - 2163.
crs(msk) # +proj=aea +lat_1=20 +lat_2=-23 +lat_0=0 +lon_0=25 +x_0=0 +y_0=0 +ellps=WGS84 +units=m +no_defs 

# elephants and giraffes subset.
eg_longlat <- filter(mam_terr_all_longlat, binomial == "Loxodonta africana")
eg_z <- st_intersection(filter(mam_terr_all, binomial == "Loxodonta africana"), msk_sf)
eg <- filter(mam_terr_all, binomial == "Loxodonta africana" | binomial == "Giraffa camelopardalis")
eg$binomial <- droplevels(eg$binomial)
plot(eg["binomial"]) # one way to visualize it
ggplot() + 
  geom_sf(data = eg, mapping = aes(fill = binomial)) # visualizing using ggplot.

###
filter(mam_terr_all, str_detect(binomial,"^Giraf")) # partial matching using the stringr package.

```



## II. birds
Notes on sorting. Bird species range maps are slightly different, in that they have a seasonal component to them. 
Jenkins et al. 2013 only uses breeding ranges for these birds, and separates out the terrestrial birds.
Jetz et al. 2007 only use breeding ranges as well (I'm fairly certain). 
Filtering involved  following steps:

1. First, I filter based on "presence." selecting only records with code 1 (Extant). Other unused codes are: 2. Probably Extant (discontinued, ambiguous), 3. Possibly Extant, 4. Possibly Extinct, 5. Extinct, 6. Presence Uncertain.
2. Next, I filter by origin, selecting only native species (Code: 1) and reintroduced species (Code: 2). Other unused codes are: 3. Introduced, 4. Vagrant, 5. Origin Uncertain, 6. Assisted Colonisation.
3. Then, I filtered species based on the seasonality of their ranges. I select only "Resident" (1), "Breeding" (2), and "Non-breeding Season" (3) ranges. Other categories that I did not include were: "Passage" (4), and "Seasonal Occurrence Uncertain" (5).
4. Then, I selected only threatened species, CR (Critically Endangerd), EN (Endangered), and VU (Vulnerable), (i.e. removing LC [Least Concern], EX [Extinct], EW [Extinct in the Wild], CR (PE) [Critically Endangered, Potentially Extinct], CR (PEW) [Critically Endangered, Potentially Extinct in the Wild, e.g. Spix's Macaw], NT [Near Threatened], and DD [Data Deficient]). The PE and PEW species are mostly considered gone anyways. 
5. Having successfully narrowed down the sample to just the species and polygons I'm interested in, I then reproject the shapefiles to the Albers Equal Area projection to match the datasets being used in the @Estes2016a tradeoff model. 
6. Finally, I used the function `fasterize {fasterize}` to produce a raster map of threatened species richness.

After this, I used the function raster::aggregate to produce species richness maps at coarser resolutions (10 km x 10 km, and 110 km x 110 km), and masked the rasters to the size of Zambia.

```{r birds-start}
# Load prepped rdata (bird_threat_sf,bird_threat_made_valid, bird_terr_threat, bird_america_threat, bird_africa_threat, bird_zambia_threat) ----------------------------------------------------------
load(fp(p_iucn_dev,"bird_files.RData"), verbose = TRUE) #(bird_threat_sf,bird_threat_made_valid, bird_terr_threat, bird_america_threat, bird_africa_threat, bird_zambia_threat)

load(file = "/Users/christophercrawford/Google Drive/_Projects/Zambia/agroEcoTradeoff/external/data_new/1_IUCN_dev/bird_valid.RData", verbose = TRUE) # this has "bird_valid", an sf object made by splitting bird_sf into three files, and running cc_make_valid on each in parallel, the using rbind to put them back together. it's 6.9 gb.

load(file = "/Users/christophercrawford/Google Drive/_Projects/Zambia/agroEcoTradeoff/external/data_new/1_IUCN_dev/bird_valid_prepped.RData", verbose = TRUE) # contains bird_valid (7.22 gb), but prepped for use in small species, etc. This entailed joining the table of red list categories, changing some of the column names, adding a column for area, totalling area for parts of the range we're using, and adding a column ranking the range size to allow things to be subset for small ranged species analyses.

load(file = "/Users/christophercrawford/Google Drive/_Projects/Zambia/agroEcoTradeoff/external/data_new/1_IUCN_dev/bird_zambia.RData", verbose = TRUE) # includes bird_zambia, which has had area added, been prepped, and then clipped to zambia

# ----------------------------------

st_layers(fp(p_bird,"BOTW/BOTW.gdb")) # what layers are there in the BOTW file geodatabase? 

bird_sf <- st_read(dsn = fp(p_bird,"BOTW/BOTW.gdb"), layer = "All_Species")
as_tibble(bird_sf)

bird_red_list <- st_read(dsn = fp(p_bird,"BOTW/BOTW.gdb"), layer = "RedList_2018")
as_tibble(bird_red_list)
levels(bird_red_list$Family)




# bird_table
bird_table <- st_drop_geometry(bird_sf)
object_size(bird_table)
class(bird_table)
#write.csv(bird_table, file = fp(p_iucn_dev, "bird_table.csv"))


levels(bird_red_list$RedListCategory)
summary(bird_red_list$RedListCategory)
filter(bird_red_list, RedListCategory == "CR (PE)")[1:21,6:7]
filter(bird_red_list, RedListCategory %in% c("CR", "EN", "VU"))[,6:7] # 1470 species.

nrow(bird_sf)
reintroduced <- filter(bird_sf, ORIGIN == 2)
table(bird_sf$ORIGIN)

# ----------------------------------------
# how many records have origins or seasonal codes outside the ones I use?
nrow(bird_valid) # 17463
object_size(bird_valid) # 7.22 gb

bird_valid %>% st_drop_geometry() %>% filter(presence == 1) %>% nrow() # 16038, only records with Code 1 (Extant) 
bird_valid %>% st_drop_geometry() %>% filter(origin %in% c(1, 2)) %>% nrow() # 17118, only native species (Code 1) and reintroduced (Code 2).  There are 326 introduced polygons (Code 3), zero vagrant polygons (Code 4), 19 origin uncertaint (Code 5), and Zero assisted colonization polygons.
bird_valid %>% st_drop_geometry() %>% filter(seasonal %in% c(1, 2, 3)) %>% nrow() # 16645, selecting "Resident" (1), "Breeding" (2), and "Non-breeding Season" (3) ranges. Other categories include: Passage (4), and Seasonal Occurrence Uncertain (5).
# there are 740 passage range polygons
# there are 78 seasonal occurrence uncertain range polygons

```

```{r birds-valid-par}
library(sf)
library(lwgeom)
library(dplyr)
library(tidyverse)
library(pryr)
library(parallel)
library(tictoc)

bird_sf <- st_read(dsn = "/Users/christophercrawford/Google Drive/_Projects/data/Bd/IUCN_RedList/Birds/BOTW/BOTW.gdb", layer = "All_Species")

bird_sf <- bird_sf %>%
  mutate(key = row_number()) %>%
  select(key, everything())

nrow(bird_sf)
# dat
dat <- bird_sf[1:300, ]
dat1 <- bird_valid[1:7800, ]
dat2 <- bird_valid[7801:14500, ]
dat3 <- bird_valid[14501:17463, ]

object_size(dat1)
object_size(dat2)
object_size(dat3)


# see cc_functions.R for cc_make_valid()
tic("birds parallel")
dat_par <- mclapply(seq(nrow(dat)), function(i) cc_make_valid(dat[i, ]), mc.cores = parallel::detectCores()-1)
toc(log = TRUE)
# time for 300 rows: 198.865 seconds

dat_final <- do.call("rbind", dat_par)

tic("birds parallel 1")
dat1_par <- mclapply(seq(nrow(dat1)), function(i) cc_make_valid(dat1[i, ]), mc.cores = parallel::detectCores())
dat1_final <- do.call("rbind", dat1_par)
toc(log = TRUE) # time elapsed: 3185.081 seconds (53 minutes) for the first 6000 rows, 1.7 gb

tic("birds parallel 2")
dat2_par <- mclapply(seq(nrow(dat2)), function(i) cc_make_valid(dat2[i, ]), mc.cores = parallel::detectCores())
dat2_final <- do.call("rbind", dat2_par)
toc(log = TRUE) # time elapsed: 7321.151 seconds (122.02 minutes) for the second 6000 rows, 1.9 gb

tic("birds parallel 3")
dat3_par <- mclapply(seq(nrow(dat3)), function(i) cc_make_valid(dat3[i, ]), mc.cores = parallel::detectCores())
dat3_final <- do.call("rbind", dat3_par)
toc(log = TRUE) # time elapsed: 14592.23 seconds (243.2 minutes) for the last 5463 rows, which were 3.3 gb

bird_valid <- rbind(dat1_final, dat2_final, dat3_final)


# save(dat1_par, dat1_final, dat2_par, dat2_final, #dat3_par, dat3_final, 
#      file = "/Users/christophercrawford/Google Drive/_Projects/Zambia/agroEcoTradeoff/external/data_new/1_IUCN_dev/bird_par_files.RData")

tic("save dat_final 1, 2, and 3")
save(dat1_final, dat2_final, dat3_final, file = "/Users/christophercrawford/Google Drive/_Projects/Zambia/agroEcoTradeoff/external/data_new/1_IUCN_dev/bird_dat_finals.RData")
toc(log = TRUE) # 487.205 sec elapsed

tic("save bird_valid")
save(bird_valid, file = "/Users/christophercrawford/Google Drive/_Projects/Zambia/agroEcoTradeoff/external/data_new/1_IUCN_dev/bird_valid.RData")
toc(log = TRUE)
tic.log(format = TRUE) # 409.253 sec elapsed

load(file = "/Users/christophercrawford/Google Drive/_Projects/Zambia/agroEcoTradeoff/external/data_new/1_IUCN_dev/bird_valid.RData", verbose = TRUE) # this has "bird_valid", an sf object made by splitting bird_sf into three files, and running cc_make_valid on each in parallel, the using rbind to put them back together. it's 6.9 gb.




# older version of cc_make_valid, used originally.
# cc_make_valid <- function (sf, add_reasons = TRUE) {
#   if (class(sf)[1] != "sf") {stop("The function requires the input to be an sf object.")}# 0. Check to make sure input is an sf object.
#   if (add_reasons == FALSE) {
#     valid_sf <- st_make_valid(sf) # 2a. run st_make_valid to make the geometries valid. This usually takes a long time.
#     return(valid_sf)
#   } else {
#     reasons_df <-   # 1. Creates a dataframe listing whether each geometry is valid or not (along with reasons why not)
#       st_is_valid(sf, reason = TRUE) %>% # 1a. Test to see which geometries are not valid, returning a character vector (NA means corrupt geometry)
#       data.frame(pre_fix_reasons = .) %>% # 1b. Place those reasons in a data frame, titling the column
#       mutate(key = row_number()) %>% # 1c. Add a surrogate key based on row number
#       select(key, everything()) # 1d. Rearrange to have the key as the first column.
#     valid_sf <-
#       st_make_valid(sf) %>% # 2a. run st_make_valid to make the geometries valid. This usually takes a long time.
#       mutate(key = row_number()) %>% # 2b. Add a surrogate key
#       select(key, everything()) # 2c. Rearrange to make the key first column
#     reasons_df <- # 3. Check geometries again, and add another column to reasons_df
#       valid_sf %>%
#       st_is_valid(reason = TRUE) %>% # 3a. Run st_is_valid to check the geometries again after fixing them.
#       cbind(reasons_df, post_fix_reasons = .) # 3b. Add this vector to reasons_df, naming the column.
#     valid_sf <-
#       left_join(valid_sf, reasons_df, by = "key") # 4. Finally, join the now valid sf object to the dataframe listing pre and post valid status, and assign to a new object
#     return(valid_sf)
#   }
# }

```

```{r bird-prep}
load(file = "/Users/christophercrawford/Google Drive/_Projects/Zambia/agroEcoTradeoff/external/data_new/1_IUCN_dev/bird_valid.RData", verbose = TRUE) # this has "bird_valid", an sf object made by splitting bird_sf into three files, and running cc_make_valid on each in parallel, the using rbind to put them back together. it's 6.9 gb.

# ------------------------------------------------------
#  join the bird_valid file to the red_list file
# ------------------------------------------------------
names(bird_valid)
bird_valid <- bird_valid %>% 
  left_join(bird_red_list, by = c("SISID" = "SISRecID")) # by = c("key x" = "key y")

bird_valid$ScientificName <- drop.levels(bird_valid$ScientificName)
bird_valid$SCINAME <- drop.levels(bird_valid$SCINAME)
identical(bird_valid[['SCINAME']], bird_valid[['ScientificName']])

names(bird_valid)
# rename variable names to match the other vertebrate groups, for use in "cc_make_raster()".
bird_valid <- rename(bird_valid, 
                  category = RedListCategory,
                  presence = PRESENCE,
                  origin = ORIGIN, 
                  seasonal = SEASONAL,
                  binomial = SCINAME) # renaming variable names ("new name = old name")



# ------------------------------------------------------------
# code to prepare the sf file for the creation of 1) small-ranged species richness, 2) weighted endemism richness, and 3) threat-weighted species richness. This involves calculating polygon areas, summing to determine the total range area (excluding parts of the range we aren't considering), ordering the species by range size and giving the rank order (normalized to between 0-1). This also involves calculating the inverse of the global range size and the threat category weight.
# ------------------------------------------------------------

names(bird_valid)

tic("add area") ### note that I had to change "geometry" to "Shape"
bird_valid <- bird_valid %>%
  mutate(., area_km2 = st_area(.["Shape"]) %>% units::set_units(km^2)) # area, calculated from polygons in long lat projection
toc() # 271.001 sec for bird_valid (4.5 minutes)

# trying it in parallel
# it crashes, I think because the list that is created, with one list element for each row ends up being humongus. too big! This is fine when it's run on the cluster, but probably better off running it just in serial. 
# tic("add area, birds parallel, full run")
# bird_valid_l <- mclapply(seq(nrow(bird_valid)), function(i) {
#   mutate(bird_valid[i, ], area_km2 = units::set_units(st_area(bird_valid[i, ]["Shape"]), km^2))
#   }, 
#   mc.cores = parallel::detectCores()-1)
# toc(log = TRUE)
# # time for 100 rows: 2.136 seconds
# 
# bird_valid_l_combined <- do.call("rbind", bird_valid_l)


# ------------------------------------------------------------
# subset to only those ranges used in analysis,
# then, group by species, and calculate the sum of the various polygons, i.e. the total range area for each species. 
tic("summarize")
bird_valid_summary <- bird_valid %>%   # assign dat to a new object, to then be modified
  st_drop_geometry() %>%
  filter(presence == 1) %>%   # only records with Code 1 (Extant)
  filter(origin %in% c(1, 2)) %>%     # only native species (Code 1) and reintroduced (Code 2)
  filter(seasonal %in% c(1, 2, 3)) %>%   # selecting "Resident" (1), "Breeding" (2), and "Non-breeding Season" (3) ranges. Other categories include: Non-breeding Season (3), Passage (4), and Seasonal Occurrence Uncertain (5).
  filter(!category %in% c("EW", "EX")) %>% # remove Extinct or Extinct in the Wild species ("EW", "EX")
  group_by(binomial) %>%
  dplyr::summarize(total_range_area = sum(area_km2, na.rm = TRUE), n_polygons = n())
toc() # 1.355 seconds for bird_valid.

nrow(bird_valid_summary) # 10936, even. There are no EW or EX species that are also Extant (presence ==1).
drop.levels(bird_valid$binomial) # 11125 originally, pre-filtering

  
### what are the summary statistics? What is the median, 1st quartile, etc?
quantile(bird_valid_summary$total_range_area, probs = c(0.25, 0.5, 0.75)) 
# 1st quartile: 58192.94 km2 (even after dropping EW EX)
# 2nd quartile: 471064.67 km2 (even after dropping EW EX)
# 3rd quartile: 2603424.08 km2 (even after dropping EW EX)

# add column to put the species in order of range size, counting upwards from the smallest range, and add a second column dividing by the total number of species
bird_valid_summary <- bird_valid_summary %>%
  arrange(total_range_area) %>%
  mutate(range_size_quantile = row_number()/max(row_number()))

nrow(bird_valid_summary) # 10936
bird_valid_summary %>% 
  filter(range_size_quantile <= 0.5) %>% # do <= if nrow is even, and < if nrow is odd.
  arrange(desc(total_range_area)) %>%
  nrow() # 5468
nrow(bird_valid_summary)/2

# ------------------------------------------------------------
# join total range area back to original sf object
names(bird_valid_summary)
bird_valid <- bird_valid %>% # by = c("key x" = "key y")
  left_join(bird_valid_summary, by = c("binomial" = "binomial"))
names(bird_valid)
head(bird_valid)
bird_valid %>% filter(binomial == "Chaetura meridionalis") %>% st_geometry() %T>% plot()


# add the number of vertices
bird_valid <- bird_valid %>% 
  mutate(vertices = mapview::npts(bird_valid, by_feature = TRUE))


# ------------------------------------------------------------
# calculate inverse_range_glob & 
# threat status weight (based on Damania & Wheeler 2015, Veach et al. 2017)
bird_valid <- bird_valid %>% 
  mutate(inverse_range_glob = 1/total_range_area) %>% 
  mutate(threat_weight = 
           ifelse(category == "CR", 1,    # if CR then 1, if not, then ->
           ifelse(category == "EN", 1/2,  # if EN then 1/2, if not, then ->
           ifelse(category == "VU", 1/4,  # if VU then 1/4, if not, then ->
           ifelse(category == "NT", 1/8,  # if NT then 1/8, if not, then ->
           ifelse(category == "LC", 1/16, # if LC then 1/16, if not, then ->
           ifelse(category == "DD", 1/4, NA))))))) # if DD then 1/4 (a middle ground, conservative estimate). If not, then -> NA. This means that EW, EX are all set to NA.


# testing to make sure things look good. 
names(bird_valid)
bird_valid %>% 
  st_drop_geometry() %>%
  .[1:20, c(3, 27:34)]

# -----------------------------------------------------
### Now you can use it to filter to only "small-ranged species," those species with total range areas of less than the median (or the 1st quartile, whatever method you decide)
nrow(bird_valid_summary)
bird_valid %>% 
  filter(range_size_quantile <= 0.5) %>% # do <= if nrow is even, and < if nrow is odd.
  arrange(desc(total_range_area))  

# -----------------------------------------------------
save(bird_valid, file = "/Users/christophercrawford/Google Drive/_Projects/Zambia/agroEcoTradeoff/external/data_new/1_IUCN_dev/bird_valid_prepped.RData") # contains bird_valid (7.22 gb), but prepped for use in small species, etc. This entailed joining the table of red list categories, changing some of the column names, adding a column for area, totalling area for parts of the range we're using, and adding a column ranking the range size to allow things to be subset for small ranged species analyses.


#####
# >>>> filter the original bird_sf
#####
```


```{r bird-clip}
load(file = "/Users/christophercrawford/Google Drive/_Projects/Zambia/agroEcoTradeoff/external/data_new/1_IUCN_dev/bird_valid_prepped.RData", verbose = TRUE)

# --------------------------------------------------------
# clip to Zambia
bird_zambia <- bird_valid %>%
  st_intersection(., st_union(msk_sf_ll_noholes)) %>%
  st_collection_extract(., "POLYGON") # extract only polygons


# -------------------------------------------------------------
# calculate area of clipped polygons in Zambia (calculated in long lat projection)
bird_zambia <- bird_zambia %>%
  mutate(area_zambia_km2 = st_area(.["Shape"]) %>% units::set_units(km^2)) 


# -------------------------------------------------------------
# subset to only those ranges used in analysis, then 
# group by species and sum across polygons to get species' total range area in Zambia

bird_zambia_summary <- bird_zambia %>%   # assign dat to a new object, to then be modified
  st_drop_geometry() %>%
  filter(presence == 1) %>%   # only records with Code 1 (Extant)
  filter(origin %in% c(1, 2)) %>%     # only native species (Code 1) and reintroduced (Code 2)
  filter(seasonal %in% c(1, 2, 3)) %>%   # selecting "Resident" (1), "Breeding" (2), and "Non-breeding Season" (3) ranges. Other categories include: Passage (4), and Seasonal Occurrence Uncertain (5).
  #filter(marine == "False") %>%   # removing all marine species, except for bird species
  filter(!category %in% c("EW", "EX")) %>% # remove Extinct or Extinct in the Wild species ("EW", "EX")
  group_by(binomial) %>%
  dplyr::summarize(total_zambia_range_area = sum(area_zambia_km2, na.rm = TRUE), n_polygons = n())

nrow(bird_zambia_summary) # 738 species, even number of rows

  
# what are the summary statistics? What is the median, 1st quartile, etc?
summary(bird_zambia_summary$total_zambia_range_area)
quantile(bird_zambia_summary$total_zambia_range_area, probs = c(0.25, 0.5, 0.75)) 
# update for each taxonomic group
# 1st quartile: 88,348.02 km2 (global: 58,192.94 km2, even after dropping EW EX)
# 2nd quartile: 503,786.22 km2 (global: 471,064.67 km2, even after dropping EW EX)
# 3rd quartile: 741,094.45 km2 (global: 2,603,424.08 km2, even after dropping EW EX)

# ------------------------------------------------------------
# add column to put the species in order of range size, 
# counting upwards from the smallest range, and add a second column 
# dividing by the total number of species
bird_zambia_summary <- bird_zambia_summary %>%
  arrange(total_zambia_range_area) %>%
  mutate(range_size_quantile_zambia = row_number()/max(row_number()))
  
nrow(bird_zambia_summary) # 738
tail(bird_zambia_summary)

median(bird_zambia_summary$total_zambia_range_area)

bird_zambia_summary %>% 
  filter(range_size_quantile_zambia <= 0.5) %>% # do <= if nrow is even, and < if nrow is odd.
  arrange(desc(total_zambia_range_area)) %>%
  nrow() # 369
nrow(bird_zambia_summary)/2

# ------------------------------------------------------------
# join total Zambia range area back to clipped sf object
names(bird_zambia_summary)
bird_zambia <- bird_zambia %>% # by = c("key x" = "key y")
  left_join(bird_zambia_summary, by = c("binomial" = "binomial"))



# -------------------------------------------------------------
# calculate the inverse of the range in Zambia
bird_zambia <- bird_zambia %>%
  mutate(inverse_range_zam = 1/total_zambia_range_area) 


# -------------------------------------------------------------
save(bird_zambia, file = "/Users/christophercrawford/Google Drive/_Projects/Zambia/agroEcoTradeoff/external/data_new/1_IUCN_dev/bird_zambia.RData") # includes bird_zambia, which has had area added, been prepped, and then clipped to zambia



# -------------------------------------------------------------
# extras:




bird_zambia_4deg_buff <- bird_valid %>%
  st_intersection(., st_union(msk_sf_ll_4deg_buff)) %>%
  st_collection_extract(., "POLYGON")
plot(bird_zambia_4deg_buff$Shape)
save(bird_zambia_4deg_buff, file = "/Users/christophercrawford/Google Drive/_Projects/Zambia/agroEcoTradeoff/external/data_new/1_IUCN_dev/bird_zambia_4deg_buff.RData") # includes bird_zambia, which has had area added, been prepped, and then clipped to zambia

```

```{r other-subsets}
# ---- subset to threatened birds
bird_threat_sf <- bird_sf %>%
  filter(PRESENCE == 1) %>%   # only extant species (1)
  filter(ORIGIN == 1) %>%     # only native species (1)
  filter(SEASONAL %in% c(1, 2, 3)) %>% # selecting "Resident" (1), "Breeding" (2), and "Non-breeding Season" (3) ranges. Other categories include: Non-breeding Season (3), Passage (4), and Seasonal Occurrence Uncertain (5).
  filter(category %in% c("CR", "EN", "VU"))

# clip throws an invlid error.
bird_zambia_threat_sf <- bird_threat_sf %>% 
  st_intersection(zambia_sf$geometry) %>% st_cast("MULTIPOLYGON")

# ---- st_make_valid() - alternative method, for when you actually have time (hint: run at night, or in parallel).
tic(); bird_threat_made_valid <- st_make_valid(bird_threat_sf); toc() # 10468.9 sec elapsed (174.48 min, 2.91 hours)
bird_threat_made_valid <- bird_threat_made_valid %>% st_cast("MULTIPOLYGON")
st_geometry(bird_threat_made_valid)

st_write(bird_threat_made_valid, dsn = fp(p_iucn_dev, "bird_threat_made_valid.shp"), layer="bird_threat_made_valid", driver="ESRI Shapefile")
bird_threat_made_valid_test <- st_read(dsn = fp(p_iucn_dev, "bird_threat_made_valid.shp"), layer = "bird_threat_made_valid")

# ------------- intersections
bird_terr_threat <- bird_threat_made_valid %>%
  st_intersection(st_union(world$geometry)) %>% st_cast("MULTIPOLYGON") # 2529.999 sec elapsed

bird_africa_threat <- bird_threat_made_valid %>%
  st_intersection(st_union(africa$geometry)) %>% st_cast("MULTIPOLYGON") # 242.479 sec elapsed

bird_america_threat <- bird_threat_made_valid %>%
  st_intersection(st_union(americas$geometry)) %>% st_cast("MULTIPOLYGON") # 1043.185 sec elapsed

test_buff <- st_buffer(msk_sf_ll, units::set_units(1, degree))
plot(test_buff)
plot(msk_sf_ll, add = T)
bird_zambia_threat <- bird_threat_made_valid %>% 
  st_intersection(msk_sf_ll) %>% st_cast("MULTIPOLYGON") # 10.098 sec elapsed

# plot them
bird_terr_threat %>%
  #sample_n(50) %>%
  st_simplify(dTolerance = units::set_units(5, degree), preserveTopology = TRUE) %>%
  st_geometry() %T>% plot(border="blue", add = FALSE)

```

At this point, I grappled with how to create the raster to rasterize the polygons into. My original solution was to just create a raster using `raster()` based on the extent of the input sf object (after it had been reprojected in the pipeline), with a resolution of 1000 m. However, this meant that each time I created a raster to be rasterized into, it oriented the grid slightly differently each time. This is why I kept running into the errors about different origin when trying to mask the raster to `msk`, which I solved by cropping, manually setting the extent, and then masking. So, there were a few potential solutions from the `raster` package, such as `alignExtent` (which does what it sounds like), `resample` (which uses some fancy method to make a new raster with the same grid as an template raster, and then fills in the values based on the input raster by "resampling".). A third solution, which is what I ultimately ended up using was to use the function `raster::extend()`, which takes an input raster, and then extends it on all sides to match the extent of an input 'extent' object, such as `extent(input sf object)`. This works like a charm, and allows the crop and mask to `msk` to go smoothly. Nice!

The original code I used in my pipes was this `fasterize(., raster(., res = 1000), fun = 'sum')`


```{r bird_list_final}
nrow(bird_valid_summary) # 10936 bird species globally (even)
nrow(bird_zambia_summary) # 738 bird species in Zambia (even)

tic()
bird_list <- cc_make_raster8(input_sf = bird_zambia, 
                              run_clip = FALSE, run_extract = FALSE,
                              clip_area = msk_sf_ll_noholes, 
                              filter_marine = FALSE, 
                              odd_n_global = FALSE, odd_n_zam = FALSE)
toc() # 274 secs if doing the full bird_valid, 13 seconds if only bird_zambia


bird_list$brick
object_size(bird_list)

plot(bird_list$brick$all_richness)
plot(bird_list$brick$endemism_richness)
plot(bird_list$brick$endemism_zam_richness)
plot(bird_list$brick$threat_richness)
plot(bird_list$brick$threat_weighted_richness)
plot(bird_list$brick$small_richness)
plot(bird_list$brick$small_zam_richness)
plot(bird_list$brick$small_threat_richness)


save(bird_list, file = "/Users/christophercrawford/Google Drive/_Projects/Zambia/agroEcoTradeoff/external/data_new/1_IUCN_dev/bird_list.RData")

bird_brick <- writeRaster(bird_list$brick, filename = fp(p_iucn_dev, "bird_brick.tif"), overwrite = TRUE)
names(bird_brick) <- names(bird_list$brick)

```



maybe get rid of this
```{r save-bird-files}
save(bird_threat_sf,
     bird_threat_made_valid,  # bird_sf after st_make_valid
     bird_terr_threat, # bird_threat_made_valid clipped to continental outline
     bird_america_threat, # bird_threat_made_valid clipped to North and South American outline
     bird_africa_threat, # bird_threat_made_valid clipped to Africa outline
     bird_zambia_threat, # bird_threat_made_valid clipped to Zambia outline (msk_sf_ll)
     file = fp(p_iucn_dev,"bird_files.RData"))


```

extras
```{r casting}
plot(bird_list$all_richness, zlim = c(100, 500))

# ---- subset to Zambia
bird_zambia <- bird_valid %>%
  st_intersection(., st_union(msk_sf_ll_noholes)) %>%
  st_collection_extract(., "POLYGON") # extract only polygons



# extras.
bird_zambia <- bird_zambia %>% 
  mutate(geometry_type = st_geometry_type(.))
levels(drop.levels(bird_zambia$geometry_type))
nrow(bird_zambia)
bird_zambia <- bird_zambia %>%
  st_collection_extract("POLYGON")
nrow(bird_zambia)



gc <- test_cast %>% 
  filter(geometry_type == "GEOMETRYCOLLECTION") #%>%
  st_geometry() %T>% plot()
  
gcx <- st_collection_extract(gc, "POLYGON")
gcx
cs %>% st_cast("POLYGON")
st_is(cs, "GEOMETRYCOLLECTION")
csx <- cs %>%
  st_collection_extract("POLYGON")
plot(csx$Shape)

cs <- bird_valid %>% filter(binomial == "Cinnyris shelleyi") #%>%
  st_collection_extract("MULTIPOLYGON") %>%
  st_geometry() %T>% plot()
  
bird_valid <- bird_valid %>%
  mutate(geometry_type = st_geometry_type(.))

bird_valid %>% filter(geometry_type != "MULTIPOLYGON")
levels(drop.levels(bird_valid$geometry_type))
non <- bird_valid %>% filter(geometry_type != "MULTIPOLYGON")
non1 <- non %>%
  st_collection_extract("POLYGON")
non[169:171, ]
non1
nrow(non)
nrow(non1)

vn <- bird_valid %>% filter(binomial == "Vidua nigeriae")
vn %>% st_collection_extract("POLYGON") %>% st_geometry() %T>% plot()
plot(vn[2, ]$Shape)
levels(drop.levels(non$binomial))
levels(drop.levels(non1$binomial))

plot(gcx[3:8,]$Shape)


  #st_cast("MULTIPOLYGON")



test <- st_geometry_type(bird_zambia)
levels(drop.levels(test_cast$geometry_type))
```
```{r manual-bird-richness}

bird_africa_threat_richness <- bird_africa_threat %>%
  st_transform(aaeac) %>%   # reproject
  fasterize(., extend(msk, extent(.), value = 0), fun = 'sum') %>% # produce richness raster map
  crop(msk) %>%
  raster::mask(msk)

plot(bird_africa_threat_richness)
bird_africa_threat_richness <- crop(bird_africa_threat_richness, extent(msk)) # crop to (almost) the right extent
bird_africa_threat_richness[is.na(bird_africa_threat_richness)] <- 0 # amplace NAs with 0s
bird_africa_threat_richness <- raster::mask(bird_africa_threat_richness, msk) # masking, in order to set all cells in hotspots_r to NA where msk is NA.


bird_zambia_threat_richness <- bird_zambia_threat %>% # assign bird_sf to a new object, to then be modified
  st_transform(aaeac) %>%   # reproject shapefiles to Albers Equal Area projection
  fasterize(., extend(msk, extent(.), value = 0), fun = 'sum') %>% # produce richness raster map
  #fasterize(., msk, fun = 'sum') %>% # produce richness raster map
  crop(msk) %>%
  raster::mask(msk)

plot(bird_zambia_threat_richness)
#bird_zambia_threat_richness <- crop(bird_zambia_threat_richness, extent(msk)) # crop to (almost) the right extent
bird_zambia_threat_richness[is.na(bird_zambia_threat_richness)] <- 0 # amplace NAs with 0s
bird_zambia_threat_richness <- raster::mask(bird_zambia_threat_richness, msk) # masking, in order to set all cells in hotspots_r to NA where msk is NA.

plot(bird_africa_threat_richness, col = viridis(100))
plot(bird_zambia_threat_richness, col = viridis(100))


# just for fun:
bird_america_threat_richness <- bird_america_threat %>% # assign bird_sf to a new object, to then be modified
  st_transform(crs_moll_americas) %>%   # reproject
  fasterize(., raster(., res = 1000), fun = 'sum') # produce richness raster map
plot(bird_america_threat_richness, col = viridis(100))


# plots
plot(bird_threat_richness, col = viridis(100))
plot(bird_terr_threat_richness, col = viridis(100))
plot(bird_africa_threat_richness, col = viridis(100))
plot(bird_america_threat_richness, col = viridis(100))
plot(bird_zambia_threat_richness, col = viridis(100))

# note that if I use msk as the input raster on which to rasterize, then the extent and everything is the same and masking goes smoothly.  

```

```{r bird-expl-gge}
load("/Users/christophercrawford/Google Drive/_Projects/Zambia/agroEcoTradeoff/external/data_new/1_IUCN_dev/bird_valid_prepped.RData", verbose = TRUE)
# save(bird_valid, file = "/Users/christophercrawford/Google Drive/_Projects/Zambia/agroEcoTradeoff/external/data_new/1_IUCN_dev/bird_valid_prepped.RData")  # resaving the bird_valid file, with the number of vertices as a column
names(bird_valid)

rm(bird_valid)
parus <- bird_valid %>% filter(ScientificName == "Parus major")
parus

parus_simpl_less <- st_simplify(parus, dTolerance = units::set_units(0.01, degree))

parus_simpl <- st_simplify(parus, dTolerance = units::set_units(0.1, degree))


parus_ext <- drawExtent(show = TRUE, col = "red")

parus %>% st_geometry() %T>% plot()
plot(parus$Shape)
plot(st_geometry(parus))
plot(parus_simpl$Shape)
plot(parus_simpl_less$Shape)

plot(parus$Shape, xlim = parus_ext[1:2], ylim = parus_ext[3:4])
plot(parus_simpl_less$Shape, xlim = parus_ext[1:2], ylim = parus_ext[3:4])
plot(parus_simpl$Shape, xlim = parus_ext[1:2], ylim = parus_ext[3:4])

razor <- bird_valid %>% filter(ScientificName == "Alca torda")
bird_sub <- bird_valid[1:10, ]

# count the vertices
mapview::npts(parus, by_feature = FALSE)
mapview::npts(parus_simpl_less, by_feature = FALSE)
mapview::npts(parus_simpl, by_feature = FALSE)

st_write(parus, "/Users/christophercrawford/Google Drive/R/parus.shp")

mapview::npts(razor, by_feature = TRUE)
mapview::npts(bird_sub, by_feature = TRUE)

vertices <- mapview::npts(bird_valid, by_feature = TRUE)

bird_valid <- bird_valid %>% 
  mutate(vertices = mapview::npts(bird_valid, by_feature = TRUE))

head(vertices)

length(vertices)

summary(bird_valid$vertices)
quantile(bird_valid$vertices, 0.95) # 96,347

names(bird_valid)
bird_vertices <- bird_valid %>%
  st_drop_geometry() %>%
  select(CommonName, ScientificName, presence, origin, seasonal, category, range_size_quantile, vertices)

object_size(bird_vertices)

fwrite(bird_vertices, "/Users/christophercrawford/Google Drive/_Projects/Zambia/agroEcoTradeoff/external/data_new/1_IUCN_dev/bird_vertices.csv")
fwrite(big_birds, "/Users/christophercrawford/Google Drive/_Projects/Zambia/agroEcoTradeoff/external/data_new/1_IUCN_dev/big_birds.csv")


big_birds <- bird_vertices %>% filter(vertices > 96348) # just the features with the top 5% number of vertices (i.e. greater than 100,000 vertices about)
big_birds

names(big_birds)
summary(big_birds$vertices)

big_birds %>%
  st_drop_geometry() %>%
  arrange(desc(vertices)) %>%
  select(CommonName, vertices)


object_size(big_birds) # 4.25 gb
object_size(bird_valid) # 7.22 gb



bird_valid$Shape

bird_valid[15545, ]$Shape

bird_valid[15563, ]

bird_valid[15563, ] %>%
  st_geometry() %T>% plot()

# subset
bird_sub <- bird_valid[1:500, ]

# pre simplification
st_write(bird_sub, "/Users/christophercrawford/Google Drive/R/bird_sub.shp")

# simplify
bird_simp <- bird_sub %>% 
    # Simplify
    st_simplify(preserveTopology = TRUE, dTolerance = units::set_units(0.1, degree))

st_geometry(bird_sub)
st_is_geometry()

bird_valid_extract <- bird_valid %>%
  st_collection_extract(bird_valid, "POLYGON") # extract only polygons


st_write(bird_valid, "/Users/christophercrawford/Google Drive/R/bird_full.shp")
# Writing layer `bird_full' to data source `/Users/christophercrawford/Google Drive/R/bird_full.shp' using driver `ESRI Shapefile'
# Writing 17463 features with 31 fields and geometry type Unknown (any).
# Failed to create feature 14562 in bird_full
# Error in CPL_write_ogr(obj, dsn, layer, driver, as.character(dataset_options),  : 
#   Feature creation failed.
# In addition: There were 50 or more warnings (use warnings() to see the first 50)
# seems like most of the errors (at least in the first 50) are related to the values of the total_range_area being too big to be written because of the field width. 

# trying it after dropping the field total_range_area.
names(bird_valid)
summary(st_drop_geometry(bird_valid))
round(bird_valid$total_range_area[1,])
bird_valid$total_range_area[100]



bird_mod <- bird_valid %>%
  select(-c(area_km2, total_range_area))

st_write(bird_mod, "/Users/christophercrawford/Google Drive/R/bird_mod.shp")
# errors:
# Writing layer `bird_mod' to data source `/Users/christophercrawford/Google Drive/R/bird_mod.shp' using driver `ESRI Shapefile'
# Writing 17463 features with 29 fields and geometry type Unknown (any).
# Failed to create feature 14562 in bird_mod
# Error in CPL_write_ogr(obj, dsn, layer, driver, as.character(dataset_options),  : 
#   Feature creation failed.
# In addition: Warning messages:
# 1: In abbreviate_shapefile_names(obj) :
#   Field names abbreviated for ESRI Shapefile driver
# 2: In CPL_write_ogr(obj, dsn, layer, driver, as.character(dataset_options),  :
#   GDAL Message 1: One or several characters couldn't be converted correctly from UTF-8 to ISO-8859-1.  This warning will not be emitted anymore.
# 3: In CPL_write_ogr(obj, dsn, layer, driver, as.character(dataset_options),  :
#   GDAL Message 1: 2GB file size limit reached for /Users/christophercrawford/Google Drive/R/bird_mod.shp. Going on, but might cause compatibility issues with third party software
# 4: In CPL_write_ogr(obj, dsn, layer, driver, as.character(dataset_options),  :
#   GDAL Error 1: Failed to write shape object. File size cannot reach 4293702740 + 1425668.


bird_valid_extract <- st_collection_extract(bird_valid, "POLYGON") # extract only polygons
object_size(bird_valid) # 7.22 gb
object_size(bird_valid_extract) # 7.22 gb
st_write(bird_valid_extract, "/Users/christophercrawford/Google Drive/R/bird_valid_extract.shp")
# Failed to create feature 14562 in bird_valid_extract
# Error in CPL_write_ogr(obj, dsn, layer, driver, as.character(dataset_options),  : 
#   Feature creation failed.
# In addition: There were 50 or more warnings (use warnings() to see the first 50)

# just feature 14562
bird_valid[14562, ] %>%
  st_geometry() %T>% plot()

# subset
bird_sub <- bird_valid[1:500, ]

# just trying the top half: 
17463/2 #8731
# top half
bird_top_half <- bird_valid[8731:17463, ]
st_write(bird_top_half, "/Users/christophercrawford/Google Drive/R/bird_top_half.shp")

```
## III. amphibians
```{r amp-start}
load(fp(p_iucn_dev,"amphibian_valid_files.RData"), verbose = TRUE) # amp_sf_valid

st_layers(fp(p_amp,"AMPHIBIANS.shp")) # what layers are there in the BOTW file geodatabase? 
amp_sf <- st_read(dsn = fp(p_amp,"AMPHIBIANS.shp"))

amp_sf_valid
as_tibble(amp_sf_valid)
table(amp_sf_valid$presence)
table(amp_sf_valid$origin)
table(amp_sf_valid$seasonal)
table(amp_sf_valid$terrestial)
table(amp_sf_valid$marine)
table(amp_sf_valid$terrestial)
table(amp_sf_valid$category)

object_size(amp_sf_valid)
names(amp_sf_valid)
```

```{r amp-valid-par}
tic("full script")
library(sf)
library(lwgeom)
library(dplyr)
library(tictoc)
library(parallel)
library(pryr)

tic("load data")
dat <- st_read(dsn = "/Users/christophercrawford/Google Drive/_Projects/data/Bd/IUCN_RedList/AMPHIBIANS/AMPHIBIANS.shp")
toc(log = TRUE)

tic("add row number")
dat <- dat %>%
  mutate(key = row_number()) %>%
  select(key, everything())
toc(log = TRUE)

print("dat object size")
object_size(dat)

# see cc_functions.R for cc_make_valid()
tic("run in parallel")
dat <- mclapply(seq(1, nrow(dat), by = 100), function(i) cc_make_valid(dat[i:(i+99), ]), mc.cores = 8)
toc(log = TRUE) #1512 seconds (25 minutes)

print("dat object size par list")
object_size(dat)
print("length of dat par list")
length(dat)
dat[[1]]

tic("recombine")
dat <- do.call("rbind", dat)
toc(log = TRUE)

print("object size post recombination")
object_size(dat)
toc(log = TRUE)

nrow(dat)

# drop NA geometries:
nrow(dat)
dat <- filter(dat, !is.na(id_no))
nrow(dat)

amp_valid <- dat
tic("write dat_par file")
save(amp_valid, file = "/Users/christophercrawford/Google Drive/_Projects/Zambia/agroEcoTradeoff/external/data_new/1_IUCN_dev/amp_valid_par.RData")
toc(log = TRUE)

toc(log = TRUE)


tic.log(format = TRUE)
```



```{r amp-prep}
# ------------------------------------------------------------
# code to prepare the sf file for the creation of 1) small-ranged species richness, 2) weighted endemism richness, and 3) threat-weighted species richness. This involves calculating polygon areas, summing to determine the total range area (excluding parts of the range we aren't considering), ordering the species by range size and giving the rank order (normalized to between 0-1). This also involves calculating the inverse of the global range size and the threat category weight.
# ------------------------------------------------------------

# amphibians ---------
# load(fp(p_iucn_dev,"amphibian_valid_files.RData"), verbose = TRUE) # amp_sf_valid

load(file = "/Users/christophercrawford/Google Drive/_Projects/Zambia/agroEcoTradeoff/external/data_new/1_IUCN_dev/amp_valid_par.RData", verbose= T) # includes amp_valid (755 mb), which was created via "amp-valid-par" in parallel. This is the one I used going forward.


#####
# ------------------------------------------------------------
# add a new column for area -------------
tic("add area") ### note that I had to change "geometry" to "Shape" for birds
amp_valid <- amp_valid %>%
  mutate(., area_km2 = st_area(.["geometry"]) %>% units::set_units(km^2)) # area, caluclated from polygons in long lat projection
toc() # 22.967 sec for amp_sf_valid

table(amp_valid$seasonal)

# ------------------------------------------------------------
# subset to only those ranges used in analysis,
# then, group by species, and calculate the sum of the various polygons, i.e. the total range area for each species. 
amp_valid_summary <- amp_valid %>%   # assign dat to a new object, to then be modified
  st_drop_geometry() %>%
  filter(presence == 1) %>%   # only records with Code 1 (Extant)
  filter(origin %in% c(1, 2)) %>%     # only native species (Code 1) and reintroduced (Code 2)
  filter(seasonal %in% c(1, 2, 3)) %>%   # selecting "Resident" (1), "Breeding" (2), and "Non-breeding Season" (3) ranges. Other categories include: Non-breeding Season (3), Passage (4), and Seasonal Occurrence Uncertain (5).
  filter(marine == "False") %>%   # removing all marine species
  filter(!category %in% c("EW", "EX")) %>% # remove Extinct or Extinct in the Wild species ("EW", "EX")
  group_by(binomial) %>%
  dplyr::summarize(total_range_area = sum(area_km2, na.rm = TRUE), n_polygons = n())

nrow(amp_valid_summary) # 6593 rows (one EX EW species: Anaxyrus baxteri)


  
### what are the summary statistics? What is the median, 1st quartile, etc?
quantile(amp_valid_summary$total_range_area, probs = c(0.25, 0.5, 0.75)) 
# 1st quartile: 230.3931 km2 (old pre dropping EW EX: 230.1272 km2)
# 2nd quartile: 4,443.1651 km2 (old pre dropping EW EX: 4439.1885 km2)
# 3rd quartile: 66,839.4557 km2 (old pre dropping EW EX: 66839.1562 km2)
   

# add column to put the species in order of range size, counting upwards from the smallest range, and add a second column dividing by the total number of species
amp_valid_summary <- amp_valid_summary %>%
  arrange(total_range_area) %>%
  mutate(range_size_quantile = row_number()/max(row_number()))
nrow(amp_valid_summary) # nrow is odd: 6593

amp_valid_summary %>% 
  filter(range_size_quantile < 0.5) %>% # do <= if nrow is even, and < if nrow is odd.
  arrange(desc(total_range_area)) %>%
  nrow() # 3296
nrow(amp_valid_summary)/2

median(amp_valid_summary$total_range_area)

nrow(amp_valid_summary) %% 2 == 0 # true if even, false if odd.
amp_valid %>%
  st_drop_geometry() %>%
  filter(presence == 1) %>%   # only records with Code 1 (Extant)
  filter(origin %in% c(1, 2)) %>%     # only native species (Code 1) and reintroduced (Code 2)
  filter(seasonal %in% c(1, 2, 3)) %>%   # selecting "Resident" (1), "Breeding" (2), and "Non-breeding Season" (3) ranges. Other categories include: Non-breeding Season (3), Passage (4), and Seasonal Occurrence Uncertain (5).
  filter(marine == "False") %>%   # removing all marine species
  filter(!category %in% c("EW", "EX")) %>% # remove Extinct or Extinct in the Wild species ("EW", "EX")
  .$binomial %>% unique() %>% length()
  

# ------------------------------------------------------------
# join total range area back to original sf object
names(amp_valid_summary)
amp_valid <- amp_valid %>% # by = c("key x" = "key y")
  left_join(amp_valid_summary, by = c("binomial" = "binomial"))

names(amp_valid)
head(amp_valid)


# ------------------------------------------------------------
# calculate inverse_range_glob & 
# threat status weight (based on Damania & Wheeler 2015, Veach et al. 2017)
amp_valid <- amp_valid %>% 
  mutate(inverse_range_glob = 1/total_range_area) %>% 
  mutate(threat_weight = 
           ifelse(category == "CR", 1,    # if CR then 1, if not, then ->
           ifelse(category == "EN", 1/2,  # if EN then 1/2, if not, then ->
           ifelse(category == "VU", 1/4,  # if VU then 1/4, if not, then ->
           ifelse(category == "NT", 1/8,  # if NT then 1/8, if not, then ->
           ifelse(category == "LC", 1/16, # if LC then 1/16, if not, then ->
           ifelse(category == "DD", 1/4, NA))))))) # if DD then 1/4 (a middle ground, conservative estimate). If not, then -> NA. This means that EW, EX are all set to NA.


# testing to make sure things look good. 
names(amp_valid)
amp_valid %>% 
  st_drop_geometry() %>%
  .[1:20, c(3, 23, 31:33, 35:36)]

### Now you can use it to filter to only "small-ranged species," those species with total range areas of less than the median (or the 1st quartile, whatever method you decide)
amp_valid %>% 
  filter(range_size_quantile < 0.5) %>% # do <= if nrow is even, and < if nrow is odd.
  arrange(desc(total_range_area))


# ------------------------------------------------------------
save(amp_valid, file = "/Users/christophercrawford/Google Drive/_Projects/Zambia/agroEcoTradeoff/external/data_new/1_IUCN_dev/amp_valid_prepped.RData") # contains amp_valid (756 mb), but prepped for use in small species, etc. This entailed joining the table of red list categories, changing some of the column names, adding a column for area, totalling area for parts of the range we're using, and adding a column ranking the range size to allow things to be subset for small ranged species analyses.


#####
# >>>> now, it's ready to be put through cc_make_raster
#####
```

```{r amp-clip}
load(file = "/Users/christophercrawford/Google Drive/_Projects/Zambia/agroEcoTradeoff/external/data_new/1_IUCN_dev/amp_valid_prepped.RData", verbose = TRUE)


# --------------------------------------------------------
# clip to Zambia
amp_zambia <- amp_valid %>%
  st_intersection(., st_union(msk_sf_ll_noholes)) %>%
  st_collection_extract(., "POLYGON") # extract only polygons


# -------------------------------------------------------------
# calculate area of clipped polygons in Zambia (calculated in long lat projection)
amp_zambia <- amp_zambia %>%
  mutate(area_zambia_km2 = st_area(.["geometry"]) %>% units::set_units(km^2)) 


# -------------------------------------------------------------
# subset to only those ranges used in analysis, then 
# group by species and sum across polygons to get species' total range area in Zambia

amp_zambia_summary <- amp_zambia %>%   # assign dat to a new object, to then be modified
  st_drop_geometry() %>%
  filter(presence == 1) %>%   # only records with Code 1 (Extant)
  filter(origin %in% c(1, 2)) %>%     # only native species (Code 1) and reintroduced (Code 2)
  filter(seasonal %in% c(1, 2, 3)) %>%   # selecting "Resident" (1), "Breeding" (2), and "Non-breeding Season" (3) ranges. Other categories include: Passage (4), and Seasonal Occurrence Uncertain (5).
  filter(marine == "False") %>%   # removing all marine species, except for bird species
  filter(!category %in% c("EW", "EX")) %>% # remove Extinct or Extinct in the Wild species ("EW", "EX")
  group_by(binomial) %>%
  dplyr::summarize(total_zambia_range_area = sum(area_zambia_km2, na.rm = TRUE), n_polygons = n())

nrow(amp_zambia_summary) # 94 species, even number of rows

  
# what are the summary statistics? What is the median, 1st quartile, etc?
quantile(amp_zambia_summary$total_zambia_range_area, probs = c(0.25, 0.5, 0.75)) 
# update for each taxonomic group
# 1st quartile: 30,470.62 km2 (global: 230.3931 km2)
# 2nd quartile: 265,359.47 km2 (global: 4,443.1651 km2)
# 3rd quartile: 588,652.05 km2 (global: 66,839.4557 km2)




# ------------------------------------------------------------
# add column to put the species in order of range size, 
# counting upwards from the smallest range, and add a second column 
# dividing by the total number of species
amp_zambia_summary <- amp_zambia_summary %>%
  arrange(total_zambia_range_area) %>%
  mutate(range_size_quantile_zambia = row_number()/max(row_number()))
  
nrow(amp_zambia_summary) # 94
tail(amp_zambia_summary)

median(amp_zambia_summary$total_zambia_range_area)

amp_zambia_summary %>% 
  filter(range_size_quantile_zambia <= 0.5) %>% # do <= if nrow is even, and < if nrow is odd.
  arrange(desc(total_zambia_range_area)) %>%
  nrow() # 47
nrow(amp_zambia_summary)/2

# ------------------------------------------------------------
# join total Zambia range area back to clipped sf object
names(amp_zambia_summary)
amp_zambia <- amp_zambia %>% # by = c("key x" = "key y")
  left_join(amp_zambia_summary, by = c("binomial" = "binomial"))



# -------------------------------------------------------------
# calculate the inverse of the range in Zambia
amp_zambia <- amp_zambia %>%
  mutate(inverse_range_zam = 1/total_zambia_range_area) 


# -------------------------------------------------------------
save(amp_zambia, file = "/Users/christophercrawford/Google Drive/_Projects/Zambia/agroEcoTradeoff/external/data_new/1_IUCN_dev/amp_zambia.RData") # includes amp_zambia, which has had area added, been prepped, and then clipped to zambia



# -------------------------------------------------------------
# extras:



# clip to buffer
amp_zambia_4deg_buff <- amp_valid %>%
  st_intersection(., st_union(msk_sf_ll_4deg_buff)) %>%
  st_collection_extract(., "POLYGON")
plot(amp_zambia_4deg_buff$geometry)
save(amp_zambia_4deg_buff, file = "/Users/christophercrawford/Google Drive/_Projects/Zambia/agroEcoTradeoff/external/data_new/1_IUCN_dev/amp_zambia_4deg_buff.RData") # includes amp_zambia, which has had area added, been prepped, and then clipped to zambia
```

```{r amp-list-final}
nrow(amp_valid_summary) # 6593 amphibians species globally (odd)
nrow(amp_zambia_summary) # 94 amphibians species in Zambia (even)

tic()
amp_list <- cc_make_raster8(input_sf = amp_zambia, 
                             run_clip = FALSE, run_extract = FALSE,
                             clip_area = msk_sf_ll_noholes, 
                             odd_n_global = TRUE, odd_n_zam = FALSE)
# seasonal note. selecting "Resident" (1), "Breeding" (2), but none of the others. Only 3 geometries of class 5 "Seasonal occurence unknown", which are excluded. No 3 or 4 polygons exist.
toc() # 5.449 sec for just amp_zambia

amp_list$brick
object_size(amp_list)

plot(amp_list$brick$all_richness)
plot(amp_list$brick$endemism_richness)
plot(amp_list$brick$endemism_zam_richness)
plot(amp_list$brick$threat_richness)
plot(amp_list$brick$threat_weighted_richness)
plot(amp_list$brick$small_richness)
plot(amp_list$brick$small_zam_richness)
plot(amp_list$brick$small_threat_richness)


save(amp_list, file = "/Users/christophercrawford/Google Drive/_Projects/Zambia/agroEcoTradeoff/external/data_new/1_IUCN_dev/amp_list.RData")

amp_brick <- writeRaster(amp_list$brick, filename = fp(p_iucn_dev, "amp_brick.tif"), overwrite = TRUE)
names(amp_brick) <- names(amp_list$brick)
```




```{r amp-manual-fasterize}
amp_terr_threat_richness <- amp_sf_valid %>%   # assign mam_sf to a new object, to then be modified
  filter(presence == 1) %>%   # only records with Code 1 (Extant)
  filter(origin == 1) %>%     # only native species (Code 1)
  filter(marine == "False") %>%   # removing all marine species
  filter(seasonal %in% c(1, 2)) %>% # selecting "Resident" (1), "Breeding" (2), but none of the others. Only 3 geometries of class 5 "Seasonal occurence unknown", which are excluded. No 3 or 4 polygons exist.
  filter(category %in% c("CR", "EN", "VU")) %>%   # choosing threatened species, removing LC [Least Concern], EX [Extinct], EW [Extinct in the Wild], NT [Near Threatened], & DD [Data Deficient]
  #st_crop(extent(-140.00000, 220.00000, -90, 90)) %>%
  #st_cast("MULTIPOLYGON") %>%
  st_transform(aaeac) %>%   # reproject shapefiles to Albers Equal Area projection
  #fasterize(., raster(., res = 1), fun = 'sum') #%>%
  fasterize(., extend(msk, extent(.), value = 0), fun = 'sum') %>% # produce richness raster map
  crop(extent(msk)) %>%
  raster::mask(msk)

plot(amp_terr_threat_richness, ext = extent(msk), col = viridis(100))
plot(msk_shp, add = T, border = "red")

amp_terr_threat_richness <- cc_write_reload_raster(amp_terr_threat_richness, "amp_terr_threat_richness", p_iucn_dev)

amp_zambia_threat_richness <- crop(amp_terr_threat_richness, extent(msk)) # crop to (almost) the right extent
amp_zambia_threat_richness[is.na(amp_zambia_threat_richness)] <- 0 # amplace NAs with 0s
amp_zambia_threat_richness <- raster::mask(amp_zambia_threat_richness, msk) # masking, in order to set all cells in hotspots_r to NA where msk is NA.

plot(amp_zambia_threat_richness)
amp_zambia_threat_richness <- cc_write_reload_raster(amp_zambia_threat_richness, "amp_zambia_threat_richness", p_iucn_dev)

```



```{r amp-valid_nonpar}
# old, not used.
tic("amp total")
tic("st_is_valid")
amp_valid_or_not <- st_is_valid(amp_sf, reason = TRUE) # a character vector saying whether geometries are valid or not
toc()
tic("st_make_valid")
amp_sf_valid <- st_make_valid(amp_sf)
toc()
toc()
# st_is_valid: 625.784 sec elapsed
# st_make_valid: 312.587 sec elapsed
# amp total: 938.376 sec elapsed

amp_valid_or_not_df <- data.frame(is_valid_reason = amp_valid_or_not)
amp_sf_valid <- amp_sf_valid %>% mutate(key = row_number())
amp_valid_or_not_df <- amp_valid_or_not_df %>% mutate(key = row_number()) 
amp_sf_valid <- amp_sf_valid %>% # joining the two tables
  left_join(amp_valid_or_not_df, by = "key")

names(amp_sf_valid)
table(amp_sf_valid$is_valid_reason)
nrow(amp_sf_valid)
amp_sf_valid[is.na(amp_sf_valid$is_valid_reason),]
amp_sf_valid %>%
  filter(is_valid_reason != "Valid Geometry")

save(amp_sf_valid,
     file = fp(p_iucn_dev,"amphibian_valid_files.RData"))
```

```{r test-cc_make_raster-function}
hbwa_africa_r <- 
  hbwa_sf %>% # all high biodiversity wilderness areas
  st_intersection(st_union(africa)) %>% st_cast("MULTIPOLYGON") %>%  # using the intersection method
  st_transform(crs(msk_shp)) %>% # reproject
  fasterize(., extend(msk, extent(.), value = 0), fun = 'last') # then rasterize.

# `cc_make_raster` -- ecoregions ----------------------
ecoregions_list <- cc_make_raster(input_sf = ecoregions_sf, fasterize_fun = 'last',
                    run_filter = FALSE, 
                    run_clip = TRUE, clip_area = africa,
                    prep_zambia = TRUE)
ecoregions_zambia_r <- ecoregions_list$output_raster
ecoregions_zambia_r <- cc_write_reload_raster(ecoregions_zambia_r, "ecoregions_zambia_r", p_ecoreg_dev)



plot(test_ecoreg$reprojected_sf$geometry)#; plot(msk_shp, add = T)
plot(test_ecoreg$output_raster)#; plot(msk_shp, add = T)
plot(ecoregions_zambia_r)#; plot(msk_shp, add = T)
plot(test_ecoreg$output_raster - ecoregions_zambia_r)
freq(test_ecoreg$output_raster - ecoregions_zambia_r)
freq(test_ecoreg1$output_raster - ecoregions_zambia_r)
freq(test_ecoreg2$output_raster - ecoregions_zambia_r)
freq(test_ecoreg3$output_raster - ecoregions_zambia_r)
freq(test_ecoreg4$output_raster - ecoregions_zambia_r)
freq(test_ecoreg5$output_raster - ecoregions_zambia_r)

ext <- drawExtent()
plot(msk, ext = ext)
plot(st_transform(st_geometry(zambia_sf), aaeac), add = T)
plot(msk_shp, add = T, border = "blue")

ncell(test_ecoreg4$output_raster)
ncell(ecoregions_zambia_r)

system.time(
ecoregions_sf %>% st_geometry() %>%
  st_simplify(dTolerance = units::set_units(1, degree), preserveTopology = TRUE) %T>% plot()
)
world %>%
  #st_crop(extent(test_world)) %>%
  #st_transform(aaeac) %>%
  st_union() %>%
  st_geometry() %T>%
  plot(add = TRUE, border = "red")

str(test, max.level = 1)
table(test$filtered_sf$origin)
table(amp_sf_valid$origin)
table(test$filtered_sf$seasonal)
table(amp_sf_valid$seasonal)
table(test$filtered_sf$category)
table(amp_sf_valid$category)
table(test$clipped_sf$category)
table(amp_sf_valid$category)
plot(test$filtered_sf$geometry)
plot(test$clipped_sf$geometry)

test$reprojected_sf %>%
  st_geometry() %>%
  st_simplify(dTolerance = units::set_units(5, degree), preserveTopology = TRUE) %T>%
  plot()


test_world <- cc_make_raster(input_sf = amp_sf_valid, origin_code = 3, filter_category = FALSE, run_clip = FALSE, clip_area = zambia_sf, run_reproject = FALSE, prep_zambia = FALSE)

table(amp_sf_valid$origin)
table(amp_sf_valid$seasonal)
table(test_world$polygons$origin)

plot(test_world$raster)
plot(msk_shp, add = T)
freq(test_world$raster)
world %>%
  st_geometry() %>%
  st_crop(extent(test_world)) %>%
  st_transform(aaeac) %T>%
  plot(add = TRUE)



amp_sf_valid %>%
  filter(presence == 2) %>%
  st_intersection() %>%
  as_tibble()

cc_make_raster

amp_sf_valid %>%
  select(binomial, presence, origin, seasonal, category, marine) %>%
  as_tibble()

test$polygons %>%
  select(binomial, presence, origin, seasonal, category, marine) %>%
  as_tibble()

plot(test$raster)
st_crs(test$polygons)
table(test$polygons$category)
plot(test$raster)
plot(test$polygons$geometry)
```


## IV. reptiles
```{r reptiles-start}
load(file = fp(p_iucn_dev,"rep_valid_prepped.RData"), verbose = TRUE)
load(file = "/Users/christophercrawford/Google Drive/_Projects/Zambia/agroEcoTradeoff/external/data_new/1_IUCN_dev/rep_zambia.RData", verbose = TRUE)

st_layers(fp(p_rep,"REPTILES.shp")) # what layers are there in the file? 
rep_sf <- st_read(dsn = fp(p_rep,"REPTILES.shp"))

as_tibble(rep_sf)
names(rep_sf)
table(rep_valid$presence)
table(rep_valid$origin)
table(rep_valid$seasonal)
table(rep_valid$marine)
table(rep_valid$category)
table(rep_valid$terrestial)

object_size(rep_sf)

names(rep_valid)
```

```{r GARD}
# load data
# note that GARD has ranges for all reptile species, but not all reptile species have been assessed by the IUCN. Therefore, only a small subset can be included in the threatened species rasters. 
# --------------------------------------------------------------------------------
gard <- st_read(dsn = "/Users/christophercrawford/Google Drive/_Projects/data/Bd/GARD/GARD1.1_dissolved_ranges/modeled_reptiles.shp")


## make sure to make valid, below 
# --------------------------------------------------------------------------------
load(file = "/Users/christophercrawford/Google Drive/_Projects/Zambia/agroEcoTradeoff/external/data_new/1_IUCN_dev/gard_valid.RData", verbose = TRUE) # contains gard_valid
gard_valid

object_size(gard_valid)
object_size(rep_valid)

table(rep_valid$category)

# load and join to IUCN threat data
# --------------------------------------------------------------------------------
iucn_csv_non_lc <- read_csv("/Users/christophercrawford/Google Drive/_Projects/data/Bd/IUCN_RedList/RedList_NonLC_Plants+Animals_allregions/simple_summary.csv")
iucn_csv_lc <- read_csv("/Users/christophercrawford/Google Drive/_Projects/data/Bd/IUCN_RedList/RedList_LC_Plants+Animals_allregions/simple_summary.csv")

iucn_csv_non_lc %>% filter(className == "REPTILIA")
iucn_csv_lc %>% filter(className == "REPTILIA")

iucn_csv <- rbind(iucn_csv_non_lc, iucn_csv_lc)
iucn_csv %>% filter(className == "REPTILIA")

iucn_rep <- iucn_csv %>% filter(className == "REPTILIA")
iucn_rep %>% names
select(iucn_rep, scientificName, redlistCategory)

length(unique(iucn_rep$scientificName)) # only 7,199 reptile species have been assessed by IUCN, or at least exist in this csv

gard_valid$Binomial # GARD includes 10,064 species. 


gard_valid_join <- left_join(x = gard_valid, y = select(iucn_rep, scientificName, redlistCategory), 
                             by = c("Binomial" = "scientificName")) # by = c("key x" = "key y")


# prep by adding 1) inverse range size, and 2) range size quantile
# --------------------------------------------------------------------------------
gard_prep <- gard_valid_join %>%
  mutate(key = row_number())

# add a new column for area -------------
tic("add area") ### note that I had to change "geometry" to "Shape" for birds
gard_prep <- gard_prep %>%
  mutate(., area_km2 = st_area(.["geometry"]) %>% units::set_units(km^2)) # area, caluclated from polygons in long lat projection
toc(log = TRUE)

nrow(gard_prep) # 10064, pre remving extinct species

# ------------------------------------------------------------
# subset to only those ranges used in analysis
# filter out the EX or EW species
table(gard_prep$redlistCategory)
gard_prep <- filter(gard_prep, !redlistCategory %in% c("Extinct","Extinct in the Wild"))
nrow(gard_prep) # 10055, odd


# with the IUCN Reptile data, I had to join all the polygons for a single species together to have one sf object for each one
# gard has one row for each species.
  
### what are the summary statistics? What is the median, 1st quartile, etc?
quantile(gard_prep$area_km2, probs = c(0.25, 0.5, 0.75)) 
quantile(gard_prep$Area, probs = c(0.25, 0.5, 0.75)) # basically the same, but use the area_km2 to be consistent across the taxa.
   
# 1st quartile: 1,865.698 km2 (rep_valid, iucn: 966.7065 km2)
# 2nd quartile: 31,426.023 km2 (rep_valid, iucn: 16,955.5827 km2)
# 3rd quartile: 285,647.991 km2 (rep_valid, iucn: 180,190.4067 km2)
   

# add column to put the species in order of range size, counting upwards from the smallest range, and add a second column dividing by the total number of species

gard_prep <- gard_prep %>%
  arrange(area_km2) %>%
  mutate(range_size_quantile = row_number()/max(row_number()))
nrow(gard_prep) # 10055 odd! 

gard_prep %>% 
  filter(range_size_quantile < 0.5) %>% # do <= if nrow is even, and < if nrow is odd.
  arrange(desc(area_km2)) %>%
  nrow() # 5027
nrow(amp_valid_summary)/2

gard_prep <- gard_prep %>% arrange(key)


# ------------------------------------------------------------
# calculate inverse_range_glob
gard_prep <- gard_prep %>% 
  mutate(inverse_range_glob = 1/area_km2) 
# note, can't add threat status weight to GARD, since I don't have threat status for most reptile species (based on Damania & Wheeler 2015, Veach et al. 2017)



### Now you can use it to filter to only "small-ranged species," those species with total range areas of less than the median (or the 1st quartile, whatever method you decide)
gard_prep %>% 
  st_drop_geometry() %>%
  filter(range_size_quantile < 0.5) %>% # do <= if nrow is even, and < if nrow is odd.
  arrange(desc(area_km2)) %>%
  as_tibble()

# ------------------------------------------------------------
save(gard_prep, file = "/Users/christophercrawford/Google Drive/_Projects/Zambia/agroEcoTradeoff/external/data_new/1_IUCN_dev/gard_prep.RData") # contains gard_prep, which is gard, made valid, joined to IUCN table, and prepped for use in small species, endemism, etc. This entailed joining the table of red list categories, changing some of the column names, adding a column for area, totalling area for parts of the range we're using, and adding a column ranking the range size to allow things to be subset for small ranged species analyses.


gard_prep
# --------------------------------------------------------------------------------
# clip to Zambia
gard_zam <- gard_prep %>% # gard_valid
  st_intersection(., st_union(msk_sf_ll_noholes)) %>%
  st_collection_extract(., "POLYGON") # extract only polygons

gard_zam
table(gard_zam$Group)

object_size(gard_zam)
plot(gard_zam$geometry)

unique(gard_zam$Binomial) # 226 unique species in Zambia
unique(rep_zambia$binomial) # 38 reptile species have been assessed by the IUCN in Zambia. After filtering, there are only 37 species left. 

plot(rep_zambia$geometry)

gard_zam %>% filter(is.na(redlistCategory)) # 178


# testing the threat status of the gard ranges. My decision is to use the iucn range maps for threatened species, to maintain consistency.
rep_zambia %>% st_drop_geometry() %>% select(binomial, category) %>% filter(category != "LC")
gard_zam %>% st_drop_geometry() %>% select(Binomial, redlistCategory) %>% filter(is.na(redlistCategory))
gard_zam %>% st_drop_geometry() %>% select(Binomial, redlistCategory) %>% filter(!is.na(redlistCategory), redlistCategory != "Least Concern")

plot(msk_sf_ll$geometry)
rep_valid %>% filter(binomial == "Cycloderma frenatum") %>% st_geometry() %T>% plot(add = TRUE)
rep_zambia %>% filter(binomial == "Cycloderma frenatum") %>% st_geometry() %T>% plot(add = TRUE)

gard_zam %>% filter(Binomial == "Cycloderma frenatum") %>% st_geometry() %T>% plot(add = TRUE, col = "red")
gard_valid %>% filter(Binomial == "Cycloderma frenatum") %>% st_geometry() %T>% plot()#add = TRUE, col = "blue")


plot(msk_sf_ll$geometry)
rep_valid %>% filter(binomial == "Mecistops cataphractus") %>% st_geometry() %T>% plot(add = TRUE)
rep_zambia %>% filter(binomial == "Mecistops cataphractus") %>% st_geometry() %T>% plot(add = TRUE)

gard_zam %>% filter(Binomial == "Mecistops cataphractus") %>% st_geometry() %T>% plot(add = TRUE, col = "red")
gard_valid %>% filter(Binomial == "Mecistops cataphractus") %>% st_geometry() %T>% plot()#add = TRUE, col = "blue")

# just plotting the threatened species
rep_zambia %>% filter(category != "LC") %>% st_geometry() %T>% plot()
gard_zam %>% filter(!is.na(redlistCategory), redlistCategory != "Least Concern") %>% 
  st_geometry() %T>% plot()

test <- fasterize(st_transform(gard_zam, aaeac), msk, field = NULL, fun = "sum")
test_t <- fasterize(st_transform(filter(gard_zam, redlistCategory %in% c("Endangered", "Critically Endangered")), aaeac), msk, field = NULL, fun = "sum")
gard_zam %>% st_drop_geometry() %>% select(Binomial, redlistCategory) %>% filter(redlistCategory %in% c("Endangered", "Critically Endangered"))

plot(test)
plot(test_t)


#####
# >>>> now, it's ready to be put through cc_make_raster
#####
test_t <- fasterize(st_transform(filter(gard_zam, redlistCategory %in% c("Endangered", "Critically Endangered")), aaeac), msk, field = NULL, fun = "sum")

gard_zam <- gard_zam %>%
  mutate(inverse_range_zam = 1,
         threat_weight = 1)
gard_list <- cc_make_raster8(input_sf = gard_zam, 
                             run_clip = FALSE, run_extract = FALSE,
                             clip_area = msk_sf_ll_noholes, 
                             odd_n_global = TRUE, odd_n_zam = FALSE,
                             filter_presence = FALSE, 
                             filter_origin = FALSE,
                             filter_marine = FALSE,
                             filter_seasonal = FALSE,
                             filter_EX_EW = FALSE,
                             filter_category = FALSE,
                             filter_range_size = TRUE, range_threshold = 0.5,
                             filter_range_size_zam = FALSE,
                             filter_both = FALSE
                             )

gard_list
plot(gard_list$brick$all_richness)
plot(log(gard_list$brick$endemism_richness))
plot(gard_list$brick$endemism_zam_richness)
plot(gard_list$brick$threat_richness)
plot(gard_list$brick$threat_weighted_richness)
plot(gard_list$brick$small_richness)
plot(gard_list$brick$small_zam_richness)
plot(gard_list$brick$small_threat_richness)


object_size(gard_list)
gard_list$filtered_threat <- NULL
gard_list$filtered_threat_small <- NULL
gard_list$filtered_small_zam <- NULL
gard_list$reprojected_threat <- NULL
gard_list$reprojected_small_zam <- NULL
gard_list$reprojected_threat_small <- NULL
gard_list$brick$endemism_zam_richness <- NULL
gard_list$brick$threat_richness <- NULL
gard_list$brick$small_zam_richness <- NULL
gard_list$brick$small_threat_richness <- NULL
gard_list$brick$threat_weighted_richness <- NULL

gard_list$brick <- dropLayer(gard_list$brick, c(3, 4, 5,7, 8))




# --------------------------------------------------------------------------------
# save

save(gard_list, file = "/Users/christophercrawford/Google Drive/_Projects/Zambia/agroEcoTradeoff/external/data_new/1_IUCN_dev/gard_list.RData")

gard_brick <- writeRaster(gard_list$brick, filename = fp(p_iucn_dev, "gard_brick.tif"), overwrite = TRUE)
names(gard_brick) <- names(gard_list$brick) # c("all_richness", "endemism_richness", "small_richness")



# --------------------------------------------------------------------------------
# load stuff back in

load(file = "/Users/christophercrawford/Google Drive/_Projects/Zambia/agroEcoTradeoff/external/data_new/1_IUCN_dev/gard_valid.RData", verbose = TRUE) # contains gard_valid

load(file = "/Users/christophercrawford/Google Drive/_Projects/Zambia/agroEcoTradeoff/external/data_new/1_IUCN_dev/gard_prep.RData", verbose = TRUE) # contains gard_prep, which is gard, made valid, joined to IUCN table, and prepped for use in small species, endemism, etc. This entailed joining the table of red list categories, changing some of the column names, adding a column for area, totalling area for parts of the range we're using, and adding a column ranking the range size to allow things to be subset for small ranged species analyses.

load(file = "/Users/christophercrawford/Google Drive/_Projects/Zambia/agroEcoTradeoff/external/data_new/1_IUCN_dev/gard_list.RData", verbose = TRUE)

gard_list$filtered_all %>%
  st_drop_geometry() %>%
  select(Binomial) %>%
  unique() %>% nrow() # 226

gard_list$filtered_small %>%
  st_drop_geometry() %>%
  select(Binomial) %>%
  unique() %>% nrow() # 10

rep_list$filtered_threat %>%
  st_drop_geometry() %>%
  select(binomial) %>%
  unique() %>% nrow() # 10

# threatened rep:
# Malacochersus tornieri
# Cycloderma frenatum
# Mecistops cataphractus

gard_list$filtered_all %>% 
  filter(Binomial %in% c("Malacochersus tornieri", "Cycloderma frenatum", "Mecistops cataphractus"))


# note about what's driving the rep_endemism map
load(file = "/Users/christophercrawford/Google Drive/_Projects/Zambia/agroEcoTradeoff/external/data_new/1_IUCN_dev/gard_prep.RData", verbose = TRUE) # contains gard_prep, which is gard, made valid, joined to IUCN table, and prepped for use in small species, endemism, etc. This entailed joining the table of red list categories, changing some of the column names, adding a column for area, totalling area for parts of the range we're using, and adding a column ranking the range size to allow things to be subset for small ranged species analyses.

load(file = "/Users/christophercrawford/Google Drive/_Projects/Zambia/agroEcoTradeoff/external/data_new/1_IUCN_dev/gard_list.RData", verbose = TRUE)
gard_list$filtered_small %>%
  st_drop_geometry() %>%
  filter(range_size_quantile < 0.5) %>% # do <= if nrow is even, and < if nrow is odd.
  arrange(area_km2)

# Acontias schmitzi is a lizard endemic to Zambia, with a tiny range of basically 10 km2. It's only locality is from near Mongu, at 15°23.015’S, 23°23.729’E. 
# see: http://reptile-database.reptarium.cz/species?genus=Acontias&species=schmitzi

# plot
plot(vert_r$endemism_richness$rep, main = "rep_endemism")

ext <- drawExtent(show = TRUE, col = "red")
plot(vert_r$endemism_richness$rep, main = "rep_endemism", ext = ext)

# maximum cell values
cellStats(vert_r$endemism_richness$rep, "max") # 0.1001044
hist(vert_r$endemism_richness$rep, 
     main = "rep_endemism", maxpixels = maxpixels)


1/0.1001044 # = 9.9, corresponding to the range of Acontias schmitzi: http://reptile-database.reptarium.cz/species?genus=Acontias&species=schmitzi

# if you remove the values associated with Acontias schmitzi, the distribution of values looks much more "reasonable"
hist(vert_r$endemism_richness$rep[vert_r$endemism_richness$rep < 0.09])
max(vert_r$endemism_richness$rep[vert_r$endemism_richness$rep < 0.09]) # 0.000538

```


```{r rep-valid-par}
tic("full script")
library(sf)
library(lwgeom)
library(dplyr)
library(tictoc)
library(parallel)
library(pryr)

tic("load data")
# dat <- st_read(dsn = "/Users/christophercrawford/Google Drive/_Projects/data/Bd/IUCN_RedList/REPTILES/REPTILES.shp")
dat <- st_read(dsn = "/Users/christophercrawford/Google Drive/_Projects/data/Bd/GARD/GARD1.1_dissolved_ranges/modeled_reptiles.shp")

toc(log = TRUE)

tic("add row number")
dat <- dat %>%
  mutate(key = row_number()) %>%
  select(key, everything())
toc(log = TRUE)

print("dat object size")
object_size(dat)

tic("run in parallel")
dat <- mclapply(seq(1, nrow(dat), by = 100), function(i) cc_make_valid(dat[i:(i+99), ]), mc.cores = 8)
toc(log = TRUE) #1512 seconds (25 minutes)

print("dat object size par list")
object_size(dat)
print("length of dat par list")
length(dat)
dat[[1]]

tic("recombine")
dat <- do.call("rbind", dat)
toc(log = TRUE)

print("object size post recombination")
object_size(dat)
toc(log = TRUE)

nrow(dat)

# drop NA geometries:
nrow(dat)
#dat <- filter(dat, !is.na(id_no)) # for IUCN
dat <- filter(dat, !is.na(key)) # for GARD

nrow(dat)

#rep_valid <- dat
gard_valid <- dat

tic("write dat_par file")
# save(rep_valid, file = "/Users/christophercrawford/Google Drive/_Projects/Zambia/agroEcoTradeoff/external/data_new/1_IUCN_dev/rep_valid_par.RData")

save(gard_valid, file = "/Users/christophercrawford/Google Drive/_Projects/Zambia/agroEcoTradeoff/external/data_new/1_IUCN_dev/gard_valid.RData")
toc(log = TRUE)

toc(log = TRUE)


tic.log(format = TRUE)
# "load data: 12.388 sec elapsed"
# "add row number: 0.164 sec elapsed"
# "run in parallel: 14840.091 sec elapsed"
# "recombine: 5.552 sec elapsed"
# "full script: 14868.046 sec elapsed"
# "write dat_par file: 67.931 sec elapsed"

# rm(dat)
```



```{r rep-prep}
# ------------------------------------------------------------
# code to prepare the sf file for the creation of 1) small-ranged species richness, 2) weighted endemism richness, and 3) threat-weighted species richness. This involves calculating polygon areas, summing to determine the total range area (excluding parts of the range we aren't considering), ordering the species by range size and giving the rank order (normalized to between 0-1). This also involves calculating the inverse of the global range size and the threat category weight.
# ------------------------------------------------------------


# reptiles  ---------
# load(fp(p_iucn_dev, "reptile_valid_files.RData"), verbose = TRUE) # rep_sf_valid
load(file = "/Users/christophercrawford/Google Drive/_Projects/Zambia/agroEcoTradeoff/external/data_new/1_IUCN_dev/rep_valid_par.RData", verbose = TRUE) # includes rep_valid (1.33 gb), which was made in the chunk "mam-valid-par". This is the one I used going forward.
object_size(rep_valid)


#####
# ------------------------------------------------------------
# add a new column for area -------------
tic("add area") ### note that I had to change "geometry" to "Shape" for birds
rep_valid <- rep_valid %>%
  mutate(., area_km2 = st_area(.["geometry"]) %>% units::set_units(km^2)) # area, caluclated from polygons in long lat projection
toc(log = TRUE) # 40.115 sec for rep_valid

table(rep_valid$seasonal) # 1: 8740, 2: 10, 5: 3
nrow(rep_valid) # 8753.

# ------------------------------------------------------------
# subset to only those ranges used in analysis,
# then, group by species, and calculate the sum of the various polygons, i.e. the total range area for each species. 
rep_valid_summary <- rep_valid %>%   # assign dat to a new object, to then be modified
  st_drop_geometry() %>%
  filter(presence == 1) %>%   # only records with Code 1 (Extant)
  filter(origin %in% c(1, 2)) %>%     # only native species (Code 1) and reintroduced (Code 2)
  filter(seasonal %in% c(1, 2, 3)) %>%   # selecting "Resident" (1), "Breeding" (2), and "Non-breeding Season" (3) ranges. Other categories include: Non-breeding Season (3), Passage (4), and Seasonal Occurrence Uncertain (5).
  filter(marine == "False") %>%   # removing all marine species
  filter(!category %in% c("EW", "EX")) %>% # remove Extinct or Extinct in the Wild species ("EW", "EX")
  group_by(binomial) %>%
  dplyr::summarize(total_range_area = sum(area_km2, na.rm = TRUE), n_polygons = n())

nrow(rep_valid_summary) # 6358 species, even - (6360 minus two EX or EW species: Contomastix charrua, Leiocephalus eremitus)

  
### what are the summary statistics? What is the median, 1st quartile, etc?
quantile(rep_valid_summary$total_range_area, probs = c(0.25, 0.5, 0.75)) 
# 1st quartile: 966.7065 km2 (old pre dropping EW EX: 964.3203 km2)
# 2nd quartile: 16,955.5827 km2 (old pre dropping EW EX: 16917.3988 km2)
# 3rd quartile: 180,190.4067 km2 (old pre dropping EW EX: 180036.9535 km2)
   

# add column to put the species in order of range size, counting upwards from the smallest range, and add a second column dividing by the total number of species
rep_valid_summary <- rep_valid_summary %>%
  arrange(total_range_area) %>%
  mutate(range_size_quantile = row_number()/max(row_number()))
nrow(rep_valid_summary) # 6358 even

amp_valid_summary %>% 
  filter(range_size_quantile <= 0.5) %>% # do <= if nrow is even, and < if nrow is odd.
  arrange(desc(total_range_area)) %>%
  nrow() # 2763
nrow(amp_valid_summary)/2

# ------------------------------------------------------------
# join total range area back to original sf object
names(rep_valid_summary)
rep_valid <- rep_valid %>% # by = c("key x" = "key y")
  left_join(rep_valid_summary, by = c("binomial" = "binomial"))
names(rep_valid)
head(rep_valid)


# ------------------------------------------------------------
# calculate inverse_range_glob & 
# threat status weight (based on Damania & Wheeler 2015, Veach et al. 2017)
rep_valid <- rep_valid %>% 
  mutate(inverse_range_glob = 1/total_range_area) %>% 
  mutate(threat_weight = 
           ifelse(category == "CR", 1,    # if CR then 1, if not, then ->
           ifelse(category == "EN", 1/2,  # if EN then 1/2, if not, then ->
           ifelse(category == "VU", 1/4,  # if VU then 1/4, if not, then ->
           ifelse(category == "NT", 1/8,  # if NT then 1/8, if not, then ->
           ifelse(category == "LC", 1/16, # if LC then 1/16, if not, then ->
           ifelse(category == "DD", 1/4, NA))))))) # if DD then 1/4 (a middle ground, conservative estimate). If not, then -> NA. This means that EW, EX are all set to NA.



# testing to make sure things look good. 
names(rep_valid)
rep_valid %>% 
  st_drop_geometry() %>%
  .[1:20, c(3, 23, 31:33, 35:36)]

### Now you can use it to filter to only "small-ranged species," those species with total range areas of less than the median (or the 1st quartile, whatever method you decide)
rep_valid %>% 
  st_drop_geometry() %>%
  filter(range_size_quantile <= 0.5) %>% # do <= if nrow is even, and < if nrow is odd.
  arrange(desc(total_range_area)) %>%
  as_tibble()

# ------------------------------------------------------------
save(rep_valid, file = "/Users/christophercrawford/Google Drive/_Projects/Zambia/agroEcoTradeoff/external/data_new/1_IUCN_dev/rep_valid_prepped.RData") # contains rep_valid (1.3 gb), but prepped for use in small species, etc. This entailed joining the table of red list categories, changing some of the column names, adding a column for area, totalling area for parts of the range we're using, and adding a column ranking the range size to allow things to be subset for small ranged species analyses.


#####
# >>>> now, it's ready to be put through cc_make_raster
#####
```

```{r rep-clip}
# --------------------------------------------------------
# clip to Zambia
rep_zambia <- rep_valid %>%
  st_intersection(., st_union(msk_sf_ll_noholes)) %>%
  st_collection_extract(., "POLYGON") # extract only polygons


# -------------------------------------------------------------
# calculate area of clipped polygons in Zambia (calculated in long lat projection)
rep_zambia <- rep_zambia %>%
  mutate(area_zambia_km2 = st_area(.["geometry"]) %>% units::set_units(km^2)) 


# -------------------------------------------------------------
# subset to only those ranges used in analysis, then 
# group by species and sum across polygons to get species' total range area in Zambia

rep_zambia_summary <- rep_zambia %>%   # assign dat to a new object, to then be modified
  st_drop_geometry() %>%
  filter(presence == 1) %>%   # only records with Code 1 (Extant)
  filter(origin %in% c(1, 2)) %>%     # only native species (Code 1) and reintroduced (Code 2)
  filter(seasonal %in% c(1, 2, 3)) %>%   # selecting "Resident" (1), "Breeding" (2), and "Non-breeding Season" (3) ranges. Other categories include: Passage (4), and Seasonal Occurrence Uncertain (5).
  filter(marine == "False") %>%   # removing all marine species, except for bird species
  filter(!category %in% c("EW", "EX")) %>% # remove Extinct or Extinct in the Wild species ("EW", "EX")
  group_by(binomial) %>%
  dplyr::summarize(total_zambia_range_area = sum(area_zambia_km2, na.rm = TRUE), n_polygons = n())

nrow(rep_zambia_summary) # 37 species, odd number of rows

  
# what are the summary statistics? What is the median, 1st quartile, etc?
quantile(rep_zambia_summary$total_zambia_range_area, probs = c(0.25, 0.5, 0.75)) 
# 1st quartile: 677.0284 (global: 966.7065 km2)
# 2nd quartile: 9,936.0568 (global: 16,955.5827 km2)
# 3rd quartile: 141,564.2241 (global: 180,190.4067 km2)
     

# ------------------------------------------------------------
# add column to put the species in order of range size, 
# counting upwards from the smallest range, and add a second column 
# dividing by the total number of species
rep_zambia_summary <- rep_zambia_summary %>%
  arrange(total_zambia_range_area) %>%
  mutate(range_size_quantile_zambia = row_number()/max(row_number()))
  
nrow(rep_zambia_summary) # 37
tail(rep_zambia_summary)

median(rep_zambia_summary$total_zambia_range_area)

rep_zambia_summary %>% 
  filter(range_size_quantile_zambia < 0.5) %>% # do <= if nrow is even, and < if nrow is odd.
  arrange(desc(total_zambia_range_area)) %>%
  nrow() # 18
nrow(rep_zambia_summary)/2

# ------------------------------------------------------------
# join total Zambia range area back to clipped sf object
names(rep_zambia_summary)
rep_zambia <- rep_zambia %>% # by = c("key x" = "key y")
  left_join(rep_zambia_summary, by = c("binomial" = "binomial"))



# -------------------------------------------------------------
# calculate the inverse of the range in Zambia
rep_zambia <- rep_zambia %>%
  mutate(inverse_range_zam = 1/total_zambia_range_area) 


# -------------------------------------------------------------
save(rep_zambia, file = "/Users/christophercrawford/Google Drive/_Projects/Zambia/agroEcoTradeoff/external/data_new/1_IUCN_dev/rep_zambia.RData") # includes rep_zambia, which has had area added, been prepped, and then clipped to zambia



# -------------------------------------------------------------
# extras:



# clip to buffer
rep_zambia_4deg_buff <- rep_valid %>%
  st_intersection(., st_union(msk_sf_ll_4deg_buff)) %>%
  st_collection_extract(., "POLYGON")
plot(rep_zambia_4deg_buff$geometry)
save(rep_zambia_4deg_buff, file = "/Users/christophercrawford/Google Drive/_Projects/Zambia/agroEcoTradeoff/external/data_new/1_IUCN_dev/rep_zambia_4deg_buff.RData") # includes rep_zambia, which has had area added, been prepped, and then clipped to zambia
```

```{r rep-list-final}
nrow(rep_valid_summary) # 6358 reptile species globally (even)
nrow(rep_zambia_summary) # 37 reptile species in Zambia (odd)

rep_list <- cc_make_raster8(input_sf = rep_zambia, 
                             run_clip = FALSE, run_extract = FALSE,
                             clip_area = msk_sf_ll_noholes, 
                             odd_n_global = FALSE, odd_n_zam = TRUE)

rep_list$brick
object_size(rep_list)

plot(rep_list$brick$all_richness)
plot(rep_list$brick$endemism_richness)
plot(rep_list$brick$endemism_zam_richness)
plot(rep_list$brick$threat_richness)
plot(rep_list$brick$threat_weighted_richness)
plot(rep_list$brick$small_richness)
plot(rep_list$brick$small_zam_richness)
plot(rep_list$brick$small_threat_richness)


save(rep_list, file = "/Users/christophercrawford/Google Drive/_Projects/Zambia/agroEcoTradeoff/external/data_new/1_IUCN_dev/rep_list.RData")

load(file = "/Users/christophercrawford/Google Drive/_Projects/Zambia/agroEcoTradeoff/external/data_new/1_IUCN_dev/rep_list.RData", verbose = TRUE)

rep_brick <- writeRaster(rep_list$brick, filename = fp(p_iucn_dev, "rep_brick.tif"), overwrite = TRUE)
names(rep_brick) <- names(rep_list$brick)
```





```{r rep-manual-fasterize}
rep_terr_threat_richness <- rep_sf_valid %>%   # assign rep_sf to a new object, to then be modified
  filter(presence == 1) %>%   # only records with Code 1 (Extant)
  filter(origin == 1) %>%     # only native species (Code 1)
  filter(marine == "False") %>%   # removing all marine species
  filter(category %in% c("CR", "EN", "VU")) %>%   # choosing threatened species, removing LC [Least Concern], EX [Extinct], EW [Extinct in the Wild], NT [Near Threatened], & DD [Data Deficient]
  #st_crop(extent(-140.00000, 220.00000, -90, 90)) %>%
  #st_intersection(st_union(africa)) %>% st_cast("MULTIPOLYGON") %>%
  st_transform(aaeac) %>%   # reproject shapefiles to Albers Equal Area projection
  #fasterize(., raster(., res = 1), fun = 'sum') #%>%
  fasterize(., extend(msk, extent(.), value = 0), fun = 'sum') #%>% # produce richness raster map
  #crop(extent(msk)) %>%
  #raster::mask(msk)

plot(rep_terr_threat_richness)
plot(msk_shp, add = T, border = "red")

rep_terr_threat_richness <- cc_write_reload_raster(rep_terr_threat_richness, "rep_terr_threat_richness", p_iucn_dev)


rep_zambia_threat_richness <- crop(rep_terr_threat_richness, extent(msk)) # crop to (almost) the right extent
rep_zambia_threat_richness[is.na(rep_zambia_threat_richness)] <- 0 # replace NAs with 0s
rep_zambia_threat_richness <- raster::mask(rep_zambia_threat_richness, msk) # masking, in order to set all cells in hotspots_r to NA where msk is NA.

plot(rep_zambia_threat_richness)#, col = viridis(100))
rep_zambia_threat_richness <- cc_write_reload_raster(rep_zambia_threat_richness, "rep_zambia_threat_richness", p_iucn_dev)
```



```{r rep-valid}
# old, not used. 
#
#
#

tic("rep total")
tic("st_is_valid")
rep_valid_or_not <- st_is_valid(rep_sf, reason = TRUE) # a character vector saying whether geometries are valid or not
toc()
tic("st_make_valid")
rep_sf_valid <- st_make_valid(rep_sf)
toc()
toc()
# st_is_valid: 13126.661 sec elapsed
# st_make_valid: 6964.37 sec elapsed
# rep total: 20091.034 sec elapsed

rep_valid_or_not_df <- data.frame(is_valid_reason = rep_valid_or_not)
rep_sf_valid <- rep_sf_valid %>% mutate(key = row_number())
rep_valid_or_not_df <- rep_valid_or_not_df %>% mutate(key = row_number()) 
rep_sf_valid <- rep_sf_valid %>% # joining the two tables
  left_join(rep_valid_or_not_df, by = "key")

table(rep_sf_valid$is_valid_reason) # just 8 invalid geometries
nrow(rep_sf_valid)


save(rep_sf_valid,
     file = fp(p_iucn_dev, "reptile_valid_files.RData"))

load(file = fp(p_iucn_dev, "reptile_valid_files.RData"), verbose = TRUE)
```


## all vertebrates
```{r save_list_summaries}
# note: these lists were created using the function cc_make_raster8 on January 31st, 2020. 
save(mam_list, bird_list, amp_list, rep_list, file = fp(p_iucn_dev, "vert_lists.RData"))


# global totals
nrow(mam_valid_summary) # 5527 mammal species globally (odd)
nrow(mam_zambia_summary) # 252 mammal species in Zambia (even)

nrow(bird_valid_summary) # 10936 bird species globally (even)
nrow(bird_zambia_summary) # 738 bird species in Zambia (even)

nrow(amp_valid_summary) # 6593 amphibians species globally (odd)
nrow(amp_zambia_summary) # 94 amphibians species in Zambia (even)

nrow(rep_valid_summary) # 6358 reptile species globally (even)
nrow(rep_zambia_summary) # 37 reptile species in Zambia (odd)

save(mam_valid_summary,
     bird_valid_summary,
     amp_valid_summary,
     rep_valid_summary, 
     file = fp(p_datnew, "1_IUCN_dev/vert_valid_summaries.RData"))

save(mam_zambia_summary, 
     bird_zambia_summary, 
     amp_zambia_summary, 
     rep_zambia_summary,
     file = fp(p_datnew, "1_IUCN_dev/vert_zambia_summaries.RData"))


####
load(file = fp(p_iucn_dev, "vert_lists.RData"), verbose = TRUE)
load(file = fp(p_datnew, "1_IUCN_dev/vert_valid_summaries.RData"), verbose = TRUE)
load(file = fp(p_datnew, "1_IUCN_dev/vert_zambia_summaries.RData"), verbose = TRUE)

```


```{r prep-zambia}

r1 <- cc_prep_zambia(mam_zambia_threat_richness)
r2 <- cc_prep_zambia(bird_zambia_threat_richness)
r3 <- cc_prep_zambia(amp_zambia_threat_richness)
r4 <- cc_prep_zambia(rep_zambia_threat_richness)
v <- r1 + r2 + r3 + r4
plot(v)
plot(amp_zambia_threat_richness)
plot(test)

output_raster <- crop(output_raster, extent(msk))
output_raster[is.na(output_raster)] <- 0 # replace NAs with 0s
output_raster <- raster::mask(output_raster, msk)
```

```{r vert_bricks}
save(mam_brick, bird_brick, amp_brick, rep_brick, gard_brick, file = fp(p_datnew, "vert_bricks.Rdata"))
load(file = fp(p_datnew, "vert_bricks.Rdata"), verbose = TRUE)
gard_brick

vert_bricks <- list(
  mam = mam_brick,
  bird = bird_brick,
  amp = amp_brick,
  rep = rep_brick,
  gard = gard_brick
)



plot(rep_brick$all_richness)
plot(gard_brick$all_richness)
plot(log(rep_brick$endemism_richness))
plot(log(gard_brick$endemism_richness))

plot(rep_brick$small_richness)
plot(gard_brick$small_richness)

plot(rep_brick$threat_richness)

```

```{r sum_norm_rescale_+_save}
# this script does four things: sum the vertebrate taxa, normalize them, rescale them, and finally save the brick to file.
# ---------------
# add vert rasters together -------------------------------------------------
# ---------------
# This involves three steps:
# 1. $sum, which is just the absolute sum of the four layers (mam, bird, amp, rep)
# 2. $sum_norm, which is $sum normalized to 0-1.
# 3. $norm_sum, which is calculated by individually normalizing the four layers, adding them together, and then renormalizing the sum.

# ------------------------------------------------------------------------------------
richness_names <- c("all_richness", "endemism_richness", "endemism_zam_richness", "threat_richness", "threat_weighted_richness", "small_richness", "small_zam_richness", "small_threat_richness")

names(mam_brick)

# replace rep_brick layers with gard_brick layers
rep_brick$all_richness <- gard_brick$all_richness
rep_brick$endemism_richness <- gard_brick$endemism_richness
rep_brick$small_richness <- gard_brick$small_richness

# to recreate this with the old reptile files, just use the unmodified rep_brick from load(file = fp(p_datnew, "vert_bricks.Rdata"), verbose = TRUE)


# updated for loop:
for(i in seq_along(richness_names)) {
  
  brick <- brick()
  brick$mam <- mam_brick[[i]]
  brick$bird <- bird_brick[[i]]
  brick$amp <- amp_brick[[i]]
  brick$rep <- rep_brick[[i]]
  brick$sum <- 
    brick$mam +
    brick$bird +
    brick$amp +
    brick$rep
  
  brick$sum_norm <- 
    normalize(brick$sum)
  
  brick$norm_sum <- 
    normalize(
      normalize(brick$mam) + 
      normalize(brick$bird) + 
      normalize(brick$amp) + 
      normalize(brick$rep)
      )
  
  brick$mam_10 <- cc_rescale(brick$mam, factor = 10, mask = msk)
  brick$bird_10 <- cc_rescale(brick$bird, factor = 10, mask = msk)
  brick$amp_10 <- cc_rescale(brick$amp, factor = 10, mask = msk)
  brick$rep_10 <- cc_rescale(brick$rep, factor = 10, mask = msk)
  brick$norm_sum_10 <- 
    normalize(
      normalize(brick$mam_10) + 
      normalize(brick$bird_10) + 
      normalize(brick$amp_10) + 
      normalize(brick$rep_10)
      )
  
  brick$mam_110 <- cc_rescale(brick$mam, factor = 110, mask = msk)
  brick$bird_110 <- cc_rescale(brick$bird, factor = 110, mask = msk)
  brick$amp_110 <- cc_rescale(brick$amp, factor = 110, mask = msk)
  brick$rep_110 <- cc_rescale(brick$rep, factor = 110, mask = msk)
  brick$norm_sum_110 <- 
    normalize(
      normalize(brick$mam_110) + 
      normalize(brick$bird_110) + 
      normalize(brick$amp_110) + 
      normalize(brick$rep_110)
      )
names(brick)
  # save to file
  writeRaster(brick, filename = paste0(p_iucn_dev, "/", richness_names[i], ".tif"), overwrite = TRUE)
  }

```

```{r load_vert_layers}
# load in the final brick of all the vertebrate layers.
# create layer names object
layer_names <- c("mam", "bird", "amp", "rep", "sum", "sum_norm", "norm_sum", "mam_10", "bird_10", "amp_10", "rep_10", "norm_sum_10", "mam_110", "bird_110", "amp_110", "rep_110", "norm_sum_110")

conv_eq_dt

# load in as a list of all rasters
vert_r <- list(
  all_richness = brick(paste0(p_iucn_dev, "/", richness_names[1], ".tif")),
  endemism_richness = brick(paste0(p_iucn_dev, "/", richness_names[2], ".tif")),
  endemism_zam_richness = brick(paste0(p_iucn_dev, "/", richness_names[3], ".tif")),
  threat_richness = brick(paste0(p_iucn_dev, "/", richness_names[4], ".tif")),
  threat_weighted_richness = brick(paste0(p_iucn_dev, "/", richness_names[5], ".tif")),
  small_richness = brick(paste0(p_iucn_dev, "/", richness_names[6], ".tif")),
  small_zam_richness = brick(paste0(p_iucn_dev, "/", richness_names[7], ".tif")),
  small_threat_richness = brick(paste0(p_iucn_dev, "/", richness_names[8], ".tif"))
  )

# rename layers
for(i in seq_along(vert_r)) {
  names(vert_r[[i]]) <- layer_names
}

# to load in individually
# all_richness <- brick(paste0(p_iucn_dev, "/", richness_names[1], ".tif"))
# endemism_richness <- brick(paste0(p_iucn_dev, "/", richness_names[2], ".tif"))
# endemism_zam_richness <- brick(paste0(p_iucn_dev, "/", richness_names[3], ".tif"))
# threat_richness <- brick(paste0(p_iucn_dev, "/", richness_names[4], ".tif"))
# threat_weighted_richness <- brick(paste0(p_iucn_dev, "/", richness_names[5], ".tif"))
# small_richness <- brick(paste0(p_iucn_dev, "/", richness_names[6], ".tif"))
# small_zam_richness <- brick(paste0(p_iucn_dev, "/", richness_names[7], ".tif"))
# small_threat_richness <- brick(paste0(p_iucn_dev, "/", richness_names[8], ".tif"))

  
  
# ------------------------------------------------------------------------------------
```

```{r bilinear_and_coarser_fasterize}
# testing the bilinear interpolation method
# & testing directly fasterizing into a coarser resolution msk raster 

raster_rescaled <- raster::aggregate(vert_r$all_richness$mam, fact = 110, fun = mean)
mam_110_bilinear <- disaggregate(raster_rescaled, fact = 110, method = 'bilinear') %>%
  crop(extent(msk)) %>% raster::mask(msk)

plot(vert_r$all_richness$mam)
plot(raster_rescaled)
plot(mam_110_bilinear)

# testing directly fasterizing into a coarser resolution msk raster 
msk_110 <- raster::aggregate(msk, fact = 110, fun = mean)
msk_110 <- msk_110 %>% crop(extent(msk))
plot(msk_110)
mask_filled <- msk_110
  mask_filled[is.na(mask_filled)] <- 0 # replace NAs with 0s
plot(mask_filled)

mam_richness_110_manual <- 
  fasterize(mam_list$reprojected_all, mask_filled, field = NULL, fun = 'sum')

plot(mam_richness_110_manual)
plot(vert_r$all_richness$mam_110)

```



```{r plot-tester}
border = "transparent"
pdf(file = fp("/Users/christophercrawford/Google Drive/_Projects/Zambia/agroEcoTradeoff/external/data_new/temp","vert_plots.pdf"), width = 9, height = 9)

dev.off()
par(mfrow=c(4,4), mar=c(0.5, 0.5, 0.5, 0.5), omi=c(0.1,0.1,0.1,0.1), cex.main=1) # setting the plot parameters. 

plot(vert_threat_richness_brick$mam, col = viridis(100), axes = FALSE, box=FALSE, legend=FALSE,
     main = "Threatened Mammal Richness")
addRasterLegend(vert_threat_richness_brick$mam, 
                location=c(181000, 181100, 330500, 331500), direction = "horizontal", side=1,
                nTicks = maxValue(vert_threat_richness_brick$mam), 
                cex.axis = 0.6, labelDist = 0.3, ramp=viridis(100))

click()

print("hi")
locator()
mtext("(a) Estes et al. 2016, equal weights \n areas converted to maize \n displayed by conversion order", side = 3, adj = 0.05, line = -1.3, cex = cap_size) 
mtext("Maize", side = 4, adj = 0.5, line = -3.5, cex = cap_size) 
legend("bottomright", inset = 0.05, legend = c("GMAs", "NatParks","Soy"),
           pch = 15, col = c(pacols[2:3],"#41ab5d"), bty = "n",
           pt.cex = 1, cex = legend_size)

plot(msk_sf)
plot(msk_sf)
plot(msk_sf)
plot(msk_sf)
plot(msk_sf)
plot(msk_sf)
plot(msk_sf)
plot(msk_sf)
plot(msk_sf)
plot(msk_sf)
plot(msk_sf)
plot(msk_sf)
plot(msk_sf)
plot(msk_sf)
plot(msk_sf)

dev.off()

cap_size <- 0.75
legend_size <- 1






```


```{r vert-plots}

pdf(file = fp(p_plots,"vert_plots.pdf"), width = 9, height = 8)
#png(file = fp(p_plots,"Estes-plots_test.png"), width = 8, height = 9, units = "in", res = 100)
par(mfrow=c(4,4), mar=c(1,2,2,1), oma=c(1,1,1,1), cex.main=1) # setting the plot parameters. 

plot(vert_all_richness_brick$mam, box = F, axes = F, main = "Mammals: All sp."); plot(msk_shp, add=TRUE)
plot(vert_all_richness_brick$bird, box = F, axes = F, main = "Birds: All sp.", zlim = c(300,500)); plot(msk_shp, add=TRUE)
plot(vert_all_richness_brick$amp, box = F, axes = F, main = "Amphibians: All sp."); plot(msk_shp, add=TRUE)
plot(vert_all_richness_brick$rep, box = F, axes = F, main = "Reptiles: All sp."); plot(msk_shp, add=TRUE)

plot(vert_threat_richness_brick$mam, box = F, axes = F, main = "Mammals: Threatened sp."); plot(msk_shp, add=TRUE)
plot(vert_threat_richness_brick$bird, box = F, axes = F, main = "Birds: Threatened sp."); plot(msk_shp, add=TRUE)
plot(vert_threat_richness_brick$amp, box = F, axes = F, main = "Amphibians: Threatened sp."); plot(msk_shp, add=TRUE)
plot(vert_threat_richness_brick$rep, box = F, axes = F, main = "Reptiles: Threatened sp."); plot(msk_shp, add=TRUE)

plot(vert_small_richness_brick$mam, box = F, axes = F, main = "Mammals: Small-ranged sp."); plot(msk_shp, add=TRUE)
plot(vert_small_richness_brick$bird, box = F, axes = F, main = "Birds: Small-ranged sp."); plot(msk_shp, add=TRUE)
plot(vert_small_richness_brick$amp, box = F, axes = F, main = "Amphibians: Small-ranged sp."); plot(msk_shp, add=TRUE)
plot(vert_small_richness_brick$rep, box = F, axes = F, main = "Reptiles: Small-ranged sp."); plot(msk_shp, add=TRUE)

plot(vert_small_threat_richness_brick$mam, box = F, axes = F, main = "Mammals: Small-ranged or Threatened sp."); plot(msk_shp, add=TRUE)
plot(vert_small_threat_richness_brick$bird, box = F, axes = F, main = "Birds: Small-ranged or Threatened sp."); plot(msk_shp, add=TRUE)
plot(vert_small_threat_richness_brick$amp, box = F, axes = F, main = "Amphibians: Small-ranged or Threatened sp."); plot(msk_shp, add=TRUE)
plot(vert_small_threat_richness_brick$rep, box = F, axes = F, main = "Reptiles: Small-ranged or Threatened sp."); plot(msk_shp, add=TRUE)
dev.off()


# 
# # panel 1 - Estes equal weights, converted areas only, graduated
# plot(zambia, col = "grey90", border = "transparent")
# plot(e_toff_r_maize_grad, legend = TRUE, col = col_grad1, add = TRUE)
# plot(pas[pas@data$type == "gma", ], add = TRUE, col = pacols[2],
#        border = FALSE)
# plot(pas[pas@data$type == "npark", ], add = TRUE, col = pacols[3],
#        border = FALSE)
# plot(roads, add = TRUE, lwd = 0.1, col = "grey")
# plot(msk_shp, add=TRUE)
# plot(e_toff_r_soy, col="#41ab5d", add = TRUE, legend=FALSE)
# mtext("(a) Estes et al. 2016, equal weights \n areas converted to maize \n displayed by conversion order", side = 3, adj = 0.05, line = -1.3, cex = cap_size) 
# mtext("Maize", side = 4, adj = 0.5, line = -3.5, cex = cap_size) 
# legend("bottomright", inset = 0.05, legend = c("GMAs", "NatParks","Soy"),
#            pch = 15, col = c(pacols[2:3],"#41ab5d"), bty = "n",
#            pt.cex = 1, cex = legend_size)
# 
# 
# # panel 2 - Estes, equal weights, conversion probabilities, graduated
# plot(zambia, col = "grey90", border = "transparent")
# plot(e_toff_convprob_r$maize, legend = TRUE, col = col_grad, add = TRUE)
# raster::plot(pas[pas@data$type == "gma", ], add = TRUE, col = pacols[2],
#        border = FALSE)
# plot(pas[pas@data$type == "npark", ], add = TRUE, col = pacols[3],
#        border = FALSE)
# plot(roads, add = TRUE, lwd = 0.1, col = "grey")
# plot(msk_shp, add=TRUE)
# mtext("(b) Estes et al. 2016, equal weights \n all cells displayed by conversion order \n(conversion probabilities)", side = 3, adj = 0.05, line = -1.3, cex = cap_size) 
# mtext("Maize", side = 4, adj = 0.5, line = -3.5, cex = cap_size) 
# legend("bottomright", inset = 0.05, legend = c("GMAs", "NatParks"),
#            pch = 15, col = c(pacols[2:3]), bty = "n",
#            pt.cex = 1, cex = legend_size)
# 
# 
# # panel 3 - overlap
# l_e_overlap_maize <- overlay(e_toff_r$maize,l_toff_r$maize, fun = function(x,y){
#         (1*x + 2*y)}) # 1 = e maize, 2 = l maize, 3 = both maize
# 
# plot(l_e_overlap_maize,
#      axes = FALSE, box=FALSE, legend=FALSE,
#      col=col_overlap_maize)
# plot(pas[pas@data$type == "gma", ], add = TRUE, col = pacols[2],
#        border = FALSE)
# plot(pas[pas@data$type == "npark", ], add = TRUE, col = pacols[3],
#        border = FALSE)
# plot(roads, add = TRUE, lwd = 0.08, col = "grey")
# plot(msk_shp, add=TRUE)
# mtext("(c) Maize conversion overlap: \nLaurance and Estes", side = 3, adj = 0.05, line = -1.3, cex = cap_size) 
# legend("bottomright", inset = 0, #c(0.05,0.05), # inset changes where the legend is placed. cex changes the text size.
#        legend = c("GMAs", "NatParks",
#          "Estes maize only",
#          "Laurance maize only",
#          "Both maize"), pch = 15, col = c(pacols[2:3],col_overlap_maize[2:4]), 
#        bty = "n", pt.cex = 1, cex = 0.9, ncol=1)
# 
# # panel 4 - input bd raster
# plot(cp_raster, col=col_main,
#      axes = FALSE, box=FALSE)
# plot(msk_shp, add=TRUE)
# mtext("(d) Estes et al. 2016 \nbiodiversity input layer", side = 3, adj = 0.05, line = -1.3, cex = cap_size) 
# mtext("low biodiversity      high biodiversity", side = 4, adj = 0.5, line = -1.5, cex = 0.6) 
# #legend("bottomright", inset = 0.05, 
# #       legend = c("low biodiversity", "high biodiversity"), 
# #       fill = col_main_legend,
# #       bty = "n",
# #       cex = legend_size)
# 
# 
# # panel 5 - 100% bd
# plot(zambia, col = "grey90", border = "transparent")
# plot(e_BD_r_ms, legend = FALSE, col = c("grey90", "orange", "red"), add = TRUE)
# plot(pas[pas@data$type == "gma", ], add = TRUE, col = pacols[2],
#        border = FALSE)
# plot(pas[pas@data$type == "npark", ], add = TRUE, col = pacols[3],
#        border = FALSE)
# plot(roads, add = TRUE, lwd = 0.1, col = "grey")
# plot(msk_shp, add=TRUE)
# mtext("(e) Estes et al. 2016 \n100% biodiversity", side = 3, adj = 0.05, line = -1.3, cex = cap_size)
# legend("bottomright", inset = 0.05,
#        legend = c("Maize","Soy", "GMAs", "NatParks"),
#            pch = 15, col = c("orange", "red", pacols[2:3]), bty = "n",
#            pt.cex = 1, cex = legend_size)
# 
# # panel 6 - 50/50 carbon bd
# plot(zambia, col = "grey90", border = "transparent")
# plot(e_CBD_r_ms, legend = FALSE, col = c("grey90", "orange", "red"), add = TRUE)
# plot(pas[pas@data$type == "gma", ], add = TRUE, col = pacols[2],
#        border = FALSE)
# plot(pas[pas@data$type == "npark", ], add = TRUE, col = pacols[3],
#        border = FALSE)
# plot(roads, add = TRUE, lwd = 0.1, col = "grey")
# plot(msk_shp, add=TRUE)
# mtext("(f) Estes et al. 2016 \n50% carbon, 50% biodiversity", side = 3, adj = 0.05, line = -1.3, cex = cap_size)
# legend("bottomright", inset = 0.05,
#        legend = c("Maize","Soy", "GMAs", "NatParks"),
#            pch = 15, col = c("orange", "red", pacols[2:3]), bty = "n",
#            pt.cex = 1, cex = legend_size)
# 
# #dev.off()
```

```{r resolution-plots}
pdf(file = fp(p_plots,"resolution_plots.pdf"), width = 9, height = 6)
#png(file = fp(p_plots,"Estes-plots_test.png"), width = 8, height = 9, units = "in", res = 100)
par(mfrow=c(3,4), mar=c(1,2,2,1), oma=c(1, 1, 1, 1), cex.main=1) # setting the plot parameters. 

plot(vert_all_richness_brick$norm_sum, box = F, axes = F, main = "All vert. sp. richness"); plot(msk_shp, add=TRUE)
plot(vert_threat_richness_brick$norm_sum, box = F, axes = F, main = "Threatened vert. sp. richness"); plot(msk_shp, add=TRUE)
plot(vert_small_richness_brick$norm_sum, box = F, axes = F, main = "Small-ranged vert. sp. richness"); plot(msk_shp, add=TRUE)
plot(vert_small_threat_richness_brick$norm_sum, box = F, axes = F, main = "Small-ranged or threatened vert. sp. richness"); plot(msk_shp, add=TRUE)


plot(vert_all_richness_brick$norm_sum_10, box = F, axes = F, main = "10 km x 10 km"); plot(msk_shp, add=TRUE)
plot(vert_threat_richness_brick$norm_sum_10, box = F, axes = F, main = "10 km x 10 km"); plot(msk_shp, add=TRUE)
plot(vert_small_richness_brick$norm_sum_10, box = F, axes = F, main = "10 km x 10 km"); plot(msk_shp, add=TRUE)
plot(vert_small_threat_richness_brick$norm_sum_10, box = F, axes = F, main = "10 km x 10 km"); plot(msk_shp, add=TRUE)

plot(vert_all_richness_brick$norm_sum_110, box = F, axes = F, main = "110 km x 110 km"); plot(msk_shp, add=TRUE)
plot(vert_threat_richness_brick$norm_sum_110, box = F, axes = F, main = "110 km x 110 km"); plot(msk_shp, add=TRUE)
plot(vert_small_richness_brick$norm_sum_110, box = F, axes = F, main = "110 km x 110 km"); plot(msk_shp, add=TRUE)
plot(vert_small_threat_richness_brick$norm_sum_110, box = F, main = "110 km x 110 km", axes = F); plot(msk_shp, add=TRUE)
dev.off()
```


Note that the filtered lists (i.e. mam_list) are the ones I should use for this table. They've been filtered based on presence, origin, seasonal, etc., whereas the mam_zambia sf files haven't. 
```{r species-occurence-table}
load(file = fp(p_datnew, "vert_lists.RData"), verbose = TRUE)

# < when odd number of rows (mam), but <= for even rows (everything else)
mam_list$filtered_all %>%
  filter(range_size_quantile < 0.25)

drop.levels(filter(mam_list$filtered_all, range_size_quantile < 0.25)$binomial)

load(file = fp(p_datnew, "1_IUCN_dev/vert_zambia_summaries.RData"))


# number of species in various categories for Zambia. 
names(mam_zambia)
mam_zambia %>%
  st_drop_geometry() %>%
  filter(presence == 1,
         origin %in% c(1, 2), 
         seasonal %in% c(1, 2, 3),
         marine == "False", 
         !category %in% c("EW", "EX")) %>%
  #filter(category %in% c("CR", "EN", "VU")) %>%
  #filter(range_size_quantile <= 0.5) %>% # if even number of species, then <=, otherwise <
  #filter(range_size_quantile_zambia <= 0.5) %>% # median Zambian range
  filter(category %in% c("CR", "EN", "VU") | range_size_quantile < 0.5) %>%
  .$binomial %>% unique() %>% length()

mam_list$filtered_all %>% filter(binomial == "Loxodonta africana") %>% st_geometry() %T>% plot()

length(unique(mam_list$filtered_all$binomial))# 252
length(unique(mam_list$filtered_threat$binomial)) # 11
length(unique(mam_list$filtered_small$binomial)) # 17
length(unique(mam_list$filtered_threat_small$binomial)) #26
length(unique(mam_list$filtered_small_zam$binomial)) # 126 species
length(unique(filter(mam_list$filtered_all, range_size_quantile < 0.25)$binomial)) # 9, for just the smallest 25% of ranges in Zambia

length(unique(mam_list$filtered_small_zam$binomial)) # 126 species

length(unique(bird_list$filtered_all$binomial)) # 738
length(unique(bird_list$filtered_threat$binomial)) # 20
length(unique(bird_list$filtered_small$binomial)) # 67
length(unique(bird_list$filtered_threat_small$binomial)) # 82
length(unique(bird_list$filtered_small_zam$binomial)) # 369 species
length(unique(filter(bird_list$filtered_all, range_size_quantile < 0.25)$binomial)) # 12 for just the smallest 25% of ranges in Zambia

length(unique(amp_list$filtered_all$binomial)) # 94
length(unique(amp_list$filtered_threat$binomial)) # 1
length(unique(amp_list$filtered_small$binomial)) # 3
length(unique(amp_list$filtered_threat_small$binomial)) # 3
length(unique(amp_list$filtered_small_zam$binomial)) # 47 species
length(unique(filter(amp_list$filtered_all, range_size_quantile < 0.25)$binomial)) # 0, for just the smallest 25% of ranges in Zambia


length(unique(rep_list$filtered_all$binomial)) # 37
length(unique(rep_list$filtered_threat$binomial)) # 3
length(unique(rep_list$filtered_small$binomial)) # 3
length(unique(rep_list$filtered_threat_small$binomial)) # 6
length(unique(rep_list$filtered_small_zam$binomial)) # 18 species
length(unique(filter(rep_list$filtered_all, range_size_quantile < 0.25)$binomial)) # 0, for just the smallest 25% of ranges in Zambia

species_occurrence <- data.frame(
  taxa = c("mammals", "birds", "amphibians", "reptiles"),
  all_sp = c(252, 738, 94, 37),
  threat_sp = c(11, 20, 1, 3),
  small_ranged_sp = c(17, 67, 3, 3),
  small_ranged_threat_sp = c(26, 82, 3, 6))


ggpubr::ggtexttable(species_occurrence, rows = NULL)
```


Combining all four rasters into a single layer for use in the tradeoff model.
```{r}
# fancy, combining all the polygons prior to rasterizing them.
names(mam_list$reprojected_sf)
names(bird_list$reprojected_sf)
names(amp_list$reprojected_sf)
names(rep_list$reprojected_sf)
ncell(mam_list$reprojected_sf)
ncell(bird_list$reprojected_sf)
ncell(amp_list$reprojected_sf)
ncell(rep_list$reprojected_sf)

mam_pre_merge <- mam_list$reprojected_sf %>%
  mutate(family_name = NA, common_name = NA) %>%
  select(id_no, binomial, presence, origin, seasonal, compiler, citation, dist_comm, tax_comm, 
         kingdom, phylum, class, order_, family, family_name, genus, common_name, category, 
         marine, terrestial, freshwater, key)

amp_pre_merge <- amp_list$reprojected_sf %>% 
  mutate(family_name = NA, common_name = NA) %>%
  select(id_no, binomial, presence, origin, seasonal, compiler, citation, dist_comm, tax_comm, 
         kingdom, phylum, class, order_, family, family_name, genus, common_name, category, 
         marine, terrestial, freshwater, key)

rep_pre_merge <- rep_list$reprojected_sf %>%
  mutate(family_name = NA, common_name = NA) %>%
  select(id_no, binomial, presence, origin, seasonal, compiler, citation, dist_comm, tax_comm, 
         kingdom, phylum, class, order_, family, family_name, genus, common_name, category, 
         marine, terrestial, freshwater, key)

bird_pre_merge <- bird_list$reprojected_sf %>% 
  mutate(class = "AVES", genus = NA, kingdom = NA, phylum = NA, 
         marine = NA, terrestial = NA, freshwater = NA) %>%
  rename(id_no = SISID,
         # category = RedListCategory, presence = PRESENCE, origin = ORIGIN, seasonal = SEASONAL
         binomial = SCINAME, source = SOURCE, compiler = COMPILER, citation = CITATION, dist_comm = DIST_COM, 
         tax_comm = TAX_COM, order_ = Order_, family = FamilyName, family_name = Family, 
         common_name = CommonName, geometry = Shape) %>%
  select(id_no, binomial, presence, origin, seasonal, compiler, citation, dist_comm, tax_comm, 
         kingdom, phylum, class, order_, family, family_name, genus, common_name, category, 
         marine, terrestial, freshwater, key)

vert_merge <- rbind(mam_pre_merge, bird_pre_merge, amp_pre_merge, rep_pre_merge)
vert_merge %>% as_tibble()

# cc_make_raster vertebrates --- --- --- ---
vert_list <- cc_make_raster(input_sf = vert_merge, run_filter = FALSE, run_clip = FALSE, run_reproject = FALSE)
vert_zambia_r_test <- vert_list$output_raster

# Test that it's the same as the original rasters all added together. 
vert_add <- mam_zambia_threat_richness + bird_zambia_threat_richness + amp_zambia_threat_richness + rep_zambia_threat_richness
plot(vert_add)
plot(vert_zambia_r_test)
plot(vert_add - vert_zambia_r_test); freq(vert_add - vert_zambia_r_test)

rm(vert_zambia_r_test)
rm(vert_add)


vert_zambia_threat_richness <- vert_list$output_raster
plot(vert_zambia_threat_richness)
ncell(vert_zambia_threat_richness)
ncell(vert_zambia_threat_richness[!is.na(vert_zambia_threat_richness)])
ncell(msk[!is.na(msk)])
ncell(vert_add[!is.na(vert_add)])

# `cc_write_reload_raster` --------------------------------------
vert_zambia_threat_richness <- cc_write_reload_raster(vert_zambia_threat_richness, "vert_zambia_threat_richness", p_iucn_dev)
vert_zambia_threat_richness <- cc_write_reload_raster(vert_zambia_threat_richness, "vert_zambia_threat_richness", p_final_inputs)
```


Meta-data about the files created above. 
```{r}
####################
# threatened mammal terrestrial species richness
####################
mam_terr_threat <- st_read(fp(p_iucn_dev,"mam_terr_threat.shp")) # subset of mammal IUCN dataset, filtering by presence, origin, threatenedness, terrestrial, and full species. This recreates the Laurance et al. 2014 global dataset, though it includes near threatened (NT) species, not just threatened, vulnerable, and endangered species.
mam_terr_threat_richness <- raster(fp(p_iucn_dev,"mam_terr_threat_richness.tif")) # global richness map created using fasterize, 1 km resolution
mam_zambia_terr_threat_richness <- raster(fp(p_iucn_dev,"mam_zambia_terr_threat_richness.tif")) # richness map for threatened terrestrial mammal species, in Zambia, 1 km resolution
mam_terr_threat_richness_10km <- raster(fp(p_iucn_dev,"mam_terr_threat_richness_10km.tif")) # same as above, but 10 km resolution
mam_zambia_terr_threat_richness_10km <- raster(fp(p_iucn_dev,"mam_zambia_terr_threat_richness_10km.tif")) # same as above, but 10 km resolution
mam_terr_threat_richness_110km <- raster(fp(p_iucn_dev,"mam_terr_threat_richness_110km.tif")) # same as above, but 110 km resolution
mam_zambia_terr_threat_richness_110km <- raster(fp(p_iucn_dev,"mam_zambia_terr_threat_richness_110km.tif")) # same as above, but 110 km resolution


mam_terr_all_richness
mam_terr_small_richness

```


# 2. Plant Richness
"We used data on the estimated number of vascular plant species per terrestrial Ecoregion7 to assess global patterns of floristic diversity. We adjusted the values to account for varying Ecoregion area, as recommended8, using the formula S=CAz, where S=estimated species richness, C=a fitted constant, A=Ecoregion area, and z=slope of the log species-log area relationship. A z value of 0.24 was determined empirically by assessing the log area-log species richness relationship across all Ecoregions."
They cite: 
7. Kier, G. et al. Global patterns of plant diversity and floristic knowledge. J. Biogeogr. 32, 1107-1116 (2005). 
8. Moore, J. et al. Integrating costs into conservation planning across Africa. Biol. Conserv. 117, 343-350. (2004).

```{r plants-start}
plants <- st_read("/Users/christophercrawford/Google Drive/_Projects/data/Bd/Plant Richness (Kier et al. 2005)/data/commondata/data0/wwf_ecos_plant_spcs.shp")
plants_1 <- st_read("/Users/christophercrawford/Google Drive/_Projects/data/Bd/Number of Plant Species by Terrestrial Ecoregion/Number of Plant Species by Terrestrial Ecoregion/commondata/data0/wwf_ecos_plant_spcs.shp")

object_size(plants)
st_crs(plants)

load(file = fp(p_plants_dev, "plants_valid.RData"), verbose = TRUE) # this includes plants, which has been made valid.

load(file = fp(p_plants_dev, "plants_zambia.RData"), verbose = TRUE)
load(file = fp(p_plants_dev, "plants_zambia_4deg_buff.RData"), verbose = TRUE)
```

```{r plants-valid}
plants <- cc_make_valid(plants)
save(plants, file = fp(p_plants_dev, "plants_valid.RData")) 
load(file = fp(p_plants_dev, "plants_valid.RData"), verbose = TRUE) # this includes plants, which has been made valid.
levels(plants$post_fix_reasons)
```

```{r plants-explore}
# exploring the datasets
plot(zambia_sf$geometry)

names(plants)
plants$plant_spcs # the number of plant species by terrestrial ecoregion.
plants$plantspcsm

plants %>%
  st_intersection(st_union(africa)) %>%
  st_transform(aaeac) %>%
  st_simplify(dTolerance = units::set_units(10, km), preserveTopology = TRUE) %>% # previously 5, degree.
  st_geometry() %T>%
  plot(add = FALSE)

plants %>%
  st_intersection(zambia_sf) %>%
  st_geometry() %T>%
  plot(add = FALSE)

plot(s2)



names(plants)
as_tibble(plants)
levels(as.factor(plants$ECO_NAME)) # 827 levels of regions. 
levels(as.factor(plants$REALM)) # 827 levels of regions. 


plants_zambia$plant_spcs
table(plants$plant_spcs)
plot(plants_zambia["plant_spcs"])

test <- plants_zambia %>%
  filter(plant_spcs >= -10)

plot(test["plant_spcs"])
test$plant_spcs
plot(test$geometry, col = "red")
  

ecoregions_sf %>%
  st_drop_geometry() %>%
  arrange(G200_BIOME)
```


```{r adj-richness}
# Adjust species richness by area -------------------------------
# --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- ---
# now, adjust the plant species richness per ecoregion to account for area affects. Laurance et al. 2014 followed methods from Moore et al. 2004, which utilized the species area relationship (S = cA^z), and a z value of 0.24 ("determined empirically by assessing the log area-log species richness relationship across all ecoregions." - Laurance et al. 2014, supplemental information.)
# So, what I want to do is create a new variable, w
plants <- plants %>%
  mutate(adj_richness = plant_spcs/(AREA^0.24)) #%>%
#  select(ECO_NAME, AREA, plant_spcs, adj_richness)

#test <- 
  plants %>%
  filter(plant_spcs >= 0) %>%
  st_intersection(msk_sf_ll_4deg_buff) %>% st_cast("MULTIPOLYGON") %>%
  #st_transform(aaeac) %>%
  st_geometry() %T>%
  plot()

# plot(test["plant_spcs"]) # or, plot(test, max.plot = 1)

# save prepped plants file

save(plants, file = "/Users/christophercrawford/Google Drive/_Projects/Zambia/agroEcoTradeoff/external/data_new/2_plants_dev/plants_prepped.RData") # contains plants_valid (71.3 mb), but prepped by cc_make_valid(), and adding a column for adj_richness. 




```

```{r plants-clip}
# ---- subset to Zambia
plants_zambia <- plants %>%
  st_intersection(., st_union(msk_sf_ll_noholes)) %>%
  #st_cast("MULTIPOLYGON") #%>% # also seems to work fine.
  st_collection_extract(., "POLYGON") # extract only polygons
plot(plants_zambia$geometry)


save(plants_zambia, file = "/Users/christophercrawford/Google Drive/_Projects/Zambia/agroEcoTradeoff/external/data_new/2_plants_dev/plants_zambia.RData") # includes plants_zambia, which has had a column for adj_richness added, been prepped, and then clipped to zambia


# clip to buffer
plants_zambia_4deg_buff <- plants %>%
  st_intersection(., st_union(msk_sf_ll_4deg_buff)) %>%
  st_collection_extract(., "POLYGON")
plot(plants_zambia_4deg_buff$geometry)
save(plants_zambia_4deg_buff, file = "/Users/christophercrawford/Google Drive/_Projects/Zambia/agroEcoTradeoff/external/data_new/2_plants_dev/plants_zambia_4deg_buff.RData") # includes plants_zambia, which has had area adj richness added, been prepped, and then clipped to zambia.

```


```{r manual-rasterization}
library(spatialEco)
norm1 <- normalize(plants_r)
norm2 <- raster.transformation(plants_r, trans = "norm") # checks out - normalize works as it should.
plot(norm1 - norm2); freq(norm1 - norm2, digits = 2)



# rasterize --- --- --- --- --- --- --- --- --- --- --- --- --- ---
plants_r <- plants %>%
#plants_r_adj <- plants %>%
  filter(plant_spcs >= 0) %>%
  st_intersection(st_union(africa)) %>% st_cast("MULTIPOLYGON") %>%
  st_transform(aaeac) %>%
  fasterize(., extend(msk, extent(.), value = 0), field = "plant_spcs", fun = 'last') #  raster(., res = 1)
#  fasterize(., extend(msk, extent(.), value = 0), field = "adj_richness", fun = 'last') #  raster(., res = 1)

plants_r <- plants_r %>% crop(extent(msk)) 
plants_r[is.na(plants_r)] <- 0 # replace NAs with 0s
plants_r <- plants_r %>% raster::mask(msk) # masking, in order to set all cells in hotspots_r to NA where msk is NA.



ncell(vert_zambia_threat_richness)
ncell(vert_zambia_threat_richness[!is.na(vert_zambia_threat_richness)])
ncell(msk[!is.na(msk)])
ncell(vert_add[!is.na(vert_add)])


plot(s2)
plot(s2_ZA_resample)
plot(plants_r)
cellStats(plants_r, "min")

plot(normalize(plants_r))
plants_r[plants_r == 0] <- -100
plot(plants_r)
freq(normalize(plants_r), value = 0)
freq(plants_r, digits = 10)
ncell()

plot(normalize(plants_r_adj))
plot(plants_list$output_raster)
ncell(plants_list$output_raster)



plot(plants_r)
plot(normalize(plants_r))
plot(s2)
freq(s2, digits = 2)
values(s2, row = 120)

```


```{r}
run_clip <- TRUE
clip_area <- msk_sf_ll_noholes
input_sf <- amp_valid

mask_filled <- msk
mask_filled[is.na(mask_filled)] <- 0 # replace NAs with 0s

msk_sf_ll_noholes
class(clip_area)

extent(msk_shp)

template_raster_extent <- 
    {if (run_clip) clip_area else input_sf} %>%
    st_transform(., aaeac) %>%
    {if (class(x)[1] == "sf") as_Spatial(.) else .} %>%
    extent(.)

template_raster <- extend(mask_filled, template_raster_extent, value = 0)


template_raster2 <- extend(mask_filled, value = 0,
                            extent(
                              as_Spatial(
                                st_transform(
                                  {if (run_clip) clip_area else input_sf}, aaeac)
                                )
                              )
                            )


```


```{r plants-final}
# `cc_make_raster` ---------------------------------------------
plants_list <- plants %>% 
  filter(plant_spcs >= 0) %>%
  cc_make_raster(input_sf = ., run_filter = FALSE, clip_area = msk_sf_ll_noholes, 
              fasterize_field = "plant_spcs", fasterize_fun = 'last', 
              run_mask = FALSE, prep_zambia = FALSE)

plot(plants_list$output_raster)

# optional: Zambia only, to run more quickly:

# plants_list <- plants_zambia %>% 
#   filter(plant_spcs >= 0) %>%
#   cc_make_raster(input_sf = ., run_filter = FALSE, run_clip = FALSE, 
#                  clip_area = msk_sf_ll_noholes, 
#                  fasterize_field = "plant_spcs", fasterize_fun = 'last', 
#                  run_mask = FALSE, run_extract = FALSE, prep_zambia = FALSE)


# spot checking, filling NA values around Lake Tanganyika ----------------------------------------------------
ext_tanganyika <- extent(c(546380.9, 670784.1, -1062930, -965184.5))

plot(plants_list$output_raster, ext = ext_tanganyika)
plants %>%
  st_geometry() %>%
  st_transform(aaeac) %T>%
  plot(border = "red",
       #xlim = ext_tanganyika[1:2], ylim = ext_tanganyika[3:4],
       add = T)

plot(msk_sf$geometry, add = T)

plants_zambia_r <- plants_list$output_raster
plot(plants_zambia_r, ext = ext_tanganyika)
ext_nv1 <- extent(c(552008.4, 592765.9, -1023444, -972497)) # drawExtent(show=T, col = "red")
plot(plants_zambia_r, ext = ext_nv1)

# fill NAs with 1000, the value of the closest adjancent ecoregion, and then mask by msk
plants_zambia_r[ext_nv1][is.na(plants_zambia_r[ext_nv1])] <- 1000
plants_zambia_r <- raster::mask(plants_zambia_r, msk)

# then fill all NAs with 3800, the value of the other closest ecoregion, and mask again. This should fix things. 
plants_zambia_r[ext_tanganyika][is.na(plants_zambia_r[ext_tanganyika])] <- 3800
plants_zambia_r <- raster::mask(plants_zambia_r, msk)
plot(plants_zambia_r, ext = ext_tanganyika)


ncell(msk)
ncell(plants_zambia_r)
ncell(msk[!is.na(msk)])
ncell(plants_zambia_r[!is.na(plants_zambia_r)])

test <- plants_list$output_raster %>%
  raster::mask(., msk)
ncell(test[!is.na(test)])




# ---------------------------------------------------------------------------

# save list, etc.
save(plants_list, file = "/Users/christophercrawford/Google Drive/_Projects/Zambia/agroEcoTradeoff/external/data_new/2_plants_dev/plants_list.RData")

# `cc_write_reload_raster` --------------------------------------
plants_zambia_r <- cc_write_reload_raster(plants_zambia_r, "plants_zambia_r", p_plants_dev)
plants_zambia_r <- cc_write_reload_raster(plants_zambia_r, "plants_zambia_r", p_final_inputs)
```

```{r species-area-exponent}
# check areas
summary(plants$AREA)
names(plants)
area_test <- plants %>%
  st_transform(crs_mollweide) %>%  # convert to moll projection, then calculate area from polygons in the Albers equal area projection
  mutate(., area_km2 = st_area(.["geometry"]) %>% units::set_units(km^2))

area_test %>%
  select(ECO_NAME, AREA, area_km2) %>%
  as_tibble()

plot(area_test[3,]$geometry, add = TRUE, col = "red", border = "red",  lwd = 2)
plot(st_transform(world$geometry, crs_mollweide), add = F)

plot(msk, col = viridis(100))

#####
# Now group by species, and calculate the sum of the various polygons, i.e. the total range area for each species. 
## due to polygons with self-intersections, first I implement a buffer of distance 0, to resolve that. 
area_summary_test <- area_test %>%
  group_by(ECO_NAME) %>% 
  dplyr::summarize(total_area_old = sum(AREA, na.rm = TRUE), 
                   total_area_new = sum(area_km2, na.rm = TRUE),
                   plant_spcs = min(plant_spcs),
                   n_polygons = n()) %>%
  st_drop_geometry()

View(area_summary_test)

dat <- area_summary_test %>%
  filter(plant_spcs >= 0)

plot(log(area_summary_test$plant_spcs) ~ log(area_summary_test$total_area_new))
plot(area_summary_test$plant_spcs ~ log(area_summary_test$total_area_old))
plot()


plants %>%
  arrange(ECO_NAME) %>%
  st_drop_geometry() %>%
  select(ECO_NAME, plant_spcs) %>%
  View()

summary(area_summary_test$plant_spcs)
names(plants)


exponential.model <- lm(log(plant_spcs) ~ log(total_area_old), data = dat)
summary(exponential.model)
plot(exponential.model)
```


# producing rasters of all the habitats layers (hotspots, ecoregions, IBAs/EBAs, Frontier Forests, etc.)
Note that projecting rasters from lat/long to equal area projections can sometimes result in lost or distorted data. So, it might be best to reproject the initial layers when they are still in vector format (polygons) before then reprojecting them.  


## Changing Resolution

```{r}
# to go from fine to coarse resolution
coarser_r <- aggregate(raster, fact = 4)

# to go from coarse to fine resolution
finer_r <- disaggregate(raster, fact = 4)
```


# 4. BD hotspots
```{r hotspots}
###########
# read data
hotspots_sf <- st_read(fp(p_dat_hab, "CI_bd_hotspots_2011_zip/data/commondata/data0/hotspots_2011_polygons.shp"))
hotspots_sf <- cc_make_valid(hotspots_sf) # my created function, implementing st_make_valid with pre and post st_is_valid checks in columns
mapView(hotspots_sf)
plot(st_geometry(hotspots_sf))
names(hotspots_sf)

hotspots_af_test <- st_intersection(hotspots_sf, st_union(africa)) # this returns the geometries where the two sf objects overlap. The resulting object retains attributes from the feature listed first after st_intersection() 
plot(st_union(africa), border = "blue")
plot(hotspots_af_test$geometry, add = T, col = "red")
hotspots_africa <- hotspots_sf %>% st_intersection(st_union(africa)) 
  #filter(TYPE == "hotspot_area") %>% # alternatively, you can filter by hotspot_area, then by name.
  #filter(NAME %in% levels(hotspots_sf$NAME)[c(3, 8, 10, 12, 14, 18, 20, 21, 30)]) 

plot(st_union(africa), add = FALSE, border = "black")
hotspots_africa %>% st_geometry() %T>% plot(add = TRUE, border="red")
hotspots_sf %>% filter(NAME == "Eastern Afromontane") %>% st_geometry() %T>% plot(border="blue", add = TRUE)
hotspots_africa %>% filter(NAME == "Eastern Afromontane") %>% st_geometry() %T>% plot(border="green", add = TRUE)


###########
# run pipe
hotspots_africa_r <- 
  hotspots_sf %>% # take the data, THEN
  filter(TYPE == "hotspot_area") %>% # filter by hotspot_area
  filter(NAME %in% levels(hotspots_sf$NAME)[c(3, 8, 10, 12, 14, 18, 20, 21, 30)]) %>% # then filter specifically to only include 9 African hotspots
  st_transform(aaeac) %>% # then reproject
  fasterize(., extend(msk, extent(.), value = 0), fun = 'last')
  #fasterize(., raster(., res = 1000), fun = 'last') # then rasterize.

hotspots_africa_r <- cc_write_reload_raster(hotspots_africa_r, "hotspots_africa_r", p_hotspot_dev)

# writeRaster(hotspots_africa_r, fp(p_hotspot_dev,"hotspots_africa_r.tif"), overwrite=TRUE)
# rm(hotspots_africa_r)
# hotspots_africa_r <- raster(fp(p_hotspot_dev,"hotspots_africa_r.tif"))
plot(hotspots_africa_r, col = viridis(100))


###########
## final prep for toff
###########
hotspots_zambia_r <- crop(hotspots_africa_r, extent(msk))
hotspots_zambia_r[is.na(hotspots_zambia_r)] <- 0 # replace NAs with 0s
hotspots_zambia_r <- raster::mask(hotspots_zambia_r, msk) # masking, in order to set all cells in hotspots_r to NA where msk is NA.

plot(hotspots_zambia_r, col = viridis(100))


## spot checking - need to fill in the missing spot at Lake Tanganyika:
# zoom in on an extent with values to update:
plot(hotspots_zambia_r, col = viridis(100))
ext_newvals <- drawExtent()
plot(hotspots_zambia_r, col = viridis(100), ext = ext_newvals)
plot(tanganyika, add = T) # check out how Lake Tanganyika looks overlaid.

hotspots_zambia_r[ext_newvals][hotspots_zambia_r[ext_newvals] == 0] <- 1 # Select values of hotspots_zambia_r in the new extent, then select those values in that extent that are equal to 0, and update them to 1
plot(hotspots_zambia_r, col = viridis(100), ext = ext_newvals)
plot(hotspots_zambia_r, col = viridis(100)) # looking good!

hotspots_zambia_r <- cc_write_reload_raster(hotspots_zambia_r, "hotspots_zambia_r", p_hotspot_dev)

# writeRaster(hotspots_zambia_r, fp(p_hotspot_dev,"hotspots_zambia_r.tif"), overwrite=TRUE)
# rm(hotspots_zambia_r)

# ------------------------------------------------------
# Resulting raster files
# ------------------------------------------------------
hotspots_africa_r <- raster(fp(p_hotspot_dev,"hotspots_africa_r.tif")) # all African biodiversity hotspots
hotspots_zambia_r <- raster(fp(p_hotspot_dev,"hotspots_zambia_r.tif")) # Zambia raster - final, with 0s and 1s only.

plot(hotspots_africa_r, col = viridis(100))
plot(hotspots_zambia_r, col = viridis(100)) # looking good!

plot(s4, col = viridis(100)) # Laurance hotspots layer for comparison.
plot(msk_shp, add = T)
```

```{r hotspots-final}
# `cc_make_raster` ---------------------------------------------
hotspots_list <- cc_make_raster(input_sf = hotspots_sf, fasterize_fun = 'last',
                    run_filter = FALSE, 
                    run_clip = TRUE, clip_area = africa,
                    prep_zambia = TRUE)
hotspots_zambia_r_test <- hotspots_list$output_raster

# Test that it's the same as the original raster.
plot(hotspots_zambia_r_test, col = viridis(100))
plot(hotspots_zambia_r, col = viridis(100))

plot(hotspots_zambia_r_test - hotspots_zambia_r)
freq(hotspots_zambia_r_test - hotspots_zambia_r) # checks out (after doing the spot checking.
freq(hotspots_zambia_r_test) # checks out.
freq(hotspots_zambia_r) # checks out.

rm(hotspots_zambia_r_test)


hotspots_zambia_r <- hotspots_list$output_raster


## spot checking - need to fill in the missing spot at Lake Tanganyika:
# zoom in on an extent with values to update:
plot(hotspots_zambia_r, col = viridis(100))
ext_newvals <- drawExtent()
plot(hotspots_zambia_r, col = viridis(100), ext = ext_newvals)
plot(tanganyika, add = T) # check out how Lake Tanganyika looks overlaid.

hotspots_zambia_r[ext_newvals][hotspots_zambia_r[ext_newvals] == 0] <- 1 # Select values of hotspots_zambia_r in the new extent, then select those values in that extent that are equal to 0, and update them to 1
plot(hotspots_zambia_r, col = viridis(100), ext = ext_newvals)
plot(hotspots_zambia_r, col = viridis(100)) # looking good!


# `cc_write_reload_raster` --------------------------------------
hotspots_zambia_r <- cc_write_reload_raster(hotspots_zambia_r, "hotspots_zambia_r", p_hotspot_dev)
hotspots_zambia_r <- cc_write_reload_raster(hotspots_zambia_r, "hotspots_zambia_r", p_final_inputs)
```


## Extras
### Load data
```{r}
# load the data using rgdal's readOGR() function
ogrinfo(fp(p_dat_hab, "CI_bd_hotspots_2011_zip/data/commondata/data0/hotspots_2011_polygons.shp"))
hotspots <- readOGR(fp(p_dat_hab, "/CI_bd_hotspots_2011_zip/data/commondata/data0/hotspots_2011_polygons.shp"))

## checking the data out
class(hotspots)
mapview(hotspots) # viewing an interactive map of the hotspots in html window
plot(hotspots)

levels(hotspots$NAME)
## Subset Afromontane | creating a subset to test the rasterizing function on
Afromontane <- subset(hotspots, NAME == "Eastern Afromontane")
test <- subset(hotspots, NAME == "Maputaland-Pondoland-Albany")
plot(test)


levels(hotspots$NAME)[c(3, 8, 10, 12, 14, 18, 20, 21, 30)] # the African hotspots to subset
africa_hotspots <- subset(hotspots, 
                          (NAME == "Cape Floristic Region") |
                          (NAME == "Coastal Forests of Eastern Africa") |
                          (NAME == "Eastern Afromontane") |
                          (NAME == "Guinean Forests of West Africa") |
                          (NAME == "Horn of Africa") |
                          (NAME == "Madagascar and the Indian Ocean Islands") |
                          (NAME == "Maputaland-Pondoland-Albany") |
                          (NAME == "Mediterranean Basin") |
                          (NAME == "Succulent Karoo")
                          )
plot(africa_hotspots)
africa_hotspots_terr <- subset(africa_hotspots, TYPE == "hotspot_area")
plot(africa_hotspots_terr)


#### not necessary
# reading the file in using sf
htspt <- read_sf(fp(p_dat_hab, "/CI_bd_hotspots_2011_zip/data/commondata/data0/hotspots_2011_polygons.shp"))
class(htspt)
AF2 <- subset(htspt, NAME == "Atlantic Forest")
plot(AF2["NAME"])
#####


# checking out Afromontane_WGS
Afromontane
plot(Afromontane)
Afromontane@bbox # this is the extent of the polygon for the Eastern Afromontane area
msk_shp@bbox # totally different, since they're in a different projection
crs(msk_shp)
crs(Afromontane)
```

### Reprojecting
Reprojecting the hotspot shapefiles.
Source on how to reproject vector data:
https://www.earthdatascience.org/courses/earth-analytics/spatial-data-r/reproject-vector-data/
Use: `africa_hotspots_terr_aea`, the shapefile of Africa's terrestrial biodiversity hotspots
```{r}
# reproject using spTransform
hotspots_aea <- spTransform(hotspots, crs(msk_shp)) # whole shapefile
Afromontane_aea <- spTransform(Afromontane, crs(msk_shp))# just Afromontane
africa_hotspots_terr_aea <- spTransform(africa_hotspots_terr, crs(msk_shp)) # all African hotspots

# write to file:
writeOGR(hotspots_aea,dsn = fp(p_hotspot_dev,"hotspots_aea.shp"), layer="hotspots_aea", driver="ESRI Shapefile")
writeOGR(Afromontane_aea,dsn = fp(p_hotspot_dev,"Afromontane_aea.shp"), layer="Afromontane_aea", driver="ESRI Shapefile")
writeOGR(africa_hotspots_terr_aea,dsn = fp(p_hotspot_dev,"africa_hotspots_terr_aea.shp"), layer="africa_hotspots_terr_aea", driver="ESRI Shapefile")
rm(hotspots_aea)
rm(Afromontane_aea)
rm(africa_hotspots_terr_aea)

# reload:
hotspots_aea <- readOGR(fp(p_hotspot_dev,"hotspots_aea.shp"))
Afromontane_aea <- readOGR(fp(p_hotspot_dev,"Afromontane_aea.shp"))
africa_hotspots_terr_aea <- readOGR(fp(p_hotspot_dev,"africa_hotspots_terr_aea.shp"))

plot(hotspots_aea) 
# Careful...looks like a few of the polygons were messed up during the reprojection of the full hotspots shapefile. In particular, looks like Polynesia-Micronesia, got messed up, most likely due to being right on the edge of the conical projection "Albers Equal Area." Note: gdalwarp() only works with rasters. Not sure how to fix this, but just using the africa_hotspots polygon seems like the best option. 


# plot
ext <- drawExtent(show = TRUE, col = "red")
plot(msk, ext = ext)
plot(hotspots_aea, add = T)
plot(s4, ext = ext)
plot(Afromontane_aea, add = T)
dev.off()

# other ways to plot at a particular extent
# plot(hotspots_aea, xlim = msk_shp@bbox[1, ], ylim = msk_shp@bbox[2, ])
# plot(hotspots_aea, xlim = ext3[c(1,2)], ylim = ext3[c(3,4)])
```

#### Exploring the error that occured when reprojecting.
Looks like the main problems are with Polynesia-Micronesia. Probably because it exists right at the edge of the projection, so some of the polygons get switched to the opposite side of the world map after the reprojection. It seems like cutting the polygons that straddle the 180th Meridian in half before reprojecting them should work. Perhaps the solution like this one: https://stackoverflow.com/questions/56146735/visual-bug-when-changing-robinson-projections-central-meridian-with-ggplot2/56155662#56155662. In the meantime, just use the Afromontane polygons! Sheesh.
```{r}
# Careful...looks like a few of the polygons were messed up during the reprojection. In particular, looks like Polynesia-Micronesia, and New Zealand got messed up.
plot(hotspots_aea) # a bit messed up. Not sure how to fix this, but just using the Afromontane polygon seems like the best option. Note: gdalwarp() only works with rasters.

hotspots_aea$NAME

# fancy way to use grep() to select polygons that are NOT named "New "...i.e., New Zealand or New Caledonia, which are the ones that got messed up in the reprojection. Note that grep() returns a vector of numbers corresponding to the elements of hotspots_aea$NAME. So, it returns the numbers (positions) in hotspots_aea$NAME that do not start with "New ", since the option invert = TRUE is included. Then, the subset works because I can select for the specific polygons based on the position (number) in the column hotspots_aea$NAME using the [] operators.
hotspots_aea$NAME[40]

hotspots_no_pm <- subset(hotspots_aea, NAME != hotspots_aea$NAME[grepl("Polynesia-Micronesia", hotspots_aea$NAME)])

plot(hotspots_no_pm) # this looks ok.
mapView(hotspots_no_pm)

ext <- drawExtent(show=TRUE, col="red")
plot(hotspots_aea, xlim = ext[1:2], ylim = ext[3:4])

terr_hotspots <- subset(hotspots_aea, TYPE == "hotspot_area")
plot(terr_hotspots)
mapView(hotspots_aea)
mapView(test)

# creating subsets of New Caledonia and New Zealand to play with to see if I can get the reprojection to work correctly. 
nc <- subset(hotspots_aea, NAME == "New Caledonia")
nc1 <- subset(hotspots_aea, NAME == hotspots_aea$NAME[34])
nc2 <- subset(hotspots_aea, NAME == hotspots_aea$NAME[35])
nz <- subset(hotspots_aea, NAME == "New Zealand")
nz1 <- subset(hotspots_aea, NAME == hotspots_aea$NAME[36])
nz2 <- subset(hotspots_aea, NAME == hotspots_aea$NAME[37])
pm <- subset(hotspots_aea, NAME_TYPE == "Polynesia-Micronesia_outer_limit")
plot(pm)
plot(hotspots)
plot(pm[pm$NAME_TYPE == "Polynesia_Micronesia_hotspot_area"])


# does it help to subset out Polynesia-Micronesia itself and then reproject it to aea? Nope.
pm_wgs <- subset(hotspots, NAME == "Polynesia-Micronesia")
pm_aea <- spTransform(pm_wgs, crs(msk_shp))
plot(pm_aea) # looks the same... bummer!

# just use africa_hotspots_terr_aea
```

### Creating base rasters
First, I needed to create blank rasters with the right extent, projection (aea), and resolution (1000 x 1000 m). I made four: 
1. `zr`, Zambia-sized, produced from `msk` 
2. `world_r_aea`, global scale, created using the extent of `hotspots_aea`
3. `world_r_aea2`, global scale, created using the extent of `worldRaster_aea_coarse`
4. `africa_r`, Africa sized, created using extent of `africa_hotspots_terr_aea` (could alternatively use `Africa`, in aea reprojected subset from `world_sp`.

Use: `africa_r`, the raster set to the size of `africa_hotspots_terr_aea`, the shapefile of Africa's terrestrial biodiversity hotspots

A note about rasters and resolutions. If to an existing plot (or msk_shp for example) I add a large raster (global sized) without specifying an extent, it will sometimes plot the raster at a lower resolution than it really exists at.

```{r}
# 1. making a Raster the shape and size of Zambia, but filled with 0s
zr <- msk
plot(zr)
zr[!is.na(values(zr))] <- 0  # fill values with 0
plot(zr) # resolution is 1000 x 1000

# 2. using the hotspots_aea extent as a boundary.
world_r_aea <- raster(ext =  extent(hotspots_aea), crs = crs(msk_shp), resolution = 1000, vals=0)

# 3. now using the worldRaster_aea extent as the boundary
world_r_aea2 <- raster(ext =  extent(worldRaster_aea_coarse), crs = crs(msk_shp), resolution = 1000, vals=0)

# 4. using africa_hotspots_terr_aea extent
africa_r <- raster(ext =  extent(africa_hotspots_terr_aea), crs = crs(msk_shp), resolution = 1000, vals=0)

###
# write rasters to file
writeRaster(zr,fp(p_datnew,"zr.tif"), overwrite=TRUE)
writeRaster(world_r_aea,fp(p_datnew,"world_r_aea.tif"), overwrite=TRUE)
writeRaster(world_r_aea2,fp(p_datnew,"world_r_aea2.tif"), overwrite=TRUE) # this doesn't work - not enough memory?
writeRaster(africa_r,fp(p_datnew,"africa_r.tif"), overwrite=TRUE)


rm(zr, world_r_aea, world_r_aea2, africa_r)

###
# remove it and then load it back in
# rm(worldRaster_aea_coarse)
world_r_aea <- raster(fp(p_datnew,"world_r_aea.tif"))
# world_r_aea2 <- raster(fp(p_datnew,"world_r_aea2.tif"))
africa_r <- raster(fp(p_datnew,"africa_r.tif"))
zr <- raster(fp(p_datnew,"zr.tif"))

#####################################
# Creating rasters totally from scratch:
# Creating a raster at the desired resolution, global in scale.
### Making two from scratch, with different crs
##### wgs projection
r_wgs <- raster(nrows=180, ncols=360, xmn=-180, xmx=180, ymn=-90, ymx=90, 
            crs = "+proj=longlat +datum=WGS84 +no_defs +ellps=WGS84 +towgs84=0,0,0", 
            resolution = 0.1, vals=NULL)
values(r_wgs) <- 1:ncell(r_wgs)
plot(r_wgs)
plot(Afromontane, add = T)

```

### rasterize() hotspots
Rasterizing the African hotspots onto varying base rasters
1. `hotspots_r`, rasterizing onto `africa_r`, a raster sized to the extent of `africa_hotspots_terr_aea`
2. `hotspots_r1`, rasterizing onto `zr`, the Zambia-sized, produced from `msk` 
3. `hotspots_r2`, rasterizing onto `world_r_aea`, global scale, created using the extent of `hotspots_aea`
4. `hotspots_r3`, rasterizing onto `world_r_aea2`, global scale, created using the extent of `worldRaster_aea_coarse`
5. `hotspots_r4`, rasterizing directly onto `worldRaster_aea_coarse`

```{r}
# rasterizing 

# 1. just with africa_r
africa_hotspots_r_last <- rasterize(africa_hotspots_terr_aea, 
               africa_r,
               field = 1, # potentially replace with the column name "NAME"
               fun = 'last') # note that fun = 'count' gave some values of 2 in strange places, so I'm using fun = 'last'.

africa_hotspots_r_first <- rasterize(africa_hotspots_terr_aea, 
               africa_r,
               field = 1, # potentially replace with the column name "NAME"
               fun = 'first')

africa_hotspots_r_count <- rasterize(africa_hotspots_terr_aea, 
               africa_r,
               field = 1, # potentially replace with the column name "NAME"
               fun = 'count')

```

##### Explore
```{r}
# visualizing just Zambia
plot(msk_shp)
plot(africa_hotspots_r, add = T, ext = extent(Afromontane_aea), col = "red")
plot(africa_hotspots_terr_aea, add = T, col = "green")

ext <- drawExtent(show = T, col = "red")
plot(africa_hotspots_r, ext = ext, col = "gray") # notice that Lake Tanganyika is filled in, as if it's a hotspot. Maybe this has something to do with the fun = 'last'? 
plot(africa_hotspots_terr_aea, add = T)
plot(africa_hotspots_terr_aea, col = "green")#, xlim = ext[1:2], ylim = ext[3:4])
plot(subset(africa_hotspots_terr_aea, NAME == "Eastern Afromontane"), col = "green", xlim = ext[1:2], ylim = ext[3:4])

# trying with fun = 'first'
plot(africa_hotspots_r_first, ext = ext, add = T) # looks good, without values for Lake Tanganyika
freq(africa_hotspots_r_first)
#     value    count
#[1,]     1  6713300
#[2,]    NA 80073676

# fun = 'count'
freq(africa_hotspots_r_count)
#     value    count
#[1,]     1  6713300
#[2,]    NA 80073676
plot(africa_hotspots_r_count)
plot(africa_hotspots_terr_aea, add = T)
africa_hotspots_r_count[!is.na(values(africa_hotspots_r_count))] <- 1  # fill values with 1

# 
freq(africa_hotspots_r_last)
#      value    count
#[1,]     1  6771539
#[2,]    NA 80015437
# they differ by 6713300 - 6771539 = 58239 km2

plot(africa_hotspots_r_last, ext = ext)
plot(africa_hotspots_r_first, ext = ext)
plot(africa_hotspots_r_count, ext = ext)


test_r1 <- africa_hotspots_r_count - africa_hotspots_r_first
plot(test_r1, ext = ext)
freq(test_r1) # this gives the following:




#### Write raster to file
# write raster to file
writeRaster(africa_hotspots_r_last,fp(p_datnew,"africa_hotspots_r.tif"), overwrite=TRUE) # with filled in Lake Tanganyika
writeRaster(africa_hotspots_r_count,fp(p_datnew,"africa_hotspots_r_no_lakes.tif"), overwrite=TRUE) # without filled in Lake Tanganyika, fun = 'count'

rm(africa_hotspots_r_count, africa_hotspots_r_first)
africa_hotspots_r <- raster(fp(p_datnew,"africa_hotspots_r.tif"))
africa_hotspots_r_count <- raster(fp(p_datnew,"africa_hotspots_r_no_lakes.tif"))
plot(africa_hotspots_r, ext = extent(msk))
plot(africa_hotspots_r_count, ext = extent(msk))
```

Extras... not necessary
```{r}
# 2. I'll try it with the Zambia raster
hotspots_r1 <- rasterize(subset(hotspots_aea, NAME == "Eastern Afromontane"), 
               zr,
               field = 1, # this could potentially be replaced by the column name "NAME"
               fun = 'count')
plot(msk)
plot(msk_shp, add = T)
plot(Afromontane_aea, add = T)
plot(hotspots_r1, add = T, col="red")

# 3. I'll try it with the world raster
hotspots_r2 <- rasterize(subset(hotspots_aea, NAME == "Eastern Afromontane"), 
               world_r_aea,
               field = 1,
               fun = 'count')
plot(hotspots_r2, add = F, col = "green", ext = ext3)

# 4. 
hotspots_r3 <- rasterize(subset(hotspots_aea, NAME == "Eastern Afromontane"), 
               world_r_aea2,
               field = 1,
               fun = 'count')
plot(hotspots_r3, add = F, col = "blue", ext = testext)

# 5. 
hotspots_r4 <- rasterize(subset(hotspots_aea, NAME == "Eastern Afromontane"), 
               worldRaster_aea_coarse,
               field = 1,
               fun = 'count')




##### Exploring the resulting rasters 

plot(africa_r)
plot(africa_hotspots_terr_aea, add = T)

###
africa_r # r
zr # r1
world_r_aea # r2
world_r_aea2 # r3
worldRaster_aea # r4


ext_bd <- drawExtent(show = TRUE, col = "red")
plot(msk_shp, xlim = ext_bd[1:2], ylim = ext_bd[3:4])
plot(africa_hotspots_terr_aea, add = T)
plot(africa_hotspots_r, add = T)
plot(africa_hotspots_r0, add = T)


# when using rasterize with the function fun = 'count', I got some weirdness going on with 2s and 1s...
ncell(africa_hotspots_r[africa_hotspots_r==1]) #  cells with value of 1
ncell(africa_hotspots_r[africa_hotspots_r==2]) # 5196 cells with value of 2
freq(africa_hotspots_r) 
#     value    count
#[1,]     1  6708104
#[2,]     2     5196
#[3,]    NA 80073676

# so I redid the rasterizing with fun = 'last' and got a consistent result of just 1s and NAs.
freq(africa_hotspots_r0)
#     value    count
#[1,]     1  6771539
#[2,]    NA 80015437

plot(msk_shp, xlim = ext_bd[1:2], ylim = ext_bd[3:4])

plot(africa_hotspots_r0, add = T, ext = ext_bd)
plot(msk_shp, add = T)
plot(africa_hotspots_terr_aea, add = T)

plot(africa_hotspots_r0, col = topo.colors(10))
plot(africa_hotspots_r, col = topo.colors(10))
test_r1 <- africa_hotspots_r0 - africa_hotspots_r
plot(test_r1, col = topo.colors(10))#, ext = ext_bd)
freq(test_r1) # this gives the following:
#     value     count
#[1,]     0   1013615
#[2,]    NA 497366518


# Note about rasters and resolutions. If to an existing plot (or msk_shp for example) I add a large raster (global sized) without specifying an extent, it will sometimes plot the raster at a lower resolution than it really exists at.


# the trim function removes outer rows and columns that only contain NA values. 
hotspots_r2_trim <- trim(hotspots_r2, values = NA) # This crashed, didn't finish. 
plot(hotspots_r2_trim)
sum(!is.na(hotspots_r2))

testr <- hotspots_r2[values(hotspots_r2) != "NA"]
sum(testr) # the number of non-NA cells in the raster hotspots_r2
sum(hotspots_r2[values(hotspots_r2) != "NA"])

which(!is.na(hotspots_r2), cells = TRUE)

# can also crop rasters:
hs_r1_af <- crop(hotspots_r1, extent(Afromontane_aea))
```

Ways to get general cell info
```{r}
cellStats(hotspots_r1, mean, na.rm = TRUE)
freq(hotspots_r1)
ncell(hotspots_r1)
plot(hotspots_r1)

# trying the trim with the smaller Zambia-sized raster
hotspots_r1_trim <- trim(hotspots_r1, values=NA)
plot(hotspots_r1_trim)
freq(hotspots_r1_trim)
ncell(hotspots_r1_trim)

tic("sum r2"); sum(hotspots_r2[values(hotspots_r2) != "NA"]); toc() # 1013653 cells, 65.345 sec elapsed
tic("sum r3"); sum(hotspots_r3[values(hotspots_r3) != "NA"]); toc() # 1013615 cells, 72.781 sec elapsed
tic("sum r4"); sum(hotspots_r4[values(hotspots_r4) != "NA"]); toc() # 1013615 cells, 76.177 sec elapsed
system.time()
plot(hotspots_r4, ext = extent(Afromontane_aea))

# timing things
tic("start")
ncell(hotspots_r2) # has 420,921,688 cells
toc()
tic("ncell"); ncell(hotspots_r2[!is.na(hotspots_r2)]); toc() # has 790646 cells with values (i.e. that are not NA)
tic("sum"); sum(hotspots_r2[values(hotspots_r2) != "NA"]); toc() # does the same thing as above, but much faster

ncell(zr)
ncell(zr[!is.na(zr)]) # number of cells that are not NA
ncell(zr[is.na(zr)]) # number of cell that are NA
ncell(zr[zr>=0]) # cells with values (greater than or equal to 0)
ncell(zr[zr==0]) # cells with a value of 0.
```

### gdal_rasterize()
```{r eval=FALSE}

# 1. just with africa_r
africa_hotspots_terr_aea
gdal_r_test <- africa_r

africa_hotspots_r_gdal <- gdal_rasterize(
  src_datasource = fp(p_hotspot_dev, "africa_hotspots_terr_aea.shp"), # polygons to rasterize
  dst_filename = fp(p_datnew, "africa_r.tif"), # source raster onto which the polygons will be rasterized
  burn = 1, 
  l = "africa_hotspots_terr_aea",
  tr = c(1000, 1000), 
  output_Raster = TRUE)

plot(africa_hotspots_r_gdal, ext = ext) # looks good
freq(africa_hotspots_r_gdal)
#     value    count
#[1,]     0 80093522
#[2,]     1  6712120


plot(africa_hotspots_r_gdal, ext = extent(msk_shp))
plot(msk_shp, add = T)

# if desired
# africa_hotspots_r_gdal[africa_hotspots_r_gdal==0] <- NA # replace the 0s with NAs

plot(africa_hotspots_r, col = "green", ext = ext, add=T)
plot(africa_hotspots_r_gdal, ext = ext, add = T)
plot(africa_hotspots_r_count, ext = ext, add = T, col="blue")
plot(msk_shp, add = T)
plot(africa_hotspots_terr_aea, add = T)

# write to file
writeRaster(africa_hotspots_r_gdal,fp(p_datnew,"africa_hotspots_r_gdal.tif"), overwrite=TRUE)
rm(africa_hotspots_r_gdal)
africa_hotspots_r_gdal <- raster(fp(p_datnew,"africa_hotspots_r_gdal.tif"))

```

#### Does gdal_rasterize burn the polygons into the africa_r file itself?
Huh... maybe I just reset the `africa_r` raster as the gdal rasterize raster for some reason. 
```{r}
africa_r <- raster(fp(p_datnew,"africa_r.tif"))
plot(africa_r) # the way it looks right now is with 1 and 0s, no NAs.
plot(africa_hotspots_r_gdal) # looks identical to africa_r does

test <- africa_r - africa_hotspots_r_gdal
plot(test) # yup, they're identical.

# reset the africa_r raster by re-running the create raster function...looks blank.
# now re running the gdal_rasterize code.
plot(africa_hotspots_r_gdal)
dev.off()
plot(africa_r)
```


### fasterize()
```{r}
install.packages("fasterize")
library(fasterize)

###########
#### load in as sf
hotspots_sf <- st_read(fp(p_dat_hab, "CI_bd_hotspots_2011_zip/data/commondata/data0/hotspots_2011_polygons.shp"))
mapView(hotspots_sf)


###########
#### subset
levels(hotspots_sf$NAME)[c(3, 8, 10, 12, 14, 18, 20, 21, 30)] # the African hotspots to subset

Afromontane_sf <- hotspots_sf[hotspots_sf$NAME == "Eastern Afromontane", ]
plot(Afromontane_sf["NAME"])

names(hotspots_sf)
mapView(filter(hotspots_sf, NAME == "Mountains of Southwest China"))
mapView(filter(hotspots_sf, TYPE == "hotspot_area"))

hotspots_sf$TYPE
hotspots_sf_terr <- subset(hotspots_sf, TYPE == "hotspot_area")
plot(hotspots_sf_terr["NAME"])

test <- filter(hotspots_sf, NAME %in% levels(hotspots_sf$NAME)[c(3, 8, 10, 12, 14, 18, 20, 21, 30)]) # the African hotspots to subset
plot(test["NAME"])

c("Cape Floristic Region", "Coastal Forests of Eastern Africa", "Eastern Afromontane", "Guinean Forests of West Africa", "Horn of Africa", "Madagascar and the Indian Ocean Islands", "Maputaland-Pondoland-Albany", "Mediterranean Basin",  "Succulent Karoo")
africa_hotspots_sf <- subset(hotspots_sf, 
                          (NAME == "Cape Floristic Region") |
                          (NAME == "Coastal Forests of Eastern Africa") |
                          (NAME == "Eastern Afromontane") |
                          (NAME == "Guinean Forests of West Africa") |
                          (NAME == "Horn of Africa") |
                          (NAME == "Madagascar and the Indian Ocean Islands") |
                          (NAME == "Maputaland-Pondoland-Albany") |
                          (NAME == "Mediterranean Basin") |
                          (NAME == "Succulent Karoo")
                          )

africa_hotspots_sf_terr <- subset(hotspots_sf_terr, 
                          (NAME == "Cape Floristic Region") |
                          (NAME == "Coastal Forests of Eastern Africa") |
                          (NAME == "Eastern Afromontane") |
                          (NAME == "Guinean Forests of West Africa") |
                          (NAME == "Horn of Africa") |
                          (NAME == "Madagascar and the Indian Ocean Islands") |
                          (NAME == "Maputaland-Pondoland-Albany") |
                          (NAME == "Mediterranean Basin") |
                          (NAME == "Succulent Karoo")
                          )
plot(africa_hotspots_sf["NAME"])
plot(africa_hotspots_sf_terr["NAME"])

#alternatively, you can just plot the geometries of the sf objects
plot(st_geometry(africa_hotspots_sf_terr))

# this is convenient because you can add these to existing plot() calls, using add = TRUE
plot(africa_hotspots_r)

plot(st_geometry(africa_hotspots_sf_terr_aea))


###########
#### reproject sf file
africa_hotspots_sf_terr_aea <- st_transform(africa_hotspots_sf_terr, crs(msk_shp))
plot(africa_hotspots_sf_terr_aea["NAME"])

# how different are the files produced in sf than those produced in sp?
africa_hotspots_terr_aea_sf_test <- st_read(fp(p_hotspot_dev,"africa_hotspots_terr_aea.shp"))
head(africa_hotspots_terr_aea_sf_test)
head(africa_hotspots_sf_terr_aea)
plot(africa_hotspots_terr_aea_sf_test["NAME"])

#they plot slightly differently, one with an automatic legend, but i can't quite figure out why.


###########
#### fasterize()
africa_hotspots_r_fast <- fasterize(africa_hotspots_sf_terr_aea, africa_r, fun = 'count') #
plot(africa_hotspots_r_fast)
plot(africa_hotspots_r) # this is the one made from fun = 'last', with the filled Lake Tanganyika.
plot(africa_hotspots_r_fast, ext = ext)
plot(msk_shp, add = T)
plot(msk_shp)
plot(africa_hotspots_r_fast, add = T, ext = extent(msk_shp))
plot(africa_hotspots_terr_aea)


###########
#### converting sf to sp
plot(africa_hotspots_sf_terr_aea["NAME"])

# see https://r-spatial.github.io/sf/reference/coerce-methods.html
africa_hotspots_sf_terr_aea$NAME
test_sp_sf <- as_Spatial(africa_hotspots_sf_terr_aea, IDs = africa_hotspots_sf_terr_aea$NAME)

plot(test_sp_sf)
plot(msk_shp, add = T)


###########
#### write to file
writeRaster(africa_hotspots_r_fast,fp(p_datnew,"africa_hotspots_r_fast.tif"), overwrite=TRUE)
rm(africa_hotspots_r_fast)
africa_hotspots_r_fast <- raster(fp(p_datnew,"africa_hotspots_r_fast.tif"))
```


# 5. Bird habitats (IBAs + EBAs)
Laurance et al. 2014 combined IBAs and EBAs into a single layer
```{r ibas-ebas}
iba_sf <- st_read(fp(p_dat_hab, "Birdlife-IBAs/IBAsGlobal_2019_March_01/IbaGlobal_2019_March_01_POL.shp"))
eba_sf <- st_read(fp(p_dat_hab, "Birdlife-EBAs/EBA/EbaMapGlobal.shp"))
msk_sf <- st_read(fp(p_datnew,"msk.shp"))

iba_sf <- cc_make_valid(iba_sf)
eba_sf <- cc_make_valid(eba_sf)
names(iba_sf)
names(eba_sf)
table(eba_sf$EBADATABAS)
nrow(eba_sf)
levels(eba_sf$EBADATABAS)
levels(eba_sf$EBANAME)


# ------------------------------------------------------
# IBAs
# ------------------------------------------------------
levels(iba_sf$Country) # 240 levels: Zambia is one of them

iba_z <- iba_sf %>%
  filter(Country == "Zambia") %>% # filter by country
  st_transform(crs(msk_shp)) # reproject

african_countries <- levels(iba_sf$Country)[c(3, 6, 23, 29, 35:36, 38, 40, 42:43, 49:51, 54, 61, 65, 67:68, 70, 79:80, 83, 91:92, 110, 117:119, 125:126, 129, 133:134, 142:143, 145, 152:153, 178, 180, 182, 184:185, 191:192, 195, 204, 207, 213, 216, 220, 224, 239:240)] # selection of African countries in IBA sf object.

iba_africa <- iba_sf %>% # all IBAs in Africa
  #filter(Country %in% african_countries) #%>% # filter by african countries
  st_intersection(st_union(africa)) %>% st_cast("MULTIPOLYGON") # alternatively, just clip to African continent
  #st_transform(crs(msk_shp)) # reproject
iba_africa1 <- iba_sf %>% st_intersection(st_union(africa))

plot(st_union(africa))
plot(st_simplify(iba_africa$geometry, dTolerance = 1000, preserveTopology = TRUE), border = "red", add = T)
plot(st_simplify(iba_africa1$geometry, dTolerance = 1000, preserveTopology = TRUE), border = "blue", add = T)


plot(msk_sf$geometry)
tic(); plot(st_simplify(iba_africa$geometry, dTolerance = 1000, preserveTopology = TRUE), border = "red", add = T); toc()


# exploratory plots
plot(s5); plot(msk_shp, add = T) # original Laurance datasets
plot(st_geometry(iba_z), border="red", add = T) # Zambia subset of the IBAs
plot(st_geometry(iba_africa), border="red", add = T) # African IBAs
plot(pas, add = T, col = adjustcolor("dark green", 0.2)) # the adjustcolor command is to set polygon transparency
plot(iba_zambia_r, add = T)

# ------------------------------------------------------
# EBAs
# ------------------------------------------------------
glimpse(eba_sf) # 218 polygons
tic(); plot(st_simplify(eba_sf$geometry, dTolerance = 100000, preserveTopology = TRUE), border = "red"); toc()
names(eba_sf)

eba_africa <- 
  eba_sf %>% # all EBAs in Africa
  st_intersection(st_union(africa)) %>% st_cast("MULTIPOLYGON") #%>%  # using the intersection method
  #st_transform(crs(msk_shp)) # reproject

plot(msk_sf$geometry)
tic(); plot(eba_africa$geometry, border = "blue", add = T); toc()
tic(); plot(st_simplify(eba_africa$geometry, dTolerance = 1000, preserveTopology = TRUE), border = "red", add = T); toc() # in this case, simplifying the polygons actually takes more time than just plotting them outright.

# are there any EBAs in Zambia?
s5_Af_aaeac <- projectRaster(s5_Af, crs = crs(msk))
msk_sf_10kmbuff <- st_buffer(msk_sf, units::set_units(100, km)) # st_buffer's default dist units seem to be in meters.
plot(s5_Af_aaeac, ext = extent(msk_sf_10kmbuff)); plot(msk_shp, add = T)


# -------------------------------
# Pipe and fasterize IBAs
# -------------------------------
iba_africa_r <- 
  iba_sf %>% # all IBAs in Africa
  filter(Country %in% african_countries) %>% # filter by african countries
  #st_intersection(st_union(africa)) %>% st_cast("MULTIPOLYGON") %>%  # using the intersection method
  st_transform(crs(msk_shp)) %>% # reproject
  fasterize(., extend(msk, extent(.), value = 0), fun = 'last') # then rasterize.

eba_africa_r <- 
  eba_sf %>% # all EBAs in Africa
  st_intersection(st_union(africa)) %>% st_cast("MULTIPOLYGON") %>%  # using the intersection method
  st_transform(crs(msk_shp)) %>% # reproject
  fasterize(., extend(msk, extent(.), value = 0), fun = 'last') # then rasterize.

# view results
plot(iba_africa_r, col = viridis(100), ext = extent(msk_shp))
plot(st_geometry(iba_africa), border="red", add = T) # African IBAs
plot(eba_africa_r, col = viridis(100), ext = extent(msk_shp))
plot(st_geometry(eba_africa), border="red", add = T) # African EBAs
plot(msk_shp, add = T)


# save results
iba_africa_r <- cc_write_reload_raster(iba_africa_r, "iba_africa_r", p_IBA_dev)
eba_africa_r <- cc_write_reload_raster(eba_africa_r, "eba_africa_r", p_IBA_dev)


# writeRaster(iba_africa_r, fp(p_IBA_dev,"iba_africa_r.tif"), overwrite=TRUE)
# rm(iba_africa_r)
# iba_africa_r <- raster(fp(p_IBA_dev,"iba_africa_r.tif"))
# 
# writeRaster(eba_africa_r, fp(p_IBA_dev,"eba_africa_r.tif"), overwrite=TRUE)
# rm(eba_africa_r)
# eba_africa_r <- raster(fp(p_IBA_dev,"eba_africa_r.tif"))

###########
## final prep for toff, iba
###########
iba_zambia_r <- crop(iba_africa_r, extent(msk)) # crop to (almost) the right extent
iba_zambia_r[is.na(iba_zambia_r)] <- 0 # replace NAs with 0s
iba_zambia_r <- raster::mask(iba_zambia_r, msk) # masking, in order to set all cells in hotspots_r to NA where msk is NA.
plot(iba_zambia_r); plot(msk_shp, add = T)

iba_zambia_r <- cc_write_reload_raster(iba_zambia_r, "iba_zambia_r", p_IBA_dev)
# writeRaster(iba_zambia_r, fp(p_IBA_dev,"iba_zambia_r.tif"), overwrite=TRUE)
# rm(iba_zambia_r)
# iba_zambia_r <- raster(fp(p_IBA_dev,"iba_zambia_r.tif"))

###########
## final prep for toff, eba
###########
eba_zambia_r <- crop(eba_africa_r, extent(msk)) # crop to (almost) the right extent
eba_zambia_r[is.na(eba_zambia_r)] <- 0 # replace NAs with 0s
eba_zambia_r <- raster::mask(eba_zambia_r, msk) # masking, in order to set all cells in hotspots_r to NA where msk is NA.
plot(eba_zambia_r); plot(msk_shp, add = T)

eba_zambia_r <- cc_write_reload_raster(eba_zambia_r, "eba_zambia_r", p_IBA_dev)
# writeRaster(eba_zambia_r, fp(p_IBA_dev,"eba_zambia_r.tif"), overwrite=TRUE)
# rm(eba_zambia_r)
# eba_zambia_r <- raster(fp(p_IBA_dev,"eba_zambia_r.tif"))

###########
## combining IBA and EBA
###########
iba_eba_zambia_r <- iba_zambia_r + eba_zambia_r
plot(iba_eba_zambia_r) # need to fix the 2s
freq(iba_eba_zambia_r)
iba_eba_zambia_r[iba_eba_zambia_r == 2] <- 1 # replace 2s with 1s

iba_eba_zambia_r <- cc_write_reload_raster(iba_eba_zambia_r, "iba_eba_zambia_r", p_IBA_dev)
# writeRaster(iba_eba_zambia_r, fp(p_IBA_dev,"iba_eba_zambia_r.tif"), overwrite=TRUE)
# rm(iba_eba_zambia_r)
# iba_eba_zambia_r <- raster(fp(p_IBA_dev,"iba_eba_zambia_r.tif"))


# ----------------------------
# Resulting raster files
# ----------------------------
iba_africa_r <- raster(fp(p_IBA_dev,"iba_africa_r.tif")) # all African IBAs - Important Bird Areas
iba_zambia_r <- raster(fp(p_IBA_dev,"iba_zambia_r.tif")) # Zambia raster of IBAs, with 0s and 1s only.
eba_africa_r <- raster(fp(p_IBA_dev,"eba_africa_r.tif")) # all African EBAs - Endemic Bird Areas
eba_zambia_r <- raster(fp(p_IBA_dev,"eba_zambia_r.tif")) # just Zambian EBAs, 0s and 1s.
iba_eba_zambia_r <- raster(fp(p_IBA_dev,"iba_eba_zambia_r.tif")) # combined raster of Zambian IBAs and EBAs, 0s and 1s, ready for the tradeoff model.


plot(iba_eba_zambia_r)
plot(s5) # Laurance hotspots layer for comparison.

plot(st_geometry(iba_africa), border="red", add = T) # African IBAs
plot(st_geometry(eba_africa), border="blue", add = T) # African EBAs
plot(msk_shp, add = T)







################################
# ------------------------------
# Extras
# ------------------------------
ncell(msk) # has 1,362,244 cells
ncell(msk[!is.na(msk)]) # has 742,821 cells with values (i.e. that are not NA)
ncell(msk[msk>=0]) # 742,821 cells with values (greater than or equal to 0)
ncell(msk[msk==0]) # has 0 cells with a value of 0.

ncell(iba_zambia_r) # has 1,362,244 cells
ncell(iba_zambia_r[!is.na(iba_zambia_r)]) # has 742,821 cells with values (i.e. that are not NA)
ncell(iba_zambia_r[iba_zambia_r>=0]) # 742,821 cells with values (greater than or equal to 0)
ncell(iba_zambia_r[iba_zambia_r==0]) # has 0 cells with a value of 0.

# simplifying the geometries
iba_simpl <- st_simplify(iba_sf, dTolerance = 0.5, preserveTopology = TRUE)
eba_simpl <- st_simplify(eba_sf, dTolerance = 0.5, preserveTopology = TRUE)
plot(st_geometry(iba_simpl))

# transforming msk_shp to latlong
msk_ll <- st_transform(msk_sf, wgs$prj4)
plot(st_geometry(msk_ll))
plot(st_geometry(iba_sf), add = T)


# alternative to filtering by country: 
# clip to Zambia shapefile
msk_sf <- st_read(fp(p_datnew,"msk.shp"))

iba_zam_test <- iba_sf %>%
  st_buffer(0.0) %>% # run a buffer with distance of 0.
  st_intersection(msk_sf) # this returns the geometries where the two sf objects overlap.

valid <- st_make_valid(iba_sf) # this makes the geometries "valid", as an alternative to running the buffer
iba_zam_test1 <- valid %>% # one 
  st_intersection(msk_ll) # this returns the geometries where the two sf objects overlap.



iba_zam_test1 %>%
  st_transform(crs(msk_shp)) %>%
  st_geometry() %T>%
  plot(col="blue")
plot(st_geometry(iba_zam_test1))
plot(st_geometry(msk_sf), add = T)
plot(st_geometry(iba_zam_test))
plot(st_geometry(iba_z), border="red", add = T) # Zambia subset of the IBAs
```

```{r merge_ibas_ebas}
names(iba_sf)
iba_sf %>% select(Country, NatName, IntName, Source, DelTxt, DelGeom) %>% as_tibble()
iba_sf$IntName[1:20]
levels(iba_sf$NatName)

# add new column to identify features as IBAs, rename some columns, and then select only four columns.
iba_pre_merge <- iba_sf %>%
  mutate(type = "iba") %>%
  rename(name = IntName,
         country = Country) %>%
  select(type, key, name, country)

names(eba_sf)
eba_sf %>% select(EBANS, EBALON, EBALAT, EBAAREA, EBAALTMIN, EBAALTMAX) %>% as_tibble()
eba_sf %>% select(EBARECID, EBANAME, EBADATABAS, EBATYPE, EBABOOKCOD, EBAFOXCODE) %>% as_tibble()

eba_pre_merge <- eba_sf %>%
  mutate(type = "eba", country = NA) %>%
  rename(name = EBANAME) %>%
  select(type, key, name, country)

iba_pre_merge %>% as_tibble()
eba_pre_merge %>% as_tibble()
names(iba_pre_merge)
names(eba_pre_merge)

iba_eba_merge <- rbind(iba_pre_merge, eba_pre_merge)
```


```{r iba_eba-final}
# 1. Following original manual method below.
# 2. Using cc_make_raster, then adding them together
# `cc_make_raster` ---------------------------------------------
iba_list <- cc_make_raster(input_sf = iba_sf, fasterize_fun = 'last',
                    run_filter = FALSE, 
                    run_clip = TRUE, clip_area = africa,
                    prep_zambia = TRUE)
iba_zambia_r_test <- iba_list$output_raster

eba_list <- cc_make_raster(input_sf = eba_sf, fasterize_fun = 'last',
                    run_filter = FALSE, 
                    run_clip = TRUE, clip_area = africa,
                    prep_zambia = TRUE)
eba_zambia_r_test <- eba_list$output_raster

plot(iba_zambia_r_test - iba_zambia_r); freq(iba_zambia_r_test - iba_zambia_r)
plot(eba_zambia_r_test - eba_zambia_r); freq(eba_zambia_r_test - eba_zambia_r) # checks out

# add them together 
iba_eba_zambia_r_test2 <- iba_zambia_r_test + eba_zambia_r_test
plot(iba_eba_zambia_r_test2) # need to fix the 2s
freq(iba_eba_zambia_r_test2)
iba_eba_zambia_r_test2[iba_eba_zambia_r_test2 == 2] <- 1 # replace 2s with 1s

plot(iba_zambia_r_test - iba_zambia_r); freq(iba_zambia_r_test - iba_zambia_r)
plot(eba_zambia_r_test - eba_zambia_r); freq(eba_zambia_r_test - eba_zambia_r)
plot(iba_eba_zambia_r_test2 - iba_eba_zambia_r); freq(iba_eba_zambia_r_test2 - iba_eba_zambia_r) # checks out.

# 3.  Using the merged sf object pre-rasterization
# version 3 - merged pre-rasterization.
iba_eba_list <- cc_make_raster(input_sf = iba_eba_merge, fasterize_fun = 'last',
                            run_filter = FALSE, 
                            run_clip = TRUE, clip_area = africa,
                            prep_zambia = TRUE)
iba_eba_zambia_r_test <- iba_eba_list$output_raster

plot(iba_eba_zambia_r); freq(iba_eba_zambia_r) # no need to fix the 2s, because of the way the rasterization works. it just chooses the "last" polygon.
# no need for this: iba_eba_zambia_r_test3[iba_eba_zambia_r_test3 == 2] <- 1 # replace 2s with 1s

plot(iba_eba_zambia_r_test - iba_eba_zambia_r)
freq(iba_eba_zambia_r_test - iba_eba_zambia_r) # checks out. Sweet!!



iba_eba_zambia_r <- iba_eba_list$output_raster
# `cc_write_reload_raster` --------------------------------------
iba_eba_zambia_r <- cc_write_reload_raster(iba_eba_zambia_r, "iba_eba_zambia_r", p_IBA_dev)
iba_eba_zambia_r <- cc_write_reload_raster(iba_eba_zambia_r, "iba_eba_zambia_r", p_final_inputs)
```

```{r kba}
kba_sf <- st_read("/Users/christophercrawford/Google Drive/_Projects/data/Habitats/BirdLife-KBAs/KBAsGlobal_2019_March_01/KbaGlobal_2019_01_March_POL.shp")
msk_sf <- st_read(fp(p_datnew,"msk.shp"))

kba_sf <- cc_make_valid(kba_sf)
names(kba_sf)
table(kba_sf$EBADATABAS)
nrow(kba_sf)
levels(kba_sf$EBANAME)


# ------------------------------------------------------
# KBAs
# ------------------------------------------------------
sort(unique(kba_sf$Country)) # 241 levels: Zambia is one of them

kba_z <- kba_sf %>%
  filter(Country == "Zambia") %>% # filter by country
  st_transform(crs(msk_shp)) # reproject

object_size(kba_z)
plot(kba_z$geometry, border = "orange", add = TRUE)

plot(iba_eba_zambia_r)
env_size(ls())
```


# 6. WWF Global 200 ecoregions
```{r g200-ecoregions}
ecoregions_sf <- st_read(fp(p_dat_hab, "global200ecoregions/g200_terr.shp"))
ecoregions_sf <- cc_make_valid(ecoregions_sf)
msk_sf <- st_read(fp(p_datnew,"msk.shp"))

# exploring the datasets, ecoregions_sf
ecoregions_sf
names(ecoregions_sf)
object_size(ecoregions_sf)
levels(as.factor(ecoregions_sf$G200_BIOME)) # 14 levels of regions. 

ecoregions_sf %>%
  st_drop_geometry() %>%
  arrange(G200_BIOME)

# exploratory plots
plot(ecoregions_sf$geometry)
plot(s6); plot(msk_shp, add = T) # original Laurance datasets
s6_Af_aaeac <- projectRaster(s6_Af, crs = crs(msk))
plot(s6_Af_aaeac, ext = extent(msk_sf_10kmbuff)); plot(msk_shp, add = T)

plot(msk_sf$geometry)


```


```{r clip-ecoregions}
# ---- subset to Zambia
ecoregions_zambia <- ecoregions_sf %>%
  st_intersection(., st_union(msk_sf_ll_noholes)) %>%
  #st_cast("MULTIPOLYGON") #%>% # also seems to work fine.
  st_collection_extract(., "POLYGON") # extract only polygons
plot(ecoregions_zambia$geometry)
plot(msk_sf_ll$geometry, add = T, border = "red")

p_ecoreg_dev
save(ecoregions_zambia, file = fp(p_ecoreg_dev, "ecoregions_zambia.RData")) # includes ecoregions_zambia, which has been made valid, been prepped, and then clipped to zambia


# clip to buffer
ecoregions_zambia_4deg_buff <- ecoregions_sf %>%
  st_intersection(., st_union(msk_sf_ll_4deg_buff)) %>%
  st_collection_extract(., "POLYGON")
plot(ecoregions_zambia_4deg_buff$geometry)
save(ecoregions_zambia_4deg_buff, file = fp(p_ecoreg_dev, "ecoregions_zambia_4deg_buff.RData")) # includes plants_zambia, which has had area adj richness added, been prepped, and then clipped to zambia.


ecoregions_africa <- ecoregions_sf %>%
  st_intersection(st_union(africa)) %>% st_cast("MULTIPOLYGON") #%>%  # using the intersection method
  #st_transform(crs(msk_shp)) 

ecoregions_africa %>%
  st_geometry() %T>% # reproject
  plot(border = "blue")

```

```{r manual-testing}
# -------------------------------
# Pipe and fasterize ecoregions
# -------------------------------
ecoregions_africa_r <- 
  ecoregions_sf %>% # all ecoregions
  st_intersection(st_union(africa)) %>% st_cast("MULTIPOLYGON") %>%  # using the intersection method
  st_transform(aaeac) %>% # reproject
  fasterize(., extend(msk, extent(.), value = 0), fun = 'last') # then rasterize.
  

# view results
plot(ecoregions_africa_r)
ecoregions_africa %>%
  st_transform(aaeac) %>%
  st_geometry() %T>%
  plot(border="blue", add = T) # African g200 ecoregions
plot(msk_shp, add = T)

# save results
ecoregions_africa_r <- cc_write_reload_raster(ecoregions_africa_r, "ecoregions_africa_r", p_ecoreg_dev)
# writeRaster(ecoregions_africa_r, fp(p_ecoreg_dev,"ecoregions_africa_r.tif"), overwrite=TRUE)
# rm(ecoregions_africa_r)
# ecoregions_africa_r <- raster(fp(p_ecoreg_dev,"ecoregions_africa_r.tif"))

###########
## final prep for toff, ecoregions
###########
ecoregions_zambia_r <- crop(ecoregions_africa_r, extent(msk)) # crop to (almost) the right extent
ecoregions_zambia_r[is.na(ecoregions_zambia_r)] <- 0 # replace NAs with 0s
ecoregions_zambia_r <- raster::mask(ecoregions_zambia_r, msk) # masking, in order to set all cells in hotspots_r to NA where msk is NA.
plot(ecoregions_zambia_r); plot(msk_shp, add = T)
plot(s6)

ecoregions_zambia_r <- cc_write_reload_raster(ecoregions_zambia_r, "ecoregions_zambia_r", p_ecoreg_dev)
# writeRaster(ecoregions_zambia_r, fp(p_ecoreg_dev,"ecoregions_zambia_r.tif"), overwrite=TRUE)
# rm(ecoregions_zambia_r)
# ecoregions_zambia_r <- raster(fp(p_ecoreg_dev,"ecoregions_zambia_r.tif"))

plot(ecoregions_africa_r)
plot(ecoregions_zambia_r)
plot(msk_shp, add = T)
```

```{r inverse_ecoregion_size}
# load in all 814 something ecoregions:
ecoregions_all <- st_read("/Users/christophercrawford/Google Drive/_Projects/data/Habitats/terr-ecoregions-TNC/tnc_terr_ecoregions.shp")

# make them valid
ecoregions_all <- cc_make_valid(ecoregions_all)

# clip them to Zambia
ecoregions_all_zambia <- ecoregions_all %>%
  st_intersection(., st_union(msk_sf_ll_noholes)) %>%
  #st_cast("MULTIPOLYGON") #%>% # also seems to work fine.
  st_collection_extract(., "POLYGON") # extract only polygons



plot(ecoregions_all_zambia$geometry)

# list the ecoregions in Zambia:
ecoregions_all_zambia$ECO_NAME %>%
  unique()
ecoregions_zam_select <- ecoregions_all %>%
  filter(ECO_NAME %in% ecoregions_all_zambia$ECO_NAME)

plot(ecoregions_zam_select$geometry)
plot(msk_sf_ll$geometry, add = T, border = "red")

ecoregions_zam_select$ECO_NAME


# calculate area of each ecoregion
# area, caluclated from polygons in long lat projection
# add column that is inverse of ecoregion_area

ecoregions_zam_select <- ecoregions_zam_select %>%
  mutate(area_km2 = st_area(.["geometry"]) %>% units::set_units(km^2),
         inverse_area = 1/area_km2) 

ecoregions_weighted_rarity <- ecoregions_zam_select %>%
  st_intersection(., st_union(msk_sf_ll_noholes)) %>%
  st_collection_extract(., "POLYGON") %>% # extract only polygons
  st_transform(aaeac) %>%
  fasterize(., raster = msk_filled, field = 'inverse_area', fun = 'last') %>%
  raster::mask(msk)

# check it out to test 
ecoregions_zam_select_clipped <- ecoregions_zam_select %>%
  st_intersection(., st_union(msk_sf_ll_noholes)) %>%
  st_collection_extract(., "POLYGON")

mapView(ecoregions_zam_select_clipped["ECO_NAME"])

plot(ecoregions_zam_select["inverse_area"])
plot(ecoregions_zam_select_clipped["inverse_area"])

plot(ecoregions_weighted_rarity)


# save file: 

ecoregions_weighted_rarity <- cc_write_reload_raster(ecoregions_weighted_rarity, "ecoregions_weighted_rarity", p_ecoreg_dev)
ecoregions_weighted_rarity <- cc_write_reload_raster(ecoregions_weighted_rarity, "ecoregions_weighted_rarity", p_final_inputs)




```


```{r ecoregions-final}
# `cc_make_raster` ---------------------------------------------
ecoregions_list <- cc_make_raster(input_sf = ecoregions_sf, fasterize_fun = 'last',
                    run_filter = FALSE, 
                    run_clip = TRUE, run_extract = TRUE, clip_area = africa,
                    prep_zambia = TRUE)

ecoregions_zambia_r <- ecoregions_list$output_raster
plot(ecoregions_list$output_raster)
plot(ecoregions_list$output_raster, ext = ext_eco)

# spot checking, filling in values around Lake Tanganyika ----------------------------------------------------
ext_eco <- extent(c(595063.2, 641692.9, -1047208, -1005969)) # drawExtent(show=T, col = "red")

plot(ecoregions_zambia_r)
plot(ecoregions_zambia_r, ext = ext_eco)
plot(st_transform(ecoregions_zambia_4deg_buff$geometry, aaeac), border = "blue", 
     #xlim = ext_eco[1:2], ylim = ext_eco[3:4],
     add = T)
plot(msk_sf$geometry, 
     #xlim = ext_tanganyika[1:2], ylim = ext_tanganyika[3:4]
     add = TRUE)

# fill 0s with 1s, the value of the closest adjancent ecoregion, and then mask by msk
ecoregions_zambia_r[ext_eco][ecoregions_zambia_r[ext_eco] == 0] <- 1
ecoregions_zambia_r <- raster::mask(ecoregions_zambia_r, msk)

plot(ecoregions_zambia_r, ext = ext_eco)
plot(ecoregions_zambia_r, ext = ext_tanganyika)


ncell(msk)
ncell(ecoregions_zambia_r)
ncell(msk[!is.na(msk)])
ncell(ecoregions_zambia_r[!is.na(ecoregions_zambia_r)])


# save list, etc.

save(ecoregions_list, file = fp(p_ecoreg_dev, "ecoregions_list.RData"))

# `cc_write_reload_raster` --------------------------------------
ecoregions_zambia_r <- cc_write_reload_raster(ecoregions_zambia_r, "ecoregions_zambia_r", p_ecoreg_dev)
ecoregions_zambia_r <- cc_write_reload_raster(ecoregions_zambia_r, "ecoregions_zambia_r", p_final_inputs)
```

# 7. Wilderness + Frontier Forests
```{r wilderness}
hbwa_sf <- st_read(fp(p_dat_hab, "D-HighBdWildernessAreas/HBWA_poly/HBWA_poly.shp"))
frontier_forests_sf <- st_read(fp(p_dat_hab, "D-FrontierForests/GFW_Frontier_Forests/data/commondata/data0/frontier.shp"))
hbwa_sf <- cc_make_valid(hbwa_sf)
frontier_forests_sf <- cc_make_valid(frontier_forests_sf)

hbwa_sf %>% filter(ID == 3) %>% st_geometry() %>% st_transform(aaeac) %T>% plot()
plot(msk_sf$geometry, add= T, border = "red")

msk_sf <- st_read(fp(p_datnew,"msk.shp"))

# exploring the datasets
s7_globe <- raster("/Users/christophercrawford/Google Drive/_Projects/Zambia/agroEcoTradeoff/external/data_new/Laurance_et_al_rasters/s7/w001001.adf")
plot(s7_globe)
# s7_globe_aaeac <- projectRaster(s7_globe, crs = crs(msk)) # ok, there is no input projection. And, even when I do the reprojection with the raster cropped to Africa, it doesn't quite work. 
plot(s7); plot(msk_shp, add = T) # original Laurance datasets
s7_Af_aaeac <- projectRaster(s7_Af, crs = crs(msk))

plot(s7_Af_aaeac, ext = extent(msk_sf_10kmbuff));  plot(msk_shp, add = T)

st_crs(frontier_forests_sf)

# -------------------------------
# exploratory plots
# -------------------------------
plot(msk_shp, add = F)
africa %>%
  st_union()
  #st_transform(crs(msk_shp)) %>%
  st_geometry() %T>%
  plot(border = "black", 
       xlim = ext[1:2], ylim = ext[3:4],
       add = F)

plot(hbwa_sf["WA_NAME"], add = FALSE)
hbwa_sf %>%
  st_transform(crs(msk_shp)) %>%
  st_geometry() %T>%
  plot(col = adjustcolor("red", 0.2), 
       border = "blue",
       add = T)

ext <- drawExtent(show=TRUE, col = "red")

# -------------------------------
# Plotting frontier forests, with nice colors
# -------------------------------
names(frontier_forests_sf)
levels(as.factor(frontier_forests_sf$THREAT_DES))
forest_table <- as_tibble(st_drop_geometry(frontier_forests_sf))
forest_table$THREAT_COD <- as.factor(forest_table$THREAT_COD)

plot(st_transform(frontier_forests_sf, crs(hbwa_sf))["THREAT_COD"], add = T)

forest_table %>% # drop geometries and then summarize, counting the number of polygons in each category
  group_by(THREAT_COD, THREAT_DES) %>% # first group by threat_cod and threat_des (or by the new one I make below, threat_new)
  dplyr::summarize(num_poly = n()) %>%
  print()

frontier_forests_sf <- frontier_forests_sf %>% # renaming factor levels
  mutate(threat_new = fct_recode(as.factor(THREAT_COD),
                               "Unassessed" = "-99",
                               "Low or No Threat (0)" = "0",
                               "Low or No Threat (1)" = "1",
                               "Medium or High Threat (2)" = "2",
                               "Medium or High Threat (3)" = "3"))

forest_colors <- rev(heat.colors(5)) # or colorRampPalette(c("yellow", "red"))(5)
forest_colors_all <- forest_colors[frontier_forests_africa$threat_new]
frontier_forests_sf %>%
  st_transform(st_crs(africa)) %>%
  st_intersection(st_union(africa)) %>% st_cast("MULTIPOLYGON") %>% 
  st_geometry() %T>%
  plot(col = forest_colors_all) # note that adding to an existing plot with 
     
legend("bottom", legend = levels(frontier_forests_sf$threat_new),
       fill = forest_colors)
africa %>% st_union() %T>% plot(add = TRUE)
africa %>% st_union() %>% st_graticule() %>% st_geometry() %T>% plot(add = TRUE)


# next steps:
# 1. select just African HBWAs and Frontier Forests, creating two new shapefiles
# 2. add these together.
# 3. rasterize these.
# 4. explore why the layer is different for s7

# -------------------------------
# cropping datasets to Africa 
# -------------------------------
frontier_forests_africa <- frontier_forests_sf %>% 
  st_transform(crs(africa)) %>% 
  st_intersection(st_union(africa)) %>% st_cast("MULTIPOLYGON") #%>% 
  #st_transform(aaeac)

plot(frontier_forests_africa$geometry)

hbwa_africa <- hbwa_sf %>% 
  st_intersection(st_union(africa)) %>% st_cast("MULTIPOLYGON") #%>% 
  #st_transform(aaeac)

hbwa_africa$WA_NAME <- droplevels(hbwa_africa$WA_NAME)
colors <- c("red", "green")
plot(hbwa_africa$geometry, border = colors[hbwa_africa$WA_NAME])
legend("bottom", legend = levels(hbwa_africa$WA_NAME),
       fill = colors)

plot(msk_sf$geometry, add = T)

# resulting sf objects
frontier_forests_africa
hbwa_africa

plot(hbwa_africa$geometry, 
     border = c("brown", "dark green")[hbwa_africa$WA_NAME], lwd = 3, 
     col = adjustcolor(c("brown", "dark green")[hbwa_africa$WA_NAME], 0.4))
plot(frontier_forests_africa$geometry, col = adjustcolor("blue", 0.4), add = T)

# merge datasets (Note: st_combine just condenses multiple features within a single sf object into one feature, it doesn't combine two sf objects)
# actually, it doesn't really make sense to combine the two sf objects. They would need to have the same column numbers and names, in order for it to make sense to combine them with something like rbind. See merge_frontier_hbwas below.

# -------------------------------
# Pipe and fasterize frontier forests and high biodiversity wilderness areas
# -------------------------------
hbwa_africa_r <- 
  hbwa_sf %>% # all high biodiversity wilderness areas
  st_intersection(st_union(africa)) %>% st_cast("MULTIPOLYGON") %>%  # using the intersection method
  st_transform(crs(msk_shp)) %>% # reproject
  fasterize(., extend(msk, extent(.), value = 0), fun = 'last') # then rasterize.

frontier_forests_africa_r <- 
  frontier_forests_sf %>%
  st_transform(crs(hbwa_sf)) %>% # reproject to same crs as africa_u
  st_intersection(st_union(africa)) %>% st_cast("MULTIPOLYGON") %>%  #clip to Africa using africa_u
  st_transform(aaeac) %>% # reproject
  fasterize(., extend(msk, extent(.), value = 0), fun = 'last') # then rasterize.


# view results
plot(hbwa_africa_r); plot(hbwa_africa$geometry, add = T)
plot(frontier_forests_africa_r, col = "green", add = T); plot(frontier_forests_africa$geometry, add = T)
plot(msk_shp, add = T)

# save results
hbwa_africa_r <- cc_write_reload_raster(hbwa_africa_r, "hbwa_africa_r", p_wilder_dev)
frontier_forests_africa_r <- cc_write_reload_raster(frontier_forests_africa_r, "frontier_forests_africa_r", p_wilder_dev)

# writeRaster(hbwa_africa_r, fp(p_wilder_dev,"hbwa_africa_r.tif"), overwrite=TRUE)
# rm(hbwa_africa_r)
# hbwa_africa_r <- raster(fp(p_wilder_dev,"hbwa_africa_r.tif"))
# 
# writeRaster(frontier_forests_africa_r, fp(p_wilder_dev,"frontier_forests_africa_r.tif"), overwrite=TRUE)
# rm(frontier_forests_africa_r)
# frontier_forests_africa_r <- raster(fp(p_wilder_dev,"frontier_forests_africa_r.tif"))

resample
# -------------------------------
# final prep for model
# -------------------------------
# high biodiversity wilderness areas
hbwa_zambia_r <- crop(hbwa_africa_r, extent(msk)) # crop to (almost) the right extent
hbwa_zambia_r[is.na(hbwa_zambia_r)] <- 0 # replace NAs with 0s
hbwa_zambia_r <- raster::mask(hbwa_zambia_r, msk) # masking, in order to set all cells in hotspots_r to NA where msk is NA.
plot(hbwa_zambia_r); plot(msk_shp, add = T)
zoom <- drawExtent(show = T, col = "red")
plot(hbwa_zambia_r, ext = zoom); plot(msk_shp, add = T)

hbwa_zambia_r <- cc_write_reload_raster(hbwa_zambia_r, "hbwa_zambia_r", p_wilder_dev)
# writeRaster(hbwa_zambia_r, fp(p_wilder_dev,"hbwa_zambia_r.tif"), overwrite=TRUE)
# rm(hbwa_zambia_r)
# hbwa_zambia_r <- raster(fp(p_wilder_dev,"hbwa_zambia_r.tif"))

###########
## final prep for toff, frontier forests
###########
# note that this piece is not necessary, as of right now, because there are no frontier forests in Zambia. 
frontier_forests_zambia_r <- crop(frontier_forests_africa_r, extent(msk)) # crop to (almost) the right extent
frontier_forests_zambia_r[is.na(frontier_forests_zambia_r)] <- 0 # replace NAs with 0s
frontier_forests_zambia_r <- raster::mask(frontier_forests_zambia_r, msk) # masking, in order to set all cells in hotspots_r to NA where msk is NA.
plot(frontier_forests_zambia_r); plot(msk_shp, add = T)
freq(frontier_forests_zambia_r) # all 0s.

frontier_forests_zambia_r <- cc_write_reload_raster(frontier_forests_zambia_r, "frontier_forests_zambia_r", p_wilder_dev)
# writeRaster(frontier_forests_zambia_r, fp(p_wilder_dev,"frontier_forests_zambia_r.tif"), overwrite=TRUE)
# rm(frontier_forests_zambia_r)
# frontier_forests_zambia_r <- raster(fp(p_wilder_dev,"frontier_forests_zambia_r.tif"))

###########
## combining frontier forests and high biodiversity wilderness areas; not needed, actually.
###########
wilderness_zambia_r <- hbwa_zambia_r + frontier_forests_zambia_r
plot(wilderness_zambia_r) 
freq(wilderness_zambia_r)
# wilderness_zambia_r[wilderness_zambia_r == 2] <- 1 # replace 2s with 1s, not needed. Not sure why I had this here.

wilderness_zambia_r <- cc_write_reload_raster(wilderness_zambia_r, "wilderness_zambia_r", p_wilder_dev)
# writeRaster(wilderness_zambia_r, fp(p_wilder_dev,"wilderness_zambia_r.tif"), overwrite=TRUE)
# rm(wilderness_zambia_r)
# wilderness_zambia_r <- raster(fp(p_wilder_dev,"wilderness_zambia_r.tif"))


# ----------------------------
# Resulting raster files
# ----------------------------
hbwa_africa_r <- raster(fp(p_wilder_dev,"hbwa_africa_r.tif")) # all African IBAs - Important Bird Areas
hbwa_zambia_r <- raster(fp(p_wilder_dev,"hbwa_zambia_r.tif")) # Zambia raster of IBAs, with 0s and 1s only.
frontier_forests_africa_r <- raster(fp(p_wilder_dev,"frontier_forests_africa_r.tif")) # all African EBAs - Endemic Bird Areas

# Note: there are no frontier forests in Zambia. 
frontier_forests_zambia_r <- raster(fp(p_wilder_dev,"frontier_forests_zambia_r.tif")) # just Zambian EBAs, 0s and 1s.
wilderness_zambia_r <- raster(fp(p_wilder_dev,"wilderness_zambia_r.tif")) # combined raster of Zambian HBWAs and Frontier Forests, 0s and 1s, ready for the tradeoff model.


plot(s4)
plot(hotspots_zambia_r)

plot(s5)
plot(iba_eba_zambia_r)

plot(s6)
plot(ecoregions_zambia_r)

plot(s7); plot(msk_shp, add = T)
plot(wilderness_zambia_r); plot(msk_shp, add = T)
```

```{r merge_frontier_hbwas}
names(hbwa_sf)
names(frontier_forests_sf)
hbwa_sf %>% select(ID, WA_NAME, TYPE) %>% as_tibble()

frontier_forests_sf %>% select(Country, NatName, IntName, Source, DelTxt, DelGeom) %>% as_tibble()
iba_sf$IntName[1:20]
levels(iba_sf$NatName)

# add new column to identify features as IBAs, rename some columns, and then select only four columns.
iba_pre_merge <- iba_sf %>%
  mutate(type = "iba") %>%
  rename(name = IntName,
         country = Country) %>%
  select(type, key, name, country)

eba_sf %>% select(EBANS, EBALON, EBALAT, EBAAREA, EBAALTMIN, EBAALTMAX) %>% as_tibble()
eba_sf %>% select(EBARECID, EBANAME, EBADATABAS, EBATYPE, EBABOOKCOD, EBAFOXCODE) %>% as_tibble()

eba_pre_merge <- eba_sf %>%
  mutate(type = "eba", country = NA) %>%
  rename(name = EBANAME) %>%
  select(type, key, name, country)

iba_pre_merge %>% as_tibble()
eba_pre_merge %>% as_tibble()
names(iba_pre_merge)
names(eba_pre_merge)

iba_eba_merge <- rbind(iba_pre_merge, eba_pre_merge)
```


```{r wilderness-final}
# `cc_make_raster` ---------------------------------------------
frontier_forests_list <- cc_make_raster(input_sf = st_transform(frontier_forests_sf, crs_longlat), fasterize_fun = 'last',
                    run_filter = FALSE, 
                    run_clip = TRUE, clip_area = africa,
                    prep_zambia = TRUE)
frontier_forests_zambia_r_test <- frontier_forests_list$output_raster

# Test that it's the same as the original raster.
plot(frontier_forests_zambia_r_test - frontier_forests_zambia_r)
freq(frontier_forests_zambia_r_test - frontier_forests_zambia_r)
rm(frontier_forests_zambia_r_test)


frontier_forests_zambia_r <- frontier_forests_list$output_raster
# `cc_write_reload_raster` --------------------------------------
frontier_forests_zambia_r <- cc_write_reload_raster(frontier_forests_zambia_r, "frontier_forests_zambia_r", p_wilder_dev)
frontier_forests_zambia_r <- cc_write_reload_raster(frontier_forests_zambia_r, "frontier_forests_zambia_r", p_final_inputs)



# `cc_make_raster` ---------------------------------------------
hbwa_list <- cc_make_raster(input_sf = hbwa_sf, fasterize_fun = 'last',
                    run_filter = FALSE, 
                    run_clip = TRUE, clip_area = africa,
                    prep_zambia = TRUE)
hbwa_zambia_r_test <- hbwa_list$output_raster

# Test that it's the same as the original raster.
plot(hbwa_zambia_r_test - hbwa_zambia_r)
freq(hbwa_zambia_r_test - hbwa_zambia_r)
rm(hbwa_zambia_r_test)


hbwa_zambia_r <- hbwa_list$output_raster
# `cc_write_reload_raster` --------------------------------------
hbwa_zambia_r <- cc_write_reload_raster(hbwa_zambia_r, "hbwa_zambia_r", p_wilder_dev)
hbwa_zambia_r <- cc_write_reload_raster(hbwa_zambia_r, "hbwa_zambia_r", p_final_inputs)


# create wilderness_r, then `cc_write_reload_raster` --------------------------------------
wilderness_zambia_r <- hbwa_zambia_r + frontier_forests_zambia_r
plot(wilderness_zambia_r); freq(wilderness_zambia_r)

wilderness_zambia_r <- cc_write_reload_raster(wilderness_zambia_r, "wilderness_zambia_r", p_wilder_dev)
wilderness_zambia_r <- cc_write_reload_raster(wilderness_zambia_r, "wilderness_zambia_r", p_final_inputs)

```

# Rescaling from 1 km x 1 km to 10 km x 10 km and 110 km x 110 km.
```{r scale}
####################
# Aggregate to 110km x 110km
####################
mam_terr_threat_richness_110km <- aggregate(mam_terr_threat_richness, fact = 110)
mam_terr_threat_richness_110km_dis <- disaggregate(mam_terr_threat_richness_110km, fact = 110)
mam_zambia_terr_threat_richness_110km <- crop(mam_terr_threat_richness_110km_dis, extent(msk)) # crop to (almost) the right extent
mam_zambia_terr_threat_richness_110km@extent <- extent(msk) # still slightly off, so forcing the extents to be the same
mam_zambia_terr_threat_richness_110km <- raster::mask(mam_zambia_terr_threat_richness_110km, msk) # mask, i.e. set all cells in hotspots_r to NA where msk is NA.

plot(mam_zambia_terr_threat_richness, col = viridis(100))
plot(mam_zambia_terr_threat_richness_10km, col = viridis(100))
plot(mam_zambia_terr_threat_richness_110km, col = viridis(100))

writeRaster(mam_terr_threat_richness_110km, fp(p_iucn_dev,"mam_terr_threat_richness_110km.tif"), overwrite=TRUE)
writeRaster(mam_zambia_terr_threat_richness_110km, fp(p_iucn_dev,"mam_zambia_terr_threat_richness_110km.tif"), overwrite=TRUE)
rm(mam_terr_threat_richness_110km)
rm(mam_zambia_terr_threat_richness_110km)
mam_terr_threat_richness_110km <- raster(fp(p_iucn_dev,"mam_terr_threat_richness_110km.tif"))
mam_zambia_terr_threat_richness_110km <- raster(fp(p_iucn_dev,"mam_zambia_terr_threat_richness_110km.tif"))
```

# Extras, unused code, etc.

```{r check-extents}
# nice if else statement to check if extents match, and update them if they don't. Nice job Chris, but you'll never actually use this. Superceded by the raster::extend() method.
if (ecoregions_zambia_r@extent != extent(msk)) { # if the extents do not match, then
  ecoregions_zambia_r@extent <- extent(msk) # set the extent of one to the extent of msk manually
  print("Extents updated...")
  if (ecoregions_zambia_r@extent == extent(msk)) { # then check if the extents match, and if they do
  print("...and they match now.") # they print that they match now
} else {print("...something is off")} # if they still don't match, something is off. 
} else { # if the extents matched at the outsets, print the following
  print("Extents are already equal")
}
```




# Final Products
Six rasters:
1 - threatened vertebrate richness (IUCN)
2 - plant species richness
4 - biodiversity hotspots (Conservation International)
5 - important bird areas and endemic bird areas (BirdLife International)
6 - global 200 ecoregions (WWF)
7 - wilderness areas (WRI's Frontier Forests and CI's High Biodiversity Wilderness Areas)


**s1.** IUCN Red-Listed threatened terrestrial vertebrate species (birds, mammals, amphibians) per pixel (1km2) (species richness). [Original data sources: @IUCN2012, BirdLife International, @Stuart2004, @Schipper2008]. [Supplementary Figure 1](http://www.globa l-roadmap.org/s/s1.jpg)

**s2.** Plant species per pixel (plant species richness). Estimated number of plant species per ecoregion globally, adjusted for ecoregion area (no. species 10,000-km-2). [Original data source: @Kier2005]. [Supplementary Figure 2](http://www.global-roadmap.org/s/s2.jpg)


Sub layer 2 – Key Habitats and Wilderness 
**s4.** Biodiversity hotspots - 35 Conservation International hotspots. [Original data source: Conservation International]. [Source: @Myers2000, @Zachos2011]. [Supplementary Figure 4](http://www.global-roadmap.org/s/s4.jpg).

**s5.** Key bird habitats, combining Important Bird Areas and Endemic Bird Areas from BirdLife International. [Sources: @Butchart2012, @Stattersfield1998]. [Supplementary Figure 5](http://www.global-roadmap.org/s/s5.jpg)

**s6.** Distribution of WWF's The Global 200 terrestrial ecoregions across Earth’s land surface. [Source: @Olson2001]. [Supplementary Figure 6](http://www.global-roadmap.org/s/s6.jpg)

**s7.** Key wilderness and biodiversity areas. [Source: @Mittermeier2003, @Bryant1997]. [Supplementary Figure 7](http://www.global-roadmap.org/s/s7.jpg)

```{r vertebrate-files}
save(mam_pre_merge, bird_pre_merge, amp_pre_merge, rep_pre_merge,
     vert_merge, vert_list, vert_zambia_threat_richness,
     file = fp(p_datnew,"vertebrate-files.RData"))

save(mam_zambia_all_richness,
     mam_zambia_threat_richness,
     mam_zambia_small_richness,
     mam_zambia_small_or_threat_richness,
     
     bird_zambia_all_richness,
     bird_zambia_threat_richness,
     bird_zambia_small_richness,
     bird_zambia_small_or_threat_richness,
     
     amp_zambia_all_richness,
     amp_zambia_threat_richness,
     amp_zambia_small_richness,
     amp_zambia_small_or_threat_richness,
     
     rep_zambia_all_richness,
     rep_zambia_threat_richness,
     rep_zambia_small_richness,
     rep_zambia_small_or_threat_richness,
     
     vert_zambia_all_richness,
     vert_zambia_threat_richness,
     vert_zambia_small_richness,
     vert_zambia_small_or_threat_richness,
     file = fp(p_datnew,"vertebrate-rasters-zambia.RData"))

# save(mam_list, bird_list, amp_list, rep_list, vert_list,
#      file = fp(p_datnew,"vertebrate-lists-zambia.RData"))



p_iucn_dev
```


```{r save-habitat-polys}
# note that all of these shapefiles have been made valid using my function make_valid()
save(hotspots_sf, hotspots_africa, #  hotspots_sf, global and africa
     iba_sf, eba_sf, iba_africa, eba_africa,# ibas and ebas, global and clipped to Africa
     ecoregions_sf, ecoregions_africa, # ecoregions, global and clipped to Africa
     hbwa_sf, hbwa_africa, # hbwa
     frontier_forests_sf, frontier_forests_africa, # frontier forests
     file = fp(p_datnew,"habitat_polys.RData"))

save(hotspots_zambia_r,
     iba_zambia_r,
     eba_zambia_r,
     iba_eba_zambia_r,
     ecoregions_zambia_r,
     hbwa_zambia_r,
     frontier_forests_zambia_r,
     wilderness_zambia_r,
     file = fp(p_datnew,"habitat_rasters_zambia.RData"))

save(hotspots_list,
     iba_list,
     eba_list,
     iba_eba_list,
     ecoregions_list,
     hbwa_list,
     frontier_forests_list, 
     file = fp(p_datnew,"habitat_lists.RData"))
```

```{r habitat-plots}
pdf(file = fp(p_plots,"vert_plots.pdf"), width = 9, height = 8)
#png(file = fp(p_plots,"Estes-plots_test.png"), width = 8, height = 9, units = "in", res = 100)
par(mfrow=c(4,4), mar=c(1,1,2,1), omi=c(0.1,0.1,0.1,0.1), cex.main=1) # setting the plot parameters. 

plot(vert_all_richness_brick$mam); plot(msk_shp, add=TRUE)
plot(vert_all_richness_brick$bird); plot(msk_shp, add=TRUE)
plot(vert_all_richness_brick$amp); plot(msk_shp, add=TRUE)
plot(vert_all_richness_brick$rep); plot(msk_shp, add=TRUE)

plot(vert_threat_richness_brick$mam); plot(msk_shp, add=TRUE)
plot(vert_threat_richness_brick$bird); plot(msk_shp, add=TRUE)
plot(vert_threat_richness_brick$amp); plot(msk_shp, add=TRUE)
plot(vert_threat_richness_brick$rep); plot(msk_shp, add=TRUE)

plot(vert_small_richness_brick$mam); plot(msk_shp, add=TRUE)
plot(vert_small_richness_brick$bird); plot(msk_shp, add=TRUE)
plot(vert_small_richness_brick$amp); plot(msk_shp, add=TRUE)
plot(vert_small_richness_brick$rep); plot(msk_shp, add=TRUE)

plot(vert_small_threat_richness_brick$mam); plot(msk_shp, add=TRUE)
plot(vert_small_threat_richness_brick$bird); plot(msk_shp, add=TRUE)
plot(vert_small_threat_richness_brick$amp); plot(msk_shp, add=TRUE)
plot(vert_small_threat_richness_brick$rep); plot(msk_shp, add=TRUE)
dev.off()
```


```{r final-zambia-files}
# threatened vertebrates ----------------------------------------------------
mam_zambia_threat_richness <- raster(fp(p_iucn_dev, "mam_zambia_threat_richness.tif"))
bird_zambia_threat_richness <- raster(fp(p_iucn_dev, "bird_zambia_threat_richness.tif"))
amp_zambia_threat_richness <- raster(fp(p_iucn_dev, "amp_zambia_threat_richness.tif"))
rep_zambia_threat_richness <- raster(fp(p_iucn_dev, "rep_zambia_threat_richness.tif"))

vert_zambia_threat_richness <- raster(fp(p_iucn_dev, "vert_zambia_threat_richness.tif"))
plot(s1)
plot(vert_zambia_threat_richness)


# plants ----------------------------------------------------
plants_zambia_r <- raster(fp(p_plants_dev, "plants_zambia_r.tif"))
plot(s2)
plot(plants_zambia_r)

# hotspots ----------------------------------------------------
hotspots_zambia_r <- raster(fp(p_hotspot_dev,"hotspots_zambia_r.tif")) # Zambia raster - final, with 0s and 1s only.

plot(s4)
plot(hotspots_zambia_r)

# Bird Habitats - IBAs and EBAs -------------------------------
iba_eba_zambia_r <- raster(fp(p_IBA_dev,"iba_eba_zambia_r.tif")) # combined raster of Zambian IBAs and EBAs, 0s and 1s, ready for the tradeoff model.

plot(s5)
plot(iba_eba_zambia_r)

# ecoregions --------------------------------------------------
ecoregions_zambia_r <- raster(fp(p_ecoreg_dev,"ecoregions_zambia_r.tif"))

plot(s6)
plot(ecoregions_zambia_r)


# wilderness --------------------------------------------------
wilderness_zambia_r <- raster(fp(p_wilder_dev,"wilderness_zambia_r.tif"))

plot(s7); plot(msk_shp, add = T)
plot(wilderness_zambia_r)
plot(msk_sf$geometry, add = T)

# save final Zambia layers ------------------------------------
save(vert_all_richness_brick,
     vert_threat_richness_brick,
     vert_small_richness_brick,
     vert_small_threat_richness_brick,
     plants_zambia_r,
     hotspots_zambia_r,
     iba_eba_zambia_r,
     ecoregions_zambia_r,
     wilderness_zambia_r,
     file = fp(p_datnew,"final-rasters-zambia.RData"))



# 
```

```{r rescaling-zambia-rasters}
vert_zambia_110 <- cc_rescale(vert_zambia_threat_richness, factor = 110, mask = msk)
plants_zambia_110 <- cc_rescale(plants_zambia_r, factor = 110, mask = msk)
hotspots_zambia_110 <- cc_rescale(hotspots_zambia_r, factor = 110, mask = msk)
iba_eba_zambia_110 <- cc_rescale(iba_eba_zambia_r, factor = 110, mask = msk)
ecoregions_zambia_110 <- cc_rescale(ecoregions_zambia_r, factor = 110, mask = msk)
wilderness_zambia_110 <- cc_rescale(wilderness_zambia_r, factor = 110, mask = msk)

plot(vert_zambia_threat_richness)
plot(vert_zambia_110)
plot(plants_zambia_r)
plot(plants_zambia_110)
plot(hotspots_zambia_r)
plot(hotspots_zambia_110)
plot(iba_eba_zambia_r)
plot(iba_eba_zambia_110)
plot(ecoregions_zambia_r)
plot(ecoregions_zambia_110)
plot(wilderness_zambia_r)
plot(wilderness_zambia_110)


# what methods should I use for aggregating? mean makes some sense for the richness rasters, but I'm not sure it does for the discrete rasters (habitats). 



```

```{r aggregate}
vert_110 <- cc_rescale(vert_zambia_threat_richness, factor = 110, mask = msk)
vert_110
plot(vert_110)


vert_zambia_threat_richness
plants_zambia_r
hotspots_zambia_r
iba_eba_zambia_r
ecoregions_zambia_r
wilderness_zambia_r


```


```{r remove-glwd}
vert_zambia_threat_richness
plants_zambia_r
hotspots_zambia_r
iba_eba_zambia_r
ecoregions_zambia_r
wilderness_zambia_r

test_r <- hotspots_list$output_raster %>% 
  raster::mask(mask = crop(glwd_zambia_r, extent(.)), inverse = TRUE)
plot(test_r)

load(file = fp(p_ZA,"parks_roads.rda")) 


```

```{r final-prep}
load(file = fp(p_datnew,"final-rasters-zambia.RData"), verbose = TRUE)
vert_zambia_threat_richness <- raster(fp(p_iucn_dev, "vert_zambia_threat_richness.tif"))
plants_zambia_r <- raster(fp(p_plants_dev, "plants_zambia_r.tif"))
hotspots_zambia_r <- raster(fp(p_hotspot_dev,"hotspots_zambia_r.tif"))
iba_eba_zambia_r <- raster(fp(p_IBA_dev,"iba_eba_zambia_r.tif"))
ecoregions_zambia_r <- raster(fp(p_ecoreg_dev,"ecoregions_zambia_r.tif"))
wilderness_zambia_r <- raster(fp(p_wilder_dev,"wilderness_zambia_r.tif"))
# could also use p_final_inputs

# normalize
z1_vert <- normalize(vert_zambia_threat_richness)
z2_plants <- normalize(plants_zambia_r)
z4_hotspots <- normalize(hotspots_zambia_r)
z5_iba_eba <- normalize(iba_eba_zambia_r)
z6_ecoregions <- normalize(ecoregions_zambia_r)
z7_wilderness <- normalize(wilderness_zambia_r)



par(mfrow = c(2,3))
plot(z1_vert)
plot(z2_plants)
plot(z4_hotspots)
plot(z5_iba_eba)
plot(z6_ecoregions)
plot(z7_wilderness)

layers <- list(z1_vert, z2_plants, z4_hotspots, z5_iba_eba, z6_ecoregions, z7_wilderness)
names <- c("z1_vert", "z2_plants", "z4_hotspots", "z5_iba_eba", "z6_ecoregions", "z7_wilderness")

list_layers <- lapply(X = 1:length(layers), FUN = function (i) {
  dope <- cc_write_reload_raster(layers[[i]], names[i], p_temp)
  return(dope)
  name(list_layers[[i]]) <- names[i]
}
)
names(list_layers) <- names

test_layers <- unlist(list_layers)

list <- list(6)
for (i in layers) {
  list[[i]] <- cc_write_reload_raster(i, path)
}


plot(i)
```


Workflow for parallel:
add libraries
check the number of clusters
set up the cluster with the particular number of cores
export the libraries each core needs to run the analysis (basically, parallel or snowfall, sf, lwgeom)
load the file, add a surrogate key to re order stuff if it comes in at a different time.

dummy function to apply st_make_valid to elements of a list, return that element, and automatically start on the next one. I think each element will be put into a list, which could then be re collected using the function collect()


```{r parallel}
library(parallel)
library(snowfall)

dat <- amp_sf[1:500]

# set the benchmark:
system.time(
  dat_valid <- st_make_valid(dat)
)

myfun <- function(dat){
  st_make_valid(dat[1,])
    
  return(mean(dat[,"y"]))
}

mylist <- replicate(100, as.matrix(dat), simplify=FALSE)

ncores <- parallel::detectCores()
ncores # I have 8 on my macbook pro
cl <- parallel::makeCluster(ncores)
doParallel::registerDoParallel(cl)

# Loop over each row in the occurrence table
valid <- foreach(i = 1:length(mylist), .combine = 'rbind', .packages = c('geometry','picante')) %dopar% {
    myfun(mylist[[i]])
}

# Stop the cluster
parallel::stopCluster(cl)
```


