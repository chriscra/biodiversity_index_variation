---
title: "2. Preparing Input Biodiversity Layers"
author: "Christopher Crawford, Princeton University"
output: html_notebook
editor_options: 
  chunk_output_type: console
---
This R Markdown file outlines the process for preparing the input biodiversity layers to go into the indices tested with the `agroEcoTradeoff` prioritization model. Biodiversity datasets were largely informed by those used by Laurance et al. 2014 (details of which can be found here [here](http://www.global-roadmap.org/technical-details/)).

In order, the biodiversity layers produced here are:

- Vertebrate richness layers, including mammals, birds, amphibians, and reptiles
- Plant species richness
- habitat rasters, including biodiversity hotspots, important and endemic bird habitats, WWF global 200 ecoregions, high biodiversity wilderness areas, and frontier forests.

See Appendix S1 for full details. 

# Set up

```{r start-up, eval=TRUE}
## libraries --------------------------------------------------------------------------------
source("scripts/cc_libraries.R")
source("scripts/cc_functions.R")
source("scripts/cc_pathnames.R")
```


```{r other-helpful}
# Other helpful files, partially duplicating what is is "scripts/1_Start.Rmd"
aaeac <- sf::st_crs("+proj=aea +lat_1=20 +lat_2=-23 +lat_0=0 +lon_0=25 +x_0=0 +y_0=0 +ellps=WGS84 +datum=WGS84 +units=m +no_defs") # Africa Albers Equal Area Conic projection.
# could probably also use raster::crs
CRSobj <- CRS("+proj=aea +lat_1=20 +lat_2=-23 +lat_0=0 +lon_0=25 +x_0=0 +y_0=0 +ellps=WGS84 +towgs84=0,0,0,0,0,0,0 +units=m +no_defs") # set CRS object for model runs, noting that this must be a CRS object for sp*, not a crs object

crs_longlat <- sf::st_crs("+proj=longlat +datum=WGS84 +no_defs")

load(file = fp(p_ZA,"parks_roads.rda")) # includes roads (a SpatialLinesDataFrame), pas (SpatialPolygonsDataFrame, a shapefile that includes both national parks and GMAs), and zambia (SpatialPolygonsDataFrame, outline of Zambia)
msk_shp <- readOGR(fp(p_datnew,"msk.shp")) %>% 
  spTransform(CRS("+proj=aea +lat_1=20 +lat_2=-23 +lat_0=0 +lon_0=25 +x_0=0 +y_0=0 +ellps=WGS84 +datum=WGS84 +units=m +no_defs"))
msk_sf <- st_read(fp(p_datnew,"msk.shp")) %>% st_transform(aaeac)
msk_sf_noholes <- smoothr::fill_holes(msk_sf, threshold = units::set_units(10000, km^2)) # a method to fill holes. could also use spatialEco::remove.holes() on sp* type data.
msk_sf_buff <- st_buffer(msk_sf, units::set_units(100, km))

msk_sf_ll <- st_transform(msk_sf, crs_longlat)
msk_sf_ll_noholes <- st_transform(msk_sf_noholes, crs_longlat)
msk_sf_ll_buff <- st_buffer(msk_sf_ll, units::set_units(1, degree))
plot(msk_sf_ll_buff)
plot(msk_sf_ll)
plot(msk_sf_ll_noholes)

msk_sf_ll_4deg_buff <- msk_sf_ll %>% st_buffer(units::set_units(4, degree))

msk <- raster(fp(p_datnew,"msk.tif")) # the actual high resolution msk, created directly from the csv in "bd_new_prep.Rmd"
msk_filled <- msk
msk_filled[is.na(msk_filled)] <- 0 # replace NAs with 0s
plot(msk_filled)


# basemaps ------------------------------------------------------------------------------------
load(fp(p_basemaps,"basemaps.RData"), verbose = TRUE)
```


```{r epsg-projections}
epsg <- rgdal::make_EPSG()
names(epsg)
epsg %>% filter(str_detect(note, regex("Lambert", ignore_case = TRUE))) 
epsg %>% filter(code == 102022)

aaeac <- st_crs("+proj=aea +lat_1=20 +lat_2=-23 +lat_0=0 +lon_0=25 +x_0=0 +y_0=0 +ellps=WGS84 +datum=WGS84 +units=m +no_defs") # Africa Albers Equal Area Conic projection
crs_saaeac <- st_crs("+proj=aea +lat_1=-5 +lat_2=-42 +lat_0=-32 +lon_0=-60 +x_0=0 +y_0=0 +ellps=aust_SA +units=m +no_defs")  # South 
crs_salcc <- st_crs("+proj=lcc +lat_1=-5 +lat_2=-42 +lat_0=-32 +lon_0=-60 +x_0=0 +y_0=0 +ellps=aust_SA +units=m +no_defs") # South America Lambert Conformal Conic
crs_naaeac <- st_crs("+proj=aea +lat_1=20 +lat_2=60 +lat_0=40 +lon_0=-96 +x_0=0 +y_0=0 +datum=NAD83 +units=m +no_defs")
crs_robinson <- st_crs("+proj=robin +lon_0=0 +x_0=0 +y_0=0 +datum=WGS84 +units=m +no_def")
crs_miller <- st_crs("+proj=mill +lat_0=0 +lon_0=0 +x_0=0 +y_0=0 +R_A +datum=WGS84 +units=m +no_defs")
crs_brazil <- epsg %>% filter(code == 5530) # brazil polygonic
crs_mollweide <- st_crs("+proj=moll +lon_0=0 +x_0=0 +y_0=0")
crs_us <- CRS(filter(epsg, code == 2163)$prj4) # US National Atlas Equal Area: EPSG - 2163
crs_mercator <- st_crs("+proj=merc +a=6378137 +b=6378137 +lat_ts=0.0 +lon_0=0.0 +x_0=0.0 +y_0=0 +k=1.0 +units=m +nadgrids=@null +wktext  +no_defs")

polyconic <- st_crs("+proj=poly +lat_0=0 +lon_0=0 +x_0=0 +y_0=0 +a=6371000 +b=6371000 +units=m +no_defs")

crs_moll_americas <- st_crs("+proj=moll +lon_0=-90 +x_0=0 +y_0=0")

americas %>% 
  st_transform(crs_moll_americas) %>% 
  st_geometry %T>% plot()

equal_earth <- "+proj=eqearth"
str_view(epsg$note, "equal")

```


```{r world-basemaps}
save(world, africa, americas, zambia_sf, usa, north_america,  # basemaps
     file = fp(p_basemaps,"basemaps.RData"))
load(fp(p_basemaps,"basemaps.RData"), verbose = TRUE)


# ------------------------------------------------------
# maps
# ------------------------------------------------------
install.packages("maps")
library(maps)
world_map <- st_as_sf(map("world", plot = FALSE, fill = TRUE))
states <- st_as_sf(map("state", plot = FALSE, fill = TRUE))
plot(world_map)
st_bbox(world_map)
plot(states)

# ------------------------------------------------------
# maptools and wrld_simpl
# ------------------------------------------------------
library(maptools)
data(wrld_simpl)
class(wrld_simpl)
plot(wrld_simpl)
bbox(wrld_simpl)
plot(spTransform(wrld_simpl, CRS=("+proj=moll +lon_0=0 +x_0=0 +y_0=0")))
plot(wrld_simpl)
names(wrld_simpl)
wrld_simpl$SUBREGION
plot(spTransform(wrld_simpl, CRS=aaeac))
# question for Lyndon - why the heck does this happen? Is there anything that I can do to prevent it? Adding vertices does not seem to help. 

# ------------------------------------------------------
# rnaturalearth and rnaturalearthdata
# ------------------------------------------------------
library(rnaturalearth)
library(rnaturalearthdata)
help(rnaturalearth)
world <- ne_countries(scale = "medium", returnclass = "sf") # can set returnclass to sf or sp.
usa <- ne_countries(scale = "medium", country = "United States of America", returnclass = "sf") # can set returnclass to sf or sp.
north_america <- ne_countries(scale = "medium", continent = "North America", returnclass = "sf") # can set returnclass to sf or sp.

plot(st_transform(north_america, crs_us)$geometry)
plot(st_transform(usa, crs_us)$geometry)

plot(world$geometry)
names(world)
st_bbox(world)
plot(world["continent"])
plot(filter(world, name == "Zambia")) # plotting just Zambia

# graticules
box <- ne_download(scale = 'medium', type = "wgs84_bounding_box", 
                          category = "physical", 
                          #destdir = tempdir(), 
                          load = TRUE, returnclass = "sf")

# ------------------------------------------------------
# americas (world)
# ------------------------------------------------------
levels(as.factor(world$continent))
americas <- world %>%
  filter(continent %in% c("North America", "South America")) # select countries in Africa

plot(st_transform(americas$geometry, crs_moll_americas), border = "red")#, add = T)

americas_u <- st_union(americas)

plot(americas$geometry, add = T)
plot(americas_u, border = "blue")

americas_igh <- world %>%
  filter(continent == c("North America", "South America")) %>% # select countries in Africa
  st_transform("+proj=igh") # transform to Albers Equal Area projection

# ------------------------------------------------------
# africa (world)
# ------------------------------------------------------
africa <- world %>%
  filter(continent == "Africa") # select countries in Africa
plot(st_geometry(africa))
plot(africa$geometry)
plot(st_transform(africa$geometry, aaeac), border = "red", add = T)
plot(msk_shp)

africa_u <- st_union(africa)

plot(africa$geometry, add = T)
plot(africa_u, border = "blue")

plot(st_transform(africa_u, aaeac), border = "blue")
plot(msk_shp, add = T, col = "red")

africa_aaeac <- world %>%
  filter(continent == "Africa") %>% # select countries in Africa
  st_transform(aaeac) # transform to Albers Equal Area projection

plot(st_geometry(africa_aaeac))

africa1 <- st_read(fp(p_datnew, "Africa.shp")) %>%
  st_transform(aaeac)
plot(africa1$geometry, border = "blue")
plot(africa_aaeac$geometry, add = T, border = "red")

plot(st_transform(africa_u, aaeac), border = "blue")

# ------------------------------------------------------
# zambia
# ------------------------------------------------------
zambia_sf <- world %>%
  filter(name == "Zambia") # just Zambia

plot(zambia_sf$geometry)
st_crs(zambia_sf)

# ------------------------------------------------------
# china
# ------------------------------------------------------
china_sf <- world %>%
  filter(name == "China") # 
plot(china_sf$geometry)
plot(china_sf$geometry)
st_crs(china_sf)

# ------------------------------------------------------
# Asia
# ------------------------------------------------------
asia_sf <- world %>%
  filter(continent == "Asia")

plot(asia_sf$geometry)


# ------------------------------------------------------
# raster:getData()
# ------------------------------------------------------
# getData('ISO3') # ZMB is the Zambia country code
Z_latlong <- getData('GADM', country='ZMB', level=0, path='') # load in Zambia from the GADM database
Z <- spTransform(Z_latlong, crs(msk_shp)) # reprojecting to aea
plot(msk_shp)
plot(Z, add = T, col= "red")


```

```{r IUCN-RedList-assessments}
redlist_assessments_lc <- read_csv("/Users/christophercrawford/Google Drive/_Projects/data/Bd/IUCN_RedList/RedList_LC_Plants+Animals_allregions/assessments.csv")
redlist_assessments_nonlc <- read_csv("/Users/christophercrawford/Google Drive/_Projects/data/Bd/IUCN_RedList/RedList_NonLC_Plants+Animals_allregions/assessments.csv")
redlist_assessments <- rbind(redlist_assessments_lc, redlist_assessments_nonlc)

redlist_summary_lc <- read_csv("/Users/christophercrawford/Google Drive/_Projects/data/Bd/IUCN_RedList/RedList_LC_Plants+Animals_allregions/simple_summary.csv")
redlist_summary_nonlc <- read_csv("/Users/christophercrawford/Google Drive/_Projects/data/Bd/IUCN_RedList/RedList_NonLC_Plants+Animals_allregions/simple_summary.csv")
redlist_summary <- rbind(redlist_summary_lc, redlist_summary_nonlc)

names(redlist_assessments)
names(redlist_summary)
View(redlist_assessments)
View(redlist_summary)


# What's the key?
redlist_summary %>% count(scientificName) %>% filter(n > 1) # two entries for Crocidura canariensis
redlist_assessments %>% count(scientificName) %>% filter(n > 1) # two entries for Crocidura canariensis

redlist_summary %>% count(internalTaxonId) %>% filter(n > 1) # two entries for 5560 (which is Crocidura canariensis, the Canary shrew)
redlist_assessments %>% count(internalTaxonId) %>% filter(n > 1) # same as above. 


# join the two tables
redlist_summary_w_assessments <- 
  redlist_summary %>% # by = c("key x" = "key y"), or by = "key"
  left_join(redlist_assessments, by = "scientificName")

names(redlist_summary_w_assessments)

select(filter(redlist_summary_w_assessments, assessmentId.x!=assessmentId.y), assessmentId.x, assessmentId.y, scientificName)
redlist_summary_w_assessments %>% count(internalTaxonId.y) %>% filter(n > 1) # same as above. 

all(as.character(bird_table_join1[['SCINAME']]) == as.character(bird_table_join1[['ScientificName']])) # this works because I've changed the factors to characters 

# filter out birds, and then filter out non-marine systems
as_tibble(redlist_summary_w_assessments)
summary(as.factor(redlist_summary_w_assessments$className))
redlist_aves <- filter(redlist_summary_w_assessments, className == "AVES")
redlist_aves %>% count(internalTaxonId.x) %>% filter(n > 1) # all unique
glimpse(redlist_aves)

summary(as.factor(redlist_aves$systems))
systems <- unique(redlist_aves$systems)
redlist_aves %>% filter(systems == "Marine") %>% 

systems <- systems[1:4, , -8, ]
redlist_terr <- filter(redlist_assessments, systems %in% c())
```


# 1. Vertebrate Species Richness Rasters

Data sources: 
Mammals, Reptiles, Amphibians: IUCN Redlist
Birds: BirdLife International
Reptiles: GARD

General Steps:
- making the geometries valid
- calculating variables required to make richness rasters for various species richness metrics, including 1) 
- running species range maps through a custom function (`cc_make_raster8()`) to filter, crop, and produce rasters for a range of richness metrics.

`cc_make_raster8()` was designed to: 
1. filter species to the appropriate groups by default (i.e. presence = extant species only, origin = native and reintroduced species only, terrestrial species only, seasonality = "Resident", "Breeding", and "Non-breeding Season", and excluding Extinct or Extinct in the Wild species ("EX", "EW")
2. allow for selection of 1) all species, 2) small-ranged species, 3) threatened species, or 4) small-ranged or threatened species
3. reproject geometries, and finally
4. produce rasters for 8 different richness metrics: 1) all sp. richness, 2) endemism richness (based on the inverse of the global range), 3) Zambian endemism richness (based on the inverse of the Zambian range), 4) threatened species richness, 5) weighted threatened species richness (following Damania & Wheeler 2015), 6) small-ranged species richness (based on the global range median), 7) Zambian small-ranged species richness (based on the Zambian range median), and 8) small-ranged or threatened species richness.


## Mammals  

```{r mam-start}
# Load prepped rdata  ----------------------------------------------------------


# ----------------------------------
mam_sf <- st_read(fp(p_mam,"MAMMALS.shp"))
# Faster than reading in shapefiles as spatial* objects using readOGR(), and loads the file in as an sf object. readOGR (for shapefiles, points, and lines) produces Spatial* objects, and sf produces "simple feasture collections" which in this case is geometry type multipolygon. Using the function read_sf() is basically the same, but it doesn't provide the output.

glimpse(mam_sf) # to examine the file. similar to: 
str(mam_sf)
as_tibble(mam_sf) # converting to a tibble to view more easily. This is similar to head(), but a little easier to read.
head(mam_sf)

class(mam_sf) # basic exploring the data
names(mam_sf) # the variables
length(mam_sf$category) #how many records? 13,086
unique(mam_sf$island)

st_geometry(mam_sf)

# how many records have origins or seasonal codes outside the ones I use?
mam_valid # 13086
nrow(mam_valid) # 13086

mam_valid %>% filter(presence == 1) %>% nrow() # 12080, only records with Code 1 (Extant) 
mam_valid %>% filter(origin %in% c(1, 2)) %>% nrow() # 12778, only native species (Code 1) and reintroduced (Code 2)
mam_valid %>% filter(seasonal %in% c(1, 2, 3)) %>% nrow() # 13048, selecting "Resident" (1), "Breeding" (2), and "Non-breeding Season" (3) ranges. Other categories include: Passage (4), and Seasonal Occurrence Uncertain (5).

```


```{r mam-valid-parallel}
# Fix invalid geometries, using custom cc_make_valid() function, running in parallel. 

tic("full script")
library(sf)
library(lwgeom)
library(dplyr)
library(tictoc)
library(parallel)
library(pryr)

tic("load data")
dat <- st_read(dsn = "/Users/christophercrawford/Google Drive/_Projects/data/Bd/IUCN_RedList/MAMMALS/MAMMALS.shp")
toc(log = TRUE)

tic("add row number")
dat <- dat %>%
  mutate(key = row_number()) %>%
  select(key, everything())
toc(log = TRUE)

print("dat object size")
object_size(dat)

# see cc_functions.R for cc_make_valid()
tic("run in parallel")
dat <- mclapply(seq(1, nrow(dat), by = 100), function(i) cc_make_valid(dat[i:(i+99), ]), mc.cores = 8)
toc(log = TRUE) #1512 seconds (25 minutes)

print("dat object size par list")
object_size(dat)
print("length of dat par list")
length(dat)
dat[[1]]

tic("recombine")
dat <- do.call("rbind", dat)
toc(log = TRUE)

print("object size post recombination")
object_size(dat)
toc(log = TRUE)

nrow(dat)

# drop NA geometries:
nrow(dat)
dat <- filter(dat, !is.na(id_no))
nrow(dat)

mam_valid <- dat
tic("write dat_par file")
save(mam_valid, file = "/Users/christophercrawford/Google Drive/_Projects/Zambia/agroEcoTradeoff/external/data_new/1_IUCN_dev/mam_valid_par.RData")
toc(log = TRUE)

toc(log = TRUE)


tic.log(format = TRUE)
```


```{r mam-prep}
# ------------------------------------------------------------
# code to prepare the sf file for the creation of 1) small-ranged species richness, 2) weighted endemism richness, and 3) threat-weighted species richness. This involves calculating polygon areas, summing to determine the total range area (excluding parts of the range we aren't considering), ordering the species by range size and giving the rank order (normalized to between 0-1). This also involves calculating the inverse of the global range size and the threat category weight.
# ------------------------------------------------------------

# Mammals -------
load(file = "/Users/christophercrawford/Google Drive/_Projects/Zambia/agroEcoTradeoff/external/data_new/1_IUCN_dev/mam_valid_par.RData", verbose = TRUE) # includes mam_valid (1.62 gb), which was made in the chunk "mam-valid-parallel". This is the one I used going forward.


#####
# add a new column for area -------------
tic("add area") ### note that I had to change "geometry" to "Shape" for birds
mam_valid <- mam_valid %>%
  mutate(., area_km2 = st_area(.["geometry"]) %>% units::set_units(km^2)) # area, caluclated from polygons in long lat projection
toc() # 62.259 sec for mam_valid


# ----------------------------------------------------------
# subset to only those ranges used in analysis, including removing the Extinct or Extinct in the Wild species ("EW", "EX")
# then, group by species, and calculate the sum of the various polygons, i.e. the total range area for each species. 
mam_valid_summary <- mam_valid %>%   # assign dat to a new object, to then be modified
  st_drop_geometry() %>%
  filter(presence == 1) %>%   # only records with Code 1 (Extant)
  filter(origin %in% c(1, 2)) %>%     # only native species (Code 1) and reintroduced (Code 2)
  filter(seasonal %in% c(1, 2, 3)) %>%   # selecting "Resident" (1), "Breeding" (2), and "Non-breeding Season" (3) ranges. Other categories include: Passage (4), and Seasonal Occurrence Uncertain (5).
  filter(marine == "False") %>%   # removing all marine species
  filter(!category %in% c("EW", "EX")) %>% # remove Extinct or Extinct in the Wild species ("EW", "EX")
  group_by(binomial) %>%
  dplyr::summarize(total_range_area = sum(area_km2, na.rm = TRUE), n_polygons = n())

nrow(mam_valid_summary) # 5527 species, odd number of rows (5529 minus 2 EX or EW species: Elaphurus davidianus, and Melomys rubicola)

  
### what are the summary statistics? What is the median, 1st quartile, etc?
quantile(mam_valid_summary$total_range_area, probs = c(0.25, 0.5, 0.75)) 
# 1st quartile: 17449.38 km2 (old pre dropping EW EX: 17400.28 km2)
# 2nd quartile: 170,594.24 km2 (old pre dropping EW EX: 170568.45 km2
# 3rd quartile: 1,089,500.88 km2 (old pre dropping EW EX: 1088892.35 km2

# ------------------------------------------------------------
# add column to put the species in order of range size, counting upwards from the smallest range, and add a second column dividing by the total number of species
mam_valid_summary <- mam_valid_summary %>%
  arrange(total_range_area) %>%
  mutate(range_size_quantile = row_number()/max(row_number()))
  
nrow(mam_valid_summary) # 5527, odd, so do <, not <=
tail(mam_valid_summary)

mam_valid_summary %>% 
  filter(range_size_quantile < 0.5) %>% # do <= if nrow is even, and < if nrow is odd.
  arrange(desc(total_range_area)) %>%
  nrow() # 2763
nrow(mam_valid_summary)/2

# ------------------------------------------------------------
# join total range area back to original sf object
names(mam_valid_summary)
mam_valid <- mam_valid %>% # by = c("key x" = "key y")
  left_join(mam_valid_summary, by = c("binomial" = "binomial"))

# ------------------------------------------------------------
# calculate inverse_range_glob & 
# threat status weight (based on Damania & Wheeler 2015, Veach et al. 2017):
# ---- weights, from Mooers et al. 2008, following Isaacs et al. 2007: 
# ---- Critically endangered (CR) = 1; Endangered (EN) = 1/2; Vulnerable (VU) = 1/4; Near Threatened (NT) = 1/8; Least Concern (LC) = 1/16. Data deficient (DD) = NA.
# ---- Veach et al 2017 use the following weights: Critically endangered = 8; Endangered = 6; Vulnerable = 4; Near Threatened = 2; Least Concern = 1; Data Deficient = 4 (Pouzols et al., 2014)

mam_valid <- mam_valid %>% 
  mutate(inverse_range_glob = 1/total_range_area) %>% 
  mutate(threat_weight = 
           ifelse(category == "CR", 1,    # if CR then 1, if not, then ->
           ifelse(category == "EN", 1/2,  # if EN then 1/2, if not, then ->
           ifelse(category == "VU", 1/4,  # if VU then 1/4, if not, then ->
           ifelse(category == "NT", 1/8,  # if NT then 1/8, if not, then ->
           ifelse(category == "LC", 1/16, # if LC then 1/16, if not, then ->
           ifelse(category == "DD", 1/4, NA))))))) # if DD then 1/4 (a middle ground, conservative estimate). If not, then -> NA. This means that EW, EX are all set to NA.

# testing to make sure things look good. 
names(mam_valid)
mam_valid %>% 
  st_drop_geometry() %>%
  .[1:20, c(3, 23, 31:33, 35:36)]

### Now you can use it to filter to only "small-ranged species," those species with total range areas of less than the median (or the 1st quartile, whatever method you decide)

mam_valid %>% 
  filter(range_size_quantile < 0.5) %>% # do <= if nrow is even, and < if nrow is odd.
  arrange(desc(total_range_area)) %>%
  nrow()

nrow(mam_valid)
object_size(mam_valid)


# ------------------------------------------------------------
# save the file
save(mam_valid, file = "/Users/christophercrawford/Google Drive/_Projects/Zambia/agroEcoTradeoff/external/data_new/1_IUCN_dev/mam_valid_prepped.RData") # contains mam_valid (1.62 gb), but prepped for use in small species, etc. This entailed joining the table of red list categories, changing some of the column names, adding a column for area, totalling area for parts of the range we're using, and adding a column ranking the range size to allow things to be subset for small ranged species analyses.


#####
# >>>> now, it's ready to be put through cc_make_raster
#####
```


```{r mam-clip}
# load prepped mam_valid
load("/Users/christophercrawford/Google Drive/_Projects/Zambia/agroEcoTradeoff/external/data_new/1_IUCN_dev/mam_valid_prepped.RData", verbose = TRUE)

# --------------------------------------------------------
# clip to Zambia
mam_zambia <- mam_valid %>%
  st_intersection(., st_union(msk_sf_ll_noholes)) %>%
  st_collection_extract(., "POLYGON") # extract only polygons


# -------------------------------------------------------------
# calculate area of clipped polygons in Zambia (calculated in long lat projection)
mam_zambia <- mam_zambia %>%
  mutate(area_zambia_km2 = st_area(.["geometry"]) %>% units::set_units(km^2)) 


# -------------------------------------------------------------
# subset to only those ranges used in analysis, then 
# group by species and sum across polygons to get species' total range area in Zambia

mam_zambia_summary <- mam_zambia %>%   # assign dat to a new object, to then be modified
  st_drop_geometry() %>%
  filter(presence == 1) %>%   # only records with Code 1 (Extant)
  filter(origin %in% c(1, 2)) %>%     # only native species (Code 1) and reintroduced (Code 2)
  filter(seasonal %in% c(1, 2, 3)) %>%   # selecting "Resident" (1), "Breeding" (2), and "Non-breeding Season" (3) ranges. Other categories include: Passage (4), and Seasonal Occurrence Uncertain (5).
  filter(marine == "False") %>%   # removing all marine species, except for bird species
  filter(!category %in% c("EW", "EX")) %>% # remove Extinct or Extinct in the Wild species ("EW", "EX")
  group_by(binomial) %>%
  dplyr::summarize(total_zambia_range_area = sum(area_zambia_km2, na.rm = TRUE), n_polygons = n())

nrow(mam_zambia_summary) # 252 species, even number of rows

  
# what are the summary statistics? What is the median, 1st quartile, etc?
quantile(mam_zambia_summary$total_zambia_range_area, probs = c(0.25, 0.5, 0.75)) 
# update for each taxonomic group
# 1st quartile: 35,382.12 km2 (global: 17449.38 km2)
# 2nd quartile: 360,085.19 km2 (global: 170,594.24 km2)
# 3rd quartile: 642,749.46 km2 (global: 1,089,500.88 km2)


# ------------------------------------------------------------
# add column to put the species in order of range size, 
# counting upwards from the smallest range, and add a second column 
# dividing by the total number of species
mam_zambia_summary <- mam_zambia_summary %>%
  arrange(total_zambia_range_area) %>%
  mutate(range_size_quantile_zambia = row_number()/max(row_number()))
  
nrow(mam_zambia_summary) # 252
tail(mam_zambia_summary)

median(mam_zambia_summary$total_zambia_range_area)

mam_zambia_summary %>% 
  filter(range_size_quantile_zambia <= 0.5) %>% # do <= if nrow is even, and < if nrow is odd.
  arrange(desc(total_zambia_range_area)) #%>%
  nrow() # 125
nrow(mam_zambia_summary)/2

# ------------------------------------------------------------
# join total Zambia range area back to clipped sf object
names(mam_zambia_summary)
mam_zambia <- mam_zambia %>% # by = c("key x" = "key y")
  left_join(mam_zambia_summary, by = c("binomial" = "binomial"))



# -------------------------------------------------------------
# calculate the inverse of the range in Zambia
mam_zambia <- mam_zambia %>%
  mutate(inverse_range_zam = 1/total_zambia_range_area) 


# -------------------------------------------------------------
save(mam_zambia, file = "/Users/christophercrawford/Google Drive/_Projects/Zambia/agroEcoTradeoff/external/data_new/1_IUCN_dev/mam_zambia.RData") # includes mam_zambia, which has had area added, been prepped, and then clipped to zambia

```


Endemism richness (rarity-weighted species richness), in which each species is given a weight based on how much of its total range is contained within a particular cell. These values are then summed, so that species with a greater portion of their range in that cell contribute to the richness value. 
Steps:

1. For each species, calculate 1/total range area. (using `mutate()` to create a new column in the new summed file, `mam_terr_all_area_sum`). Then, multiply this by the area of the grid cell. 1 km2 in this base case, but also create a column for 110*110 = 12,100 km2. 
2. Relate this back to mam_sf, so that each geometry has the associated value for each species. Check by recalculating the sum using the summarize function on this new rarity value (it should be one).
3. Run the `fasterize()` function, using the `field` argument to identify the column of values to use as the polygon value. This should be the 1/range value. Then, set the `fun` argument to "sum," so that each cell is given a value of the sum of all polygon values (1/range) for all the species that occur in that cell.

```{r endemism_richness_tester}
# load in the clipped polygon file
mam_zambia
mam_test <- mam_zambia

# there are no mammal, bird, reptile, or amphibian "EW" or "EX" species in Zambia
mam_zambia %>%
  filter(., !category %in% c("EW", "EX")) %>%
  nrow()

# Data deficient species: 
# 20 mammals: Mus neavei, Plerotes anchietae, Lemniscomys roseveari, Scotoecus albofuscus     Lophuromys machangui, Fukomys vandewoestijneae, Fukomys vandewoestijneae, Graphiurus monardi, Graphiurus angolensis, Pipistrellus grandidieri, Rhinolophus sakejiensis  Nycteris major           Epomophorus anselli      Crocidura pitmani        Paraxerus lucifer, Laephotis angolensis     Neoromicia melckorum     Elephantulus fuscus      Tadarida ventralis       Neoromicia melckorum
# 2 birds: Macronyx grimwoodi Pogoniulus makawai
# 2 ampbibians: Hemisus wittei       Hemisus barotseensis
# 2 reptiles: Zygaspis kafuensis, Trachylepis bayonii

nrow(mam_valid_summary) # 5527 mammal species globally (odd)
nrow(mam_zambia_summary) # 252 mammal species in Zambia (even)

mam_list_test <- cc_make_raster8(input_sf = mam_zambia, 
                                  run_clip = FALSE, run_extract = FALSE,
                                  clip_area = msk_sf_ll_noholes,
                                  odd_n_global = TRUE, odd_n_zam = FALSE)
# --------------------------------------------------------------------
# first, filter to just the ranges we'll include in our analysis
mam_test_all <- mam_zambia %>%
  filter(presence == 1,
         origin %in% c(1, 2), 
         seasonal %in% c(1, 2, 3),
         marine == "False", 
         !category %in% c("EW", "EX"))

# --------------------------------------------------------------------
# fasterize based on the inverse_range column -------------
# testers:
mam_test_all_richness <- mam_test_all %>%
  st_transform(aaeac) %>%
  fasterize(., raster = msk_filled, field = NULL, fun = 'sum')

mam_test_endemism_richness <- mam_test_all %>%
  st_transform(aaeac) %>%
  fasterize(., raster = msk_filled, field = 'inverse_range_glob', fun = 'sum')

mam_test_endemism_zam_richness <- mam_test_all %>%
  st_transform(aaeac) %>%
  fasterize(., raster = msk_filled, field = 'inverse_range_zam', fun = 'sum') 

mam_test_threat_richness <- mam_test_all %>% 
  filter(category %in% c("CR", "EN", "VU")) %>% 
  st_transform(aaeac) %>%
  fasterize(., raster = msk_filled, field = NULL, fun = 'sum')

mam_test_threat_weighted_richness <- mam_test_all %>%
  st_transform(aaeac) %>%
  fasterize(., raster = msk_filled, field = 'threat_weight', fun = 'sum')

mam_test_small_richness <- mam_test_all %>% 
  filter(range_size_quantile <= 0.5) %>%
  st_transform(aaeac) %>%
  fasterize(., raster = msk_filled, field = NULL, fun = 'sum')

mam_test_small_zam_richness <- mam_test_all %>% 
  filter(range_size_quantile_zambia <= 0.5) %>%
  st_transform(aaeac) %>%
  fasterize(., raster = msk_filled, field = NULL, fun = 'sum')
  
mam_test_small_threat_richness <- mam_test_all %>% 
  filter(category %in% c("CR", "EN", "VU") | range_size_quantile < 0.5) %>%
  st_transform(aaeac) %>%
  fasterize(., raster = msk_filled, field = NULL, fun = 'sum')

plot(mam_test_endemism_richness)
plot(mam_test_endemism_zam_richness)
plot(mam_test_threat_richness)
plot(mam_test_threat_weighted_richness)
plot(mam_test_small_richness)
plot(mam_test_small_zam_richness)
plot(mam_test_small_threat_richness)
  
plot(mam_test_glob_r)
plot(mam_test_zam_r, zlim = c(0.0,0.005))
hist(mam_test_zam_r)
plot(normalize(log(mam_test_zam_r)))
quantile(mam_test_zam_r)

plot(bd_inputs_brick$m3_vert_small)
plot(bd_inputs_brick[[1:4]], zlim = c(0,1))
plot(normalize(log(mam_test_glob_r)))
plot(normalize(mam_test_glob_r))


hist(bd_inputs_brick$m3_vert_small)




# -------------------------------------------------------------------
```



```{r mam-list-final}
nrow(mam_valid_summary) # 5527 mammal species globally (odd)
nrow(mam_zambia_summary) # 252 mammal species in Zambia (even)

mam_list <- cc_make_raster8(input_sf = mam_zambia, 
                             run_clip = FALSE, run_extract = FALSE,
                             clip_area = msk_sf_ll_noholes,
                             odd_n_global = TRUE, odd_n_zam = FALSE)

names(mam_list)
# this includes a bunch of layers:
# "clipped_sf", "filtered_all", "filtered_threat", "filtered_small", "filtered_small_zam", "filtered_threat_small", "reprojected_all", "reprojected_threat", "reprojected_small", "reprojected_small_zam", "reprojected_threat_small", "brick"
# "brick" includes 8 rasters:
# "all_richness", "endemism_richness", "endemism_zam_richness", "threat_richness", "threat_weighted_richness", "small_richness", "small_zam_richness", "small_threat_richness"

names(mam_list$brick)

dev.off()
par(mfrow = c(2, 2))
# eight key rasters:
levelplot(mam_list$brick[[1:4]], col.regions = terrain.colors(50, rev = TRUE), main = "title") # beware, this plots only with one scale. 
mam_list$brick
object_size(mam_list)

plot(mam_list$brick$all_richness)
plot(mam_list$brick$endemism_richness)
plot(mam_list$brick$endemism_zam_richness)
plot(mam_list$brick$threat_richness)
plot(mam_list$brick$threat_weighted_richness)
plot(mam_list$brick$small_richness)
plot(mam_list$brick$small_zam_richness)
plot(mam_list$brick$small_threat_richness)


save(mam_list, file = "/Users/christophercrawford/Google Drive/_Projects/Zambia/agroEcoTradeoff/external/data_new/1_IUCN_dev/mam_list.RData")

mam_brick <- writeRaster(mam_list$brick, filename = fp(p_iucn_dev, "mam_brick.tif"), overwrite = TRUE)
names(mam_brick) <- names(mam_list$brick)

```



## Birds  

*Notes on sorting.* Bird species range maps are slightly different, in that they have a seasonal component to them. 
Jenkins et al. 2013 only uses breeding ranges for these birds, and separates out the terrestrial birds.
Jetz et al. 2007 only use breeding ranges as well (I'm fairly certain). 

Filtering involved  following steps:

1. First, I filter based on "presence." selecting only records with code 1 (Extant). Other unused codes are: 2. Probably Extant (discontinued, ambiguous), 3. Possibly Extant, 4. Possibly Extinct, 5. Extinct, 6. Presence Uncertain.
2. Next, I filter by origin, selecting only native species (Code: 1) and reintroduced species (Code: 2). Other unused codes are: 3. Introduced, 4. Vagrant, 5. Origin Uncertain, 6. Assisted Colonisation.
3. Then, I filtered species based on the seasonality of their ranges. I select only "Resident" (1), "Breeding" (2), and "Non-breeding Season" (3) ranges. Other categories that I did not include were: "Passage" (4), and "Seasonal Occurrence Uncertain" (5).
4. Then, I selected only threatened species, CR (Critically Endangerd), EN (Endangered), and VU (Vulnerable), (i.e. removing LC [Least Concern], EX [Extinct], EW [Extinct in the Wild], CR (PE) [Critically Endangered, Potentially Extinct], CR (PEW) [Critically Endangered, Potentially Extinct in the Wild, e.g. Spix's Macaw], NT [Near Threatened], and DD [Data Deficient]). The PE and PEW species are mostly considered gone anyways. 
5. Having successfully narrowed down the sample to just the species and polygons I'm interested in, I then reproject the shapefiles to the Albers Equal Area projection to match the datasets being used in the @Estes2016a tradeoff model. 
6. Finally, I used the function `fasterize {fasterize}` to produce a raster map of threatened species richness.

After this, I used the function raster::aggregate to produce species richness maps at coarser resolutions (10 km x 10 km, and 110 km x 110 km), and masked the rasters to the size of Zambia.


```{r birds-start}
# Load prepped rdata (bird_threat_sf,bird_threat_made_valid, bird_terr_threat, bird_america_threat, bird_africa_threat, bird_zambia_threat) ----------------------------------------------------------
load(fp(p_iucn_dev,"bird_files.RData"), verbose = TRUE) #(bird_threat_sf,bird_threat_made_valid, bird_terr_threat, bird_america_threat, bird_africa_threat, bird_zambia_threat)

load(file = "/Users/christophercrawford/Google Drive/_Projects/Zambia/agroEcoTradeoff/external/data_new/1_IUCN_dev/bird_valid.RData", verbose = TRUE) # this has "bird_valid", an sf object made by splitting bird_sf into three files, and running cc_make_valid on each in parallel, the using rbind to put them back together. it's 6.9 gb.

load(file = "/Users/christophercrawford/Google Drive/_Projects/Zambia/agroEcoTradeoff/external/data_new/1_IUCN_dev/bird_valid_prepped.RData", verbose = TRUE) # contains bird_valid (7.22 gb), but prepped for use in small species, etc. This entailed joining the table of red list categories, changing some of the column names, adding a column for area, totalling area for parts of the range we're using, and adding a column ranking the range size to allow things to be subset for small ranged species analyses.

load(file = "/Users/christophercrawford/Google Drive/_Projects/Zambia/agroEcoTradeoff/external/data_new/1_IUCN_dev/bird_zambia.RData", verbose = TRUE) # includes bird_zambia, which has had area added, been prepped, and then clipped to zambia

# ----------------------------------

st_layers(fp(p_bird,"BOTW/BOTW.gdb")) # what layers are there in the BOTW file geodatabase? 

bird_sf <- st_read(dsn = fp(p_bird,"BOTW/BOTW.gdb"), layer = "All_Species")
as_tibble(bird_sf)

bird_red_list <- st_read(dsn = fp(p_bird,"BOTW/BOTW.gdb"), layer = "RedList_2018")
as_tibble(bird_red_list)
levels(bird_red_list$Family)




# bird_table
bird_table <- st_drop_geometry(bird_sf)
object_size(bird_table)
class(bird_table)
#write.csv(bird_table, file = fp(p_iucn_dev, "bird_table.csv"))


levels(bird_red_list$RedListCategory)
summary(bird_red_list$RedListCategory)
filter(bird_red_list, RedListCategory == "CR (PE)")[1:21,6:7]
filter(bird_red_list, RedListCategory %in% c("CR", "EN", "VU"))[,6:7] # 1470 species.

nrow(bird_sf)
reintroduced <- filter(bird_sf, ORIGIN == 2)
table(bird_sf$ORIGIN)

# ----------------------------------------
# how many records have origins or seasonal codes outside the ones I use?
nrow(bird_valid) # 17463
object_size(bird_valid) # 7.22 gb

bird_valid %>% st_drop_geometry() %>% filter(presence == 1) %>% nrow() # 16038, only records with Code 1 (Extant) 
bird_valid %>% st_drop_geometry() %>% filter(origin %in% c(1, 2)) %>% nrow() # 17118, only native species (Code 1) and reintroduced (Code 2).  There are 326 introduced polygons (Code 3), zero vagrant polygons (Code 4), 19 origin uncertaint (Code 5), and Zero assisted colonization polygons.
bird_valid %>% st_drop_geometry() %>% filter(seasonal %in% c(1, 2, 3)) %>% nrow() # 16645, selecting "Resident" (1), "Breeding" (2), and "Non-breeding Season" (3) ranges. Other categories include: Passage (4), and Seasonal Occurrence Uncertain (5).
# there are 740 passage range polygons
# there are 78 seasonal occurrence uncertain range polygons

```


```{r birds-valid-parallel}
# Fix invalid geometries, using custom cc_make_valid() function, running in parallel. 
# Given the large size of the bird file, this had to be broken into three pieces to run successfully. 

library(sf)
library(lwgeom)
library(dplyr)
library(tidyverse)
library(pryr)
library(parallel)
library(tictoc)

bird_sf <- st_read(dsn = "/Users/christophercrawford/Google Drive/_Projects/data/Bd/IUCN_RedList/Birds/BOTW/BOTW.gdb", layer = "All_Species")

bird_sf <- bird_sf %>%
  mutate(key = row_number()) %>%
  select(key, everything())

nrow(bird_sf)
# dat
dat <- bird_sf[1:300, ]
dat1 <- bird_valid[1:7800, ]
dat2 <- bird_valid[7801:14500, ]
dat3 <- bird_valid[14501:17463, ]

object_size(dat1)
object_size(dat2)
object_size(dat3)


# see cc_functions.R for cc_make_valid()
tic("birds parallel")
dat_par <- mclapply(seq(nrow(dat)), function(i) cc_make_valid(dat[i, ]), mc.cores = parallel::detectCores()-1)
toc(log = TRUE)
# time for 300 rows: 198.865 seconds

dat_final <- do.call("rbind", dat_par)

tic("birds parallel 1")
dat1_par <- mclapply(seq(nrow(dat1)), function(i) cc_make_valid(dat1[i, ]), mc.cores = parallel::detectCores())
dat1_final <- do.call("rbind", dat1_par)
toc(log = TRUE) # time elapsed: 3185.081 seconds (53 minutes) for the first 6000 rows, 1.7 gb

tic("birds parallel 2")
dat2_par <- mclapply(seq(nrow(dat2)), function(i) cc_make_valid(dat2[i, ]), mc.cores = parallel::detectCores())
dat2_final <- do.call("rbind", dat2_par)
toc(log = TRUE) # time elapsed: 7321.151 seconds (122.02 minutes) for the second 6000 rows, 1.9 gb

tic("birds parallel 3")
dat3_par <- mclapply(seq(nrow(dat3)), function(i) cc_make_valid(dat3[i, ]), mc.cores = parallel::detectCores())
dat3_final <- do.call("rbind", dat3_par)
toc(log = TRUE) # time elapsed: 14592.23 seconds (243.2 minutes) for the last 5463 rows, which were 3.3 gb

bird_valid <- rbind(dat1_final, dat2_final, dat3_final)


# save(dat1_par, dat1_final, dat2_par, dat2_final, #dat3_par, dat3_final, 
#      file = "/Users/christophercrawford/Google Drive/_Projects/Zambia/agroEcoTradeoff/external/data_new/1_IUCN_dev/bird_par_files.RData")

tic("save dat_final 1, 2, and 3")
save(dat1_final, dat2_final, dat3_final, file = "/Users/christophercrawford/Google Drive/_Projects/Zambia/agroEcoTradeoff/external/data_new/1_IUCN_dev/bird_dat_finals.RData")
toc(log = TRUE) # 487.205 sec elapsed

tic("save bird_valid")
save(bird_valid, file = "/Users/christophercrawford/Google Drive/_Projects/Zambia/agroEcoTradeoff/external/data_new/1_IUCN_dev/bird_valid.RData")
toc(log = TRUE)
tic.log(format = TRUE) # 409.253 sec elapsed

load(file = "/Users/christophercrawford/Google Drive/_Projects/Zambia/agroEcoTradeoff/external/data_new/1_IUCN_dev/bird_valid.RData", verbose = TRUE) # this has "bird_valid", an sf object made by splitting bird_sf into three files, and running cc_make_valid on each in parallel, the using rbind to put them back together. it's 6.9 gb.

```

```{r bird-prep}
load(file = "/Users/christophercrawford/Google Drive/_Projects/Zambia/agroEcoTradeoff/external/data_new/1_IUCN_dev/bird_valid.RData", verbose = TRUE) # this has "bird_valid", an sf object made by splitting bird_sf into three files, and running cc_make_valid on each in parallel, the using rbind to put them back together. it's 6.9 gb.

# ------------------------------------------------------
#  join the bird_valid file to the red_list file
# ------------------------------------------------------
names(bird_valid)
bird_valid <- bird_valid %>% 
  left_join(bird_red_list, by = c("SISID" = "SISRecID")) # by = c("key x" = "key y")

bird_valid$ScientificName <- drop.levels(bird_valid$ScientificName)
bird_valid$SCINAME <- drop.levels(bird_valid$SCINAME)
identical(bird_valid[['SCINAME']], bird_valid[['ScientificName']])

names(bird_valid)
# rename variable names to match the other vertebrate groups, for use in "cc_make_raster()".
bird_valid <- rename(bird_valid, 
                  category = RedListCategory,
                  presence = PRESENCE,
                  origin = ORIGIN, 
                  seasonal = SEASONAL,
                  binomial = SCINAME) # renaming variable names ("new name = old name")



# ------------------------------------------------------------
# code to prepare the sf file for the creation of 1) small-ranged species richness, 2) weighted endemism richness, and 3) threat-weighted species richness. This involves calculating polygon areas, summing to determine the total range area (excluding parts of the range we aren't considering), ordering the species by range size and giving the rank order (normalized to between 0-1). This also involves calculating the inverse of the global range size and the threat category weight.
# ------------------------------------------------------------

names(bird_valid)

tic("add area") ### note that I had to change "geometry" to "Shape"
bird_valid <- bird_valid %>%
  mutate(., area_km2 = st_area(.["Shape"]) %>% units::set_units(km^2)) # area, calculated from polygons in long lat projection
toc() # 271.001 sec for bird_valid (4.5 minutes)

# trying it in parallel
# it crashes, I think because the list that is created, with one list element for each row ends up being humongus. too big! This is fine when it's run on the cluster, but probably better off running it just in serial. 
# tic("add area, birds parallel, full run")
# bird_valid_l <- mclapply(seq(nrow(bird_valid)), function(i) {
#   mutate(bird_valid[i, ], area_km2 = units::set_units(st_area(bird_valid[i, ]["Shape"]), km^2))
#   }, 
#   mc.cores = parallel::detectCores()-1)
# toc(log = TRUE)
# # time for 100 rows: 2.136 seconds
# 
# bird_valid_l_combined <- do.call("rbind", bird_valid_l)


# ------------------------------------------------------------
# subset to only those ranges used in analysis,
# then, group by species, and calculate the sum of the various polygons, i.e. the total range area for each species. 
tic("summarize")
bird_valid_summary <- bird_valid %>%   # assign dat to a new object, to then be modified
  st_drop_geometry() %>%
  filter(presence == 1) %>%   # only records with Code 1 (Extant)
  filter(origin %in% c(1, 2)) %>%     # only native species (Code 1) and reintroduced (Code 2)
  filter(seasonal %in% c(1, 2, 3)) %>%   # selecting "Resident" (1), "Breeding" (2), and "Non-breeding Season" (3) ranges. Other categories include: Non-breeding Season (3), Passage (4), and Seasonal Occurrence Uncertain (5).
  filter(!category %in% c("EW", "EX")) %>% # remove Extinct or Extinct in the Wild species ("EW", "EX")
  group_by(binomial) %>%
  dplyr::summarize(total_range_area = sum(area_km2, na.rm = TRUE), n_polygons = n())
toc() # 1.355 seconds for bird_valid.

nrow(bird_valid_summary) # 10936, even. There are no EW or EX species that are also Extant (presence ==1).
drop.levels(bird_valid$binomial) # 11125 originally, pre-filtering

  
### what are the summary statistics? What is the median, 1st quartile, etc?
quantile(bird_valid_summary$total_range_area, probs = c(0.25, 0.5, 0.75)) 
# 1st quartile: 58192.94 km2 (even after dropping EW EX)
# 2nd quartile: 471064.67 km2 (even after dropping EW EX)
# 3rd quartile: 2603424.08 km2 (even after dropping EW EX)

# add column to put the species in order of range size, counting upwards from the smallest range, and add a second column dividing by the total number of species
bird_valid_summary <- bird_valid_summary %>%
  arrange(total_range_area) %>%
  mutate(range_size_quantile = row_number()/max(row_number()))

nrow(bird_valid_summary) # 10936
bird_valid_summary %>% 
  filter(range_size_quantile <= 0.5) %>% # do <= if nrow is even, and < if nrow is odd.
  arrange(desc(total_range_area)) %>%
  nrow() # 5468
nrow(bird_valid_summary)/2

# ------------------------------------------------------------
# join total range area back to original sf object
names(bird_valid_summary)
bird_valid <- bird_valid %>% # by = c("key x" = "key y")
  left_join(bird_valid_summary, by = c("binomial" = "binomial"))
names(bird_valid)
head(bird_valid)
bird_valid %>% filter(binomial == "Chaetura meridionalis") %>% st_geometry() %T>% plot()


# add the number of vertices
bird_valid <- bird_valid %>% 
  mutate(vertices = mapview::npts(bird_valid, by_feature = TRUE))


# ------------------------------------------------------------
# calculate inverse_range_glob & 
# threat status weight (based on Damania & Wheeler 2015, Veach et al. 2017)
bird_valid <- bird_valid %>% 
  mutate(inverse_range_glob = 1/total_range_area) %>% 
  mutate(threat_weight = 
           ifelse(category == "CR", 1,    # if CR then 1, if not, then ->
           ifelse(category == "EN", 1/2,  # if EN then 1/2, if not, then ->
           ifelse(category == "VU", 1/4,  # if VU then 1/4, if not, then ->
           ifelse(category == "NT", 1/8,  # if NT then 1/8, if not, then ->
           ifelse(category == "LC", 1/16, # if LC then 1/16, if not, then ->
           ifelse(category == "DD", 1/4, NA))))))) # if DD then 1/4 (a middle ground, conservative estimate). If not, then -> NA. This means that EW, EX are all set to NA.



# -----------------------------------------------------
### Now you can use it to filter to only "small-ranged species," those species with total range areas of less than the median (or the 1st quartile, whatever method you decide)
nrow(bird_valid_summary)
bird_valid %>% 
  filter(range_size_quantile <= 0.5) %>% # do <= if nrow is even, and < if nrow is odd.
  arrange(desc(total_range_area))  

# -----------------------------------------------------
save(bird_valid, file = "/Users/christophercrawford/Google Drive/_Projects/Zambia/agroEcoTradeoff/external/data_new/1_IUCN_dev/bird_valid_prepped.RData") # contains bird_valid (7.22 gb), but prepped for use in small species, etc. This entailed joining the table of red list categories, changing some of the column names, adding a column for area, totalling area for parts of the range we're using, and adding a column ranking the range size to allow things to be subset for small ranged species analyses.


#####
# >>>> filter the original bird_sf
#####
```


```{r bird-clip}
load(file = "/Users/christophercrawford/Google Drive/_Projects/Zambia/agroEcoTradeoff/external/data_new/1_IUCN_dev/bird_valid_prepped.RData", verbose = TRUE)

# --------------------------------------------------------
# clip to Zambia
bird_zambia <- bird_valid %>%
  st_intersection(., st_union(msk_sf_ll_noholes)) %>%
  st_collection_extract(., "POLYGON") # extract only polygons


# -------------------------------------------------------------
# calculate area of clipped polygons in Zambia (calculated in long lat projection)
bird_zambia <- bird_zambia %>%
  mutate(area_zambia_km2 = st_area(.["Shape"]) %>% units::set_units(km^2)) 


# -------------------------------------------------------------
# subset to only those ranges used in analysis, then 
# group by species and sum across polygons to get species' total range area in Zambia

bird_zambia_summary <- bird_zambia %>%   # assign dat to a new object, to then be modified
  st_drop_geometry() %>%
  filter(presence == 1) %>%   # only records with Code 1 (Extant)
  filter(origin %in% c(1, 2)) %>%     # only native species (Code 1) and reintroduced (Code 2)
  filter(seasonal %in% c(1, 2, 3)) %>%   # selecting "Resident" (1), "Breeding" (2), and "Non-breeding Season" (3) ranges. Other categories include: Passage (4), and Seasonal Occurrence Uncertain (5).
  #filter(marine == "False") %>%   # removing all marine species, except for bird species
  filter(!category %in% c("EW", "EX")) %>% # remove Extinct or Extinct in the Wild species ("EW", "EX")
  group_by(binomial) %>%
  dplyr::summarize(total_zambia_range_area = sum(area_zambia_km2, na.rm = TRUE), n_polygons = n())

nrow(bird_zambia_summary) # 738 species, even number of rows

  
# what are the summary statistics? What is the median, 1st quartile, etc?
summary(bird_zambia_summary$total_zambia_range_area)
quantile(bird_zambia_summary$total_zambia_range_area, probs = c(0.25, 0.5, 0.75)) 
# update for each taxonomic group
# 1st quartile: 88,348.02 km2 (global: 58,192.94 km2, even after dropping EW EX)
# 2nd quartile: 503,786.22 km2 (global: 471,064.67 km2, even after dropping EW EX)
# 3rd quartile: 741,094.45 km2 (global: 2,603,424.08 km2, even after dropping EW EX)

# ------------------------------------------------------------
# add column to put the species in order of range size, 
# counting upwards from the smallest range, and add a second column 
# dividing by the total number of species
bird_zambia_summary <- bird_zambia_summary %>%
  arrange(total_zambia_range_area) %>%
  mutate(range_size_quantile_zambia = row_number()/max(row_number()))
  
nrow(bird_zambia_summary) # 738
tail(bird_zambia_summary)

median(bird_zambia_summary$total_zambia_range_area)

bird_zambia_summary %>% 
  filter(range_size_quantile_zambia <= 0.5) %>% # do <= if nrow is even, and < if nrow is odd.
  arrange(desc(total_zambia_range_area)) %>%
  nrow() # 369
nrow(bird_zambia_summary)/2

# ------------------------------------------------------------
# join total Zambia range area back to clipped sf object
names(bird_zambia_summary)
bird_zambia <- bird_zambia %>% # by = c("key x" = "key y")
  left_join(bird_zambia_summary, by = c("binomial" = "binomial"))



# -------------------------------------------------------------
# calculate the inverse of the range in Zambia
bird_zambia <- bird_zambia %>%
  mutate(inverse_range_zam = 1/total_zambia_range_area) 


# -------------------------------------------------------------
save(bird_zambia, file = "/Users/christophercrawford/Google Drive/_Projects/Zambia/agroEcoTradeoff/external/data_new/1_IUCN_dev/bird_zambia.RData") # includes bird_zambia, which has had area added, been prepped, and then clipped to zambia

```


```{r bird_list_final}
nrow(bird_valid_summary) # 10936 bird species globally (even)
nrow(bird_zambia_summary) # 738 bird species in Zambia (even)

tic()
bird_list <- cc_make_raster8(input_sf = bird_zambia, 
                              run_clip = FALSE, run_extract = FALSE,
                              clip_area = msk_sf_ll_noholes, 
                              filter_marine = FALSE, 
                              odd_n_global = FALSE, odd_n_zam = FALSE)
toc() # 274 secs if doing the full bird_valid, 13 seconds if only bird_zambia


bird_list$brick
object_size(bird_list)

plot(bird_list$brick$all_richness)
plot(bird_list$brick$endemism_richness)
plot(bird_list$brick$endemism_zam_richness)
plot(bird_list$brick$threat_richness)
plot(bird_list$brick$threat_weighted_richness)
plot(bird_list$brick$small_richness)
plot(bird_list$brick$small_zam_richness)
plot(bird_list$brick$small_threat_richness)


save(bird_list, file = "/Users/christophercrawford/Google Drive/_Projects/Zambia/agroEcoTradeoff/external/data_new/1_IUCN_dev/bird_list.RData")

bird_brick <- writeRaster(bird_list$brick, filename = fp(p_iucn_dev, "bird_brick.tif"), overwrite = TRUE)
names(bird_brick) <- names(bird_list$brick)

```


## Amphibians  

```{r amp-start}
load(fp(p_iucn_dev,"amphibian_valid_files.RData"), verbose = TRUE) # amp_sf_valid

st_layers(fp(p_amp,"AMPHIBIANS.shp")) # what layers are there in the BOTW file geodatabase? 
amp_sf <- st_read(dsn = fp(p_amp,"AMPHIBIANS.shp"))

amp_sf_valid
as_tibble(amp_sf_valid)
table(amp_sf_valid$presence)
table(amp_sf_valid$origin)
table(amp_sf_valid$seasonal)
table(amp_sf_valid$terrestial)
table(amp_sf_valid$marine)
table(amp_sf_valid$terrestial)
table(amp_sf_valid$category)

object_size(amp_sf_valid)
names(amp_sf_valid)
```

```{r amp-valid-parallel}
# Fix invalid geometries, using custom cc_make_valid() function, running in parallel. 

tic("full script")
library(sf)
library(lwgeom)
library(dplyr)
library(tictoc)
library(parallel)
library(pryr)

tic("load data")
dat <- st_read(dsn = "/Users/christophercrawford/Google Drive/_Projects/data/Bd/IUCN_RedList/AMPHIBIANS/AMPHIBIANS.shp")
toc(log = TRUE)

tic("add row number")
dat <- dat %>%
  mutate(key = row_number()) %>%
  select(key, everything())
toc(log = TRUE)

print("dat object size")
object_size(dat)

# see cc_functions.R for cc_make_valid()
tic("run in parallel")
dat <- mclapply(seq(1, nrow(dat), by = 100), function(i) cc_make_valid(dat[i:(i+99), ]), mc.cores = 8)
toc(log = TRUE) #1512 seconds (25 minutes)

print("dat object size par list")
object_size(dat)
print("length of dat par list")
length(dat)
dat[[1]]

tic("recombine")
dat <- do.call("rbind", dat)
toc(log = TRUE)

print("object size post recombination")
object_size(dat)
toc(log = TRUE)

nrow(dat)

# drop NA geometries:
nrow(dat)
dat <- filter(dat, !is.na(id_no))
nrow(dat)

amp_valid <- dat
tic("write dat_par file")
save(amp_valid, file = "/Users/christophercrawford/Google Drive/_Projects/Zambia/agroEcoTradeoff/external/data_new/1_IUCN_dev/amp_valid_par.RData")
toc(log = TRUE)

toc(log = TRUE)


tic.log(format = TRUE)
```



```{r amp-prep}
# ------------------------------------------------------------
# code to prepare the sf file for the creation of 1) small-ranged species richness, 2) weighted endemism richness, and 3) threat-weighted species richness. This involves calculating polygon areas, summing to determine the total range area (excluding parts of the range we aren't considering), ordering the species by range size and giving the rank order (normalized to between 0-1). This also involves calculating the inverse of the global range size and the threat category weight.
# ------------------------------------------------------------

# amphibians ---------
# load(fp(p_iucn_dev,"amphibian_valid_files.RData"), verbose = TRUE) # amp_sf_valid

load(file = "/Users/christophercrawford/Google Drive/_Projects/Zambia/agroEcoTradeoff/external/data_new/1_IUCN_dev/amp_valid_par.RData", verbose= T) # includes amp_valid (755 mb), which was created via "amp-valid-parallel" in parallel. This is the one I used going forward.


#####
# ------------------------------------------------------------
# add a new column for area -------------
tic("add area") ### note that I had to change "geometry" to "Shape" for birds
amp_valid <- amp_valid %>%
  mutate(., area_km2 = st_area(.["geometry"]) %>% units::set_units(km^2)) # area, caluclated from polygons in long lat projection
toc() # 22.967 sec for amp_sf_valid

table(amp_valid$seasonal)

# ------------------------------------------------------------
# subset to only those ranges used in analysis,
# then, group by species, and calculate the sum of the various polygons, i.e. the total range area for each species. 
amp_valid_summary <- amp_valid %>%   # assign dat to a new object, to then be modified
  st_drop_geometry() %>%
  filter(presence == 1) %>%   # only records with Code 1 (Extant)
  filter(origin %in% c(1, 2)) %>%     # only native species (Code 1) and reintroduced (Code 2)
  filter(seasonal %in% c(1, 2, 3)) %>%   # selecting "Resident" (1), "Breeding" (2), and "Non-breeding Season" (3) ranges. Other categories include: Non-breeding Season (3), Passage (4), and Seasonal Occurrence Uncertain (5).
  filter(marine == "False") %>%   # removing all marine species
  filter(!category %in% c("EW", "EX")) %>% # remove Extinct or Extinct in the Wild species ("EW", "EX")
  group_by(binomial) %>%
  dplyr::summarize(total_range_area = sum(area_km2, na.rm = TRUE), n_polygons = n())

nrow(amp_valid_summary) # 6593 rows (one EX EW species: Anaxyrus baxteri)


  
### what are the summary statistics? What is the median, 1st quartile, etc?
quantile(amp_valid_summary$total_range_area, probs = c(0.25, 0.5, 0.75)) 
# 1st quartile: 230.3931 km2 (old pre dropping EW EX: 230.1272 km2)
# 2nd quartile: 4,443.1651 km2 (old pre dropping EW EX: 4439.1885 km2)
# 3rd quartile: 66,839.4557 km2 (old pre dropping EW EX: 66839.1562 km2)
   

# add column to put the species in order of range size, counting upwards from the smallest range, and add a second column dividing by the total number of species
amp_valid_summary <- amp_valid_summary %>%
  arrange(total_range_area) %>%
  mutate(range_size_quantile = row_number()/max(row_number()))
nrow(amp_valid_summary) # nrow is odd: 6593

amp_valid_summary %>% 
  filter(range_size_quantile < 0.5) %>% # do <= if nrow is even, and < if nrow is odd.
  arrange(desc(total_range_area)) %>%
  nrow() # 3296
nrow(amp_valid_summary)/2

median(amp_valid_summary$total_range_area)

nrow(amp_valid_summary) %% 2 == 0 # true if even, false if odd.
amp_valid %>%
  st_drop_geometry() %>%
  filter(presence == 1) %>%   # only records with Code 1 (Extant)
  filter(origin %in% c(1, 2)) %>%     # only native species (Code 1) and reintroduced (Code 2)
  filter(seasonal %in% c(1, 2, 3)) %>%   # selecting "Resident" (1), "Breeding" (2), and "Non-breeding Season" (3) ranges. Other categories include: Non-breeding Season (3), Passage (4), and Seasonal Occurrence Uncertain (5).
  filter(marine == "False") %>%   # removing all marine species
  filter(!category %in% c("EW", "EX")) %>% # remove Extinct or Extinct in the Wild species ("EW", "EX")
  .$binomial %>% unique() %>% length()
  

# ------------------------------------------------------------
# join total range area back to original sf object
names(amp_valid_summary)
amp_valid <- amp_valid %>% # by = c("key x" = "key y")
  left_join(amp_valid_summary, by = c("binomial" = "binomial"))

names(amp_valid)
head(amp_valid)


# ------------------------------------------------------------
# calculate inverse_range_glob & 
# threat status weight (based on Damania & Wheeler 2015, Veach et al. 2017)
amp_valid <- amp_valid %>% 
  mutate(inverse_range_glob = 1/total_range_area) %>% 
  mutate(threat_weight = 
           ifelse(category == "CR", 1,    # if CR then 1, if not, then ->
           ifelse(category == "EN", 1/2,  # if EN then 1/2, if not, then ->
           ifelse(category == "VU", 1/4,  # if VU then 1/4, if not, then ->
           ifelse(category == "NT", 1/8,  # if NT then 1/8, if not, then ->
           ifelse(category == "LC", 1/16, # if LC then 1/16, if not, then ->
           ifelse(category == "DD", 1/4, NA))))))) # if DD then 1/4 (a middle ground, conservative estimate). If not, then -> NA. This means that EW, EX are all set to NA.


# testing to make sure things look good. 
names(amp_valid)
amp_valid %>% 
  st_drop_geometry() %>%
  .[1:20, c(3, 23, 31:33, 35:36)]

### Now you can use it to filter to only "small-ranged species," those species with total range areas of less than the median (or the 1st quartile, whatever method you decide)
amp_valid %>% 
  filter(range_size_quantile < 0.5) %>% # do <= if nrow is even, and < if nrow is odd.
  arrange(desc(total_range_area))


# ------------------------------------------------------------
save(amp_valid, file = "/Users/christophercrawford/Google Drive/_Projects/Zambia/agroEcoTradeoff/external/data_new/1_IUCN_dev/amp_valid_prepped.RData") # contains amp_valid (756 mb), but prepped for use in small species, etc. This entailed joining the table of red list categories, changing some of the column names, adding a column for area, totalling area for parts of the range we're using, and adding a column ranking the range size to allow things to be subset for small ranged species analyses.


#####
# >>>> now, it's ready to be put through cc_make_raster
#####
```

```{r amp-clip}
load(file = "/Users/christophercrawford/Google Drive/_Projects/Zambia/agroEcoTradeoff/external/data_new/1_IUCN_dev/amp_valid_prepped.RData", verbose = TRUE)


# --------------------------------------------------------
# clip to Zambia
amp_zambia <- amp_valid %>%
  st_intersection(., st_union(msk_sf_ll_noholes)) %>%
  st_collection_extract(., "POLYGON") # extract only polygons


# -------------------------------------------------------------
# calculate area of clipped polygons in Zambia (calculated in long lat projection)
amp_zambia <- amp_zambia %>%
  mutate(area_zambia_km2 = st_area(.["geometry"]) %>% units::set_units(km^2)) 


# -------------------------------------------------------------
# subset to only those ranges used in analysis, then 
# group by species and sum across polygons to get species' total range area in Zambia

amp_zambia_summary <- amp_zambia %>%   # assign dat to a new object, to then be modified
  st_drop_geometry() %>%
  filter(presence == 1) %>%   # only records with Code 1 (Extant)
  filter(origin %in% c(1, 2)) %>%     # only native species (Code 1) and reintroduced (Code 2)
  filter(seasonal %in% c(1, 2, 3)) %>%   # selecting "Resident" (1), "Breeding" (2), and "Non-breeding Season" (3) ranges. Other categories include: Passage (4), and Seasonal Occurrence Uncertain (5).
  filter(marine == "False") %>%   # removing all marine species, except for bird species
  filter(!category %in% c("EW", "EX")) %>% # remove Extinct or Extinct in the Wild species ("EW", "EX")
  group_by(binomial) %>%
  dplyr::summarize(total_zambia_range_area = sum(area_zambia_km2, na.rm = TRUE), n_polygons = n())

nrow(amp_zambia_summary) # 94 species, even number of rows

  
# what are the summary statistics? What is the median, 1st quartile, etc?
quantile(amp_zambia_summary$total_zambia_range_area, probs = c(0.25, 0.5, 0.75)) 
# update for each taxonomic group
# 1st quartile: 30,470.62 km2 (global: 230.3931 km2)
# 2nd quartile: 265,359.47 km2 (global: 4,443.1651 km2)
# 3rd quartile: 588,652.05 km2 (global: 66,839.4557 km2)




# ------------------------------------------------------------
# add column to put the species in order of range size, 
# counting upwards from the smallest range, and add a second column 
# dividing by the total number of species
amp_zambia_summary <- amp_zambia_summary %>%
  arrange(total_zambia_range_area) %>%
  mutate(range_size_quantile_zambia = row_number()/max(row_number()))
  
nrow(amp_zambia_summary) # 94
tail(amp_zambia_summary)

median(amp_zambia_summary$total_zambia_range_area)

amp_zambia_summary %>% 
  filter(range_size_quantile_zambia <= 0.5) %>% # do <= if nrow is even, and < if nrow is odd.
  arrange(desc(total_zambia_range_area)) %>%
  nrow() # 47
nrow(amp_zambia_summary)/2

# ------------------------------------------------------------
# join total Zambia range area back to clipped sf object
names(amp_zambia_summary)
amp_zambia <- amp_zambia %>% # by = c("key x" = "key y")
  left_join(amp_zambia_summary, by = c("binomial" = "binomial"))



# -------------------------------------------------------------
# calculate the inverse of the range in Zambia
amp_zambia <- amp_zambia %>%
  mutate(inverse_range_zam = 1/total_zambia_range_area) 


# -------------------------------------------------------------
save(amp_zambia, file = "/Users/christophercrawford/Google Drive/_Projects/Zambia/agroEcoTradeoff/external/data_new/1_IUCN_dev/amp_zambia.RData") # includes amp_zambia, which has had area added, been prepped, and then clipped to zambia

```

```{r amp-list-final}
nrow(amp_valid_summary) # 6593 amphibians species globally (odd)
nrow(amp_zambia_summary) # 94 amphibians species in Zambia (even)

tic()
amp_list <- cc_make_raster8(input_sf = amp_zambia, 
                             run_clip = FALSE, run_extract = FALSE,
                             clip_area = msk_sf_ll_noholes, 
                             odd_n_global = TRUE, odd_n_zam = FALSE)
# seasonal note. selecting "Resident" (1), "Breeding" (2), but none of the others. Only 3 geometries of class 5 "Seasonal occurence unknown", which are excluded. No 3 or 4 polygons exist.
toc() # 5.449 sec for just amp_zambia

amp_list$brick
object_size(amp_list)

plot(amp_list$brick$all_richness)
plot(amp_list$brick$endemism_richness)
plot(amp_list$brick$endemism_zam_richness)
plot(amp_list$brick$threat_richness)
plot(amp_list$brick$threat_weighted_richness)
plot(amp_list$brick$small_richness)
plot(amp_list$brick$small_zam_richness)
plot(amp_list$brick$small_threat_richness)


save(amp_list, file = "/Users/christophercrawford/Google Drive/_Projects/Zambia/agroEcoTradeoff/external/data_new/1_IUCN_dev/amp_list.RData")

amp_brick <- writeRaster(amp_list$brick, filename = fp(p_iucn_dev, "amp_brick.tif"), overwrite = TRUE)
names(amp_brick) <- names(amp_list$brick)
```



## Reptiles

```{r reptiles-start}
load(file = fp(p_iucn_dev,"rep_valid_prepped.RData"), verbose = TRUE)
load(file = "/Users/christophercrawford/Google Drive/_Projects/Zambia/agroEcoTradeoff/external/data_new/1_IUCN_dev/rep_zambia.RData", verbose = TRUE)

st_layers(fp(p_rep,"REPTILES.shp")) # what layers are there in the file? 
rep_sf <- st_read(dsn = fp(p_rep,"REPTILES.shp"))

as_tibble(rep_sf)
names(rep_sf)
table(rep_valid$presence)
table(rep_valid$origin)
table(rep_valid$seasonal)
table(rep_valid$marine)
table(rep_valid$category)
table(rep_valid$terrestial)

object_size(rep_sf)

names(rep_valid)
```

```{r rep-valid-parallel}
# Fix invalid geometries, using custom cc_make_valid() function, running in parallel. 

tic("full script")
library(sf)
library(lwgeom)
library(dplyr)
library(tictoc)
library(parallel)
library(pryr)

tic("load data")
# dat <- st_read(dsn = "/Users/christophercrawford/Google Drive/_Projects/data/Bd/IUCN_RedList/REPTILES/REPTILES.shp")
dat <- st_read(dsn = "/Users/christophercrawford/Google Drive/_Projects/data/Bd/GARD/GARD1.1_dissolved_ranges/modeled_reptiles.shp") # update to new GARD source

toc(log = TRUE)

tic("add row number")
dat <- dat %>%
  mutate(key = row_number()) %>%
  select(key, everything())
toc(log = TRUE)

print("dat object size")
object_size(dat)

tic("run in parallel")
dat <- mclapply(seq(1, nrow(dat), by = 100), function(i) cc_make_valid(dat[i:(i+99), ]), mc.cores = 8)
toc(log = TRUE) #1512 seconds (25 minutes)

print("dat object size par list")
object_size(dat)
print("length of dat par list")
length(dat)
dat[[1]]

tic("recombine")
dat <- do.call("rbind", dat)
toc(log = TRUE)

print("object size post recombination")
object_size(dat)
toc(log = TRUE)

nrow(dat)

# drop NA geometries:
nrow(dat)
#dat <- filter(dat, !is.na(id_no)) # for IUCN
dat <- filter(dat, !is.na(key)) # for GARD

nrow(dat)

#rep_valid <- dat
gard_valid <- dat

tic("write dat_par file")
# save(rep_valid, file = "/Users/christophercrawford/Google Drive/_Projects/Zambia/agroEcoTradeoff/external/data_new/1_IUCN_dev/rep_valid_par.RData")

save(gard_valid, file = "/Users/christophercrawford/Google Drive/_Projects/Zambia/agroEcoTradeoff/external/data_new/1_IUCN_dev/gard_valid.RData")
toc(log = TRUE)

toc(log = TRUE)


tic.log(format = TRUE)
# "load data: 12.388 sec elapsed"
# "add row number: 0.164 sec elapsed"
# "run in parallel: 14840.091 sec elapsed"
# "recombine: 5.552 sec elapsed"
# "full script: 14868.046 sec elapsed"
# "write dat_par file: 67.931 sec elapsed"

# rm(dat)
```



```{r rep-prep}
# ------------------------------------------------------------
# code to prepare the sf file for the creation of 1) small-ranged species richness, 2) weighted endemism richness, and 3) threat-weighted species richness. This involves calculating polygon areas, summing to determine the total range area (excluding parts of the range we aren't considering), ordering the species by range size and giving the rank order (normalized to between 0-1). This also involves calculating the inverse of the global range size and the threat category weight.
# ------------------------------------------------------------


# reptiles  ---------
# load(fp(p_iucn_dev, "reptile_valid_files.RData"), verbose = TRUE) # rep_sf_valid
load(file = "/Users/christophercrawford/Google Drive/_Projects/Zambia/agroEcoTradeoff/external/data_new/1_IUCN_dev/rep_valid_par.RData", verbose = TRUE) # includes rep_valid (1.33 gb), which was made in the chunk "mam-valid-parallel". This is the one I used going forward.
object_size(rep_valid)


#####
# ------------------------------------------------------------
# add a new column for area -------------
tic("add area") ### note that I had to change "geometry" to "Shape" for birds
rep_valid <- rep_valid %>%
  mutate(., area_km2 = st_area(.["geometry"]) %>% units::set_units(km^2)) # area, caluclated from polygons in long lat projection
toc(log = TRUE) # 40.115 sec for rep_valid

table(rep_valid$seasonal) # 1: 8740, 2: 10, 5: 3
nrow(rep_valid) # 8753.

# ------------------------------------------------------------
# subset to only those ranges used in analysis,
# then, group by species, and calculate the sum of the various polygons, i.e. the total range area for each species. 
rep_valid_summary <- rep_valid %>%   # assign dat to a new object, to then be modified
  st_drop_geometry() %>%
  filter(presence == 1) %>%   # only records with Code 1 (Extant)
  filter(origin %in% c(1, 2)) %>%     # only native species (Code 1) and reintroduced (Code 2)
  filter(seasonal %in% c(1, 2, 3)) %>%   # selecting "Resident" (1), "Breeding" (2), and "Non-breeding Season" (3) ranges. Other categories include: Non-breeding Season (3), Passage (4), and Seasonal Occurrence Uncertain (5).
  filter(marine == "False") %>%   # removing all marine species
  filter(!category %in% c("EW", "EX")) %>% # remove Extinct or Extinct in the Wild species ("EW", "EX")
  group_by(binomial) %>%
  dplyr::summarize(total_range_area = sum(area_km2, na.rm = TRUE), n_polygons = n())

nrow(rep_valid_summary) # 6358 species, even - (6360 minus two EX or EW species: Contomastix charrua, Leiocephalus eremitus)

  
### what are the summary statistics? What is the median, 1st quartile, etc?
quantile(rep_valid_summary$total_range_area, probs = c(0.25, 0.5, 0.75)) 
# 1st quartile: 966.7065 km2 (old pre dropping EW EX: 964.3203 km2)
# 2nd quartile: 16,955.5827 km2 (old pre dropping EW EX: 16917.3988 km2)
# 3rd quartile: 180,190.4067 km2 (old pre dropping EW EX: 180036.9535 km2)
   

# add column to put the species in order of range size, counting upwards from the smallest range, and add a second column dividing by the total number of species
rep_valid_summary <- rep_valid_summary %>%
  arrange(total_range_area) %>%
  mutate(range_size_quantile = row_number()/max(row_number()))
nrow(rep_valid_summary) # 6358 even

amp_valid_summary %>% 
  filter(range_size_quantile <= 0.5) %>% # do <= if nrow is even, and < if nrow is odd.
  arrange(desc(total_range_area)) %>%
  nrow() # 2763
nrow(amp_valid_summary)/2

# ------------------------------------------------------------
# join total range area back to original sf object
names(rep_valid_summary)
rep_valid <- rep_valid %>% # by = c("key x" = "key y")
  left_join(rep_valid_summary, by = c("binomial" = "binomial"))
names(rep_valid)
head(rep_valid)


# ------------------------------------------------------------
# calculate inverse_range_glob & 
# threat status weight (based on Damania & Wheeler 2015, Veach et al. 2017)
rep_valid <- rep_valid %>% 
  mutate(inverse_range_glob = 1/total_range_area) %>% 
  mutate(threat_weight = 
           ifelse(category == "CR", 1,    # if CR then 1, if not, then ->
           ifelse(category == "EN", 1/2,  # if EN then 1/2, if not, then ->
           ifelse(category == "VU", 1/4,  # if VU then 1/4, if not, then ->
           ifelse(category == "NT", 1/8,  # if NT then 1/8, if not, then ->
           ifelse(category == "LC", 1/16, # if LC then 1/16, if not, then ->
           ifelse(category == "DD", 1/4, NA))))))) # if DD then 1/4 (a middle ground, conservative estimate). If not, then -> NA. This means that EW, EX are all set to NA.



# testing to make sure things look good. 
names(rep_valid)
rep_valid %>% 
  st_drop_geometry() %>%
  .[1:20, c(3, 23, 31:33, 35:36)]

### Now you can use it to filter to only "small-ranged species," those species with total range areas of less than the median (or the 1st quartile, whatever method you decide)
rep_valid %>% 
  st_drop_geometry() %>%
  filter(range_size_quantile <= 0.5) %>% # do <= if nrow is even, and < if nrow is odd.
  arrange(desc(total_range_area)) %>%
  as_tibble()

# ------------------------------------------------------------
save(rep_valid, file = "/Users/christophercrawford/Google Drive/_Projects/Zambia/agroEcoTradeoff/external/data_new/1_IUCN_dev/rep_valid_prepped.RData") # contains rep_valid (1.3 gb), but prepped for use in small species, etc. This entailed joining the table of red list categories, changing some of the column names, adding a column for area, totalling area for parts of the range we're using, and adding a column ranking the range size to allow things to be subset for small ranged species analyses.


#####
# >>>> now, it's ready to be put through cc_make_raster
#####
```

```{r rep-clip}
# --------------------------------------------------------
# clip to Zambia
rep_zambia <- rep_valid %>%
  st_intersection(., st_union(msk_sf_ll_noholes)) %>%
  st_collection_extract(., "POLYGON") # extract only polygons


# -------------------------------------------------------------
# calculate area of clipped polygons in Zambia (calculated in long lat projection)
rep_zambia <- rep_zambia %>%
  mutate(area_zambia_km2 = st_area(.["geometry"]) %>% units::set_units(km^2)) 


# -------------------------------------------------------------
# subset to only those ranges used in analysis, then 
# group by species and sum across polygons to get species' total range area in Zambia

rep_zambia_summary <- rep_zambia %>%   # assign dat to a new object, to then be modified
  st_drop_geometry() %>%
  filter(presence == 1) %>%   # only records with Code 1 (Extant)
  filter(origin %in% c(1, 2)) %>%     # only native species (Code 1) and reintroduced (Code 2)
  filter(seasonal %in% c(1, 2, 3)) %>%   # selecting "Resident" (1), "Breeding" (2), and "Non-breeding Season" (3) ranges. Other categories include: Passage (4), and Seasonal Occurrence Uncertain (5).
  filter(marine == "False") %>%   # removing all marine species, except for bird species
  filter(!category %in% c("EW", "EX")) %>% # remove Extinct or Extinct in the Wild species ("EW", "EX")
  group_by(binomial) %>%
  dplyr::summarize(total_zambia_range_area = sum(area_zambia_km2, na.rm = TRUE), n_polygons = n())

nrow(rep_zambia_summary) # 37 species, odd number of rows

  
# what are the summary statistics? What is the median, 1st quartile, etc?
quantile(rep_zambia_summary$total_zambia_range_area, probs = c(0.25, 0.5, 0.75)) 
# 1st quartile: 677.0284 (global: 966.7065 km2)
# 2nd quartile: 9,936.0568 (global: 16,955.5827 km2)
# 3rd quartile: 141,564.2241 (global: 180,190.4067 km2)
     

# ------------------------------------------------------------
# add column to put the species in order of range size, 
# counting upwards from the smallest range, and add a second column 
# dividing by the total number of species
rep_zambia_summary <- rep_zambia_summary %>%
  arrange(total_zambia_range_area) %>%
  mutate(range_size_quantile_zambia = row_number()/max(row_number()))
  
nrow(rep_zambia_summary) # 37
tail(rep_zambia_summary)

median(rep_zambia_summary$total_zambia_range_area)

rep_zambia_summary %>% 
  filter(range_size_quantile_zambia < 0.5) %>% # do <= if nrow is even, and < if nrow is odd.
  arrange(desc(total_zambia_range_area)) %>%
  nrow() # 18
nrow(rep_zambia_summary)/2

# ------------------------------------------------------------
# join total Zambia range area back to clipped sf object
names(rep_zambia_summary)
rep_zambia <- rep_zambia %>% # by = c("key x" = "key y")
  left_join(rep_zambia_summary, by = c("binomial" = "binomial"))



# -------------------------------------------------------------
# calculate the inverse of the range in Zambia
rep_zambia <- rep_zambia %>%
  mutate(inverse_range_zam = 1/total_zambia_range_area) 


# -------------------------------------------------------------
save(rep_zambia, file = "/Users/christophercrawford/Google Drive/_Projects/Zambia/agroEcoTradeoff/external/data_new/1_IUCN_dev/rep_zambia.RData") # includes rep_zambia, which has had area added, been prepped, and then clipped to zambia



# -------------------------------------------------------------
# extras:



# clip to buffer
rep_zambia_4deg_buff <- rep_valid %>%
  st_intersection(., st_union(msk_sf_ll_4deg_buff)) %>%
  st_collection_extract(., "POLYGON")
plot(rep_zambia_4deg_buff$geometry)
save(rep_zambia_4deg_buff, file = "/Users/christophercrawford/Google Drive/_Projects/Zambia/agroEcoTradeoff/external/data_new/1_IUCN_dev/rep_zambia_4deg_buff.RData") # includes rep_zambia, which has had area added, been prepped, and then clipped to zambia
```

```{r rep-list-final}
# note, this is only using data from IUCN, not from GARD.

nrow(rep_valid_summary) # 6358 reptile species globally (even)
nrow(rep_zambia_summary) # 37 reptile species in Zambia (odd)

rep_list <- cc_make_raster8(input_sf = rep_zambia, 
                             run_clip = FALSE, run_extract = FALSE,
                             clip_area = msk_sf_ll_noholes, 
                             odd_n_global = FALSE, odd_n_zam = TRUE)

rep_list$brick
object_size(rep_list)

plot(rep_list$brick$all_richness)
plot(rep_list$brick$endemism_richness)
plot(rep_list$brick$endemism_zam_richness)
plot(rep_list$brick$threat_richness)
plot(rep_list$brick$threat_weighted_richness)
plot(rep_list$brick$small_richness)
plot(rep_list$brick$small_zam_richness)
plot(rep_list$brick$small_threat_richness)


# note, this rep_list file includes only data from IUCN, not from GARD. See GARD list for the most up to date files. The richness metric .tifs have all been updated to use GARD (or IUCN in the case of threatened species richness). These are the finaly data files used in the analysis.
save(rep_list, file = "/Users/christophercrawford/Google Drive/_Projects/Zambia/agroEcoTradeoff/external/data_new/1_IUCN_dev/rep_list.RData")


load(file = "/Users/christophercrawford/Google Drive/_Projects/Zambia/agroEcoTradeoff/external/data_new/1_IUCN_dev/rep_list.RData", verbose = TRUE)

rep_brick <- writeRaster(rep_list$brick, filename = fp(p_iucn_dev, "rep_brick.tif"), overwrite = TRUE)
names(rep_brick) <- names(rep_list$brick)
```


```{r GARD}
# This chunk recreates the above prep and filtering code chunks, but with the more complete GARD dataset.

# load data
# note that GARD has ranges for all reptile species, but not all reptile species have been assessed by the IUCN. Therefore, only a small subset can be included in the threatened species rasters. 
# --------------------------------------------------------------------------------
gard <- st_read(dsn = "/Users/christophercrawford/Google Drive/_Projects/data/Bd/GARD/GARD1.1_dissolved_ranges/modeled_reptiles.shp")


## make sure to make valid, below 
# --------------------------------------------------------------------------------
load(file = "/Users/christophercrawford/Google Drive/_Projects/Zambia/agroEcoTradeoff/external/data_new/1_IUCN_dev/gard_valid.RData", verbose = TRUE) # contains gard_valid
gard_valid

object_size(gard_valid)
object_size(rep_valid)

table(rep_valid$category)

# load and join to IUCN threat data
# --------------------------------------------------------------------------------
iucn_csv_non_lc <- read_csv("/Users/christophercrawford/Google Drive/_Projects/data/Bd/IUCN_RedList/RedList_NonLC_Plants+Animals_allregions/simple_summary.csv")
iucn_csv_lc <- read_csv("/Users/christophercrawford/Google Drive/_Projects/data/Bd/IUCN_RedList/RedList_LC_Plants+Animals_allregions/simple_summary.csv")

iucn_csv_non_lc %>% filter(className == "REPTILIA")
iucn_csv_lc %>% filter(className == "REPTILIA")

iucn_csv <- rbind(iucn_csv_non_lc, iucn_csv_lc)
iucn_csv %>% filter(className == "REPTILIA")

iucn_rep <- iucn_csv %>% filter(className == "REPTILIA")
iucn_rep %>% names
select(iucn_rep, scientificName, redlistCategory)

length(unique(iucn_rep$scientificName)) # only 7,199 reptile species have been assessed by IUCN, or at least exist in this csv

gard_valid$Binomial # GARD includes 10,064 species. 


gard_valid_join <- left_join(x = gard_valid, y = select(iucn_rep, scientificName, redlistCategory), 
                             by = c("Binomial" = "scientificName")) # by = c("key x" = "key y")


# prep by adding 1) inverse range size, and 2) range size quantile
# --------------------------------------------------------------------------------
gard_prep <- gard_valid_join %>%
  mutate(key = row_number())

# add a new column for area -------------
tic("add area") ### note that I had to change "geometry" to "Shape" for birds
gard_prep <- gard_prep %>%
  mutate(., area_km2 = st_area(.["geometry"]) %>% units::set_units(km^2)) # area, caluclated from polygons in long lat projection
toc(log = TRUE)

nrow(gard_prep) # 10064, pre remving extinct species

# ------------------------------------------------------------
# subset to only those ranges used in analysis
# filter out the EX or EW species
table(gard_prep$redlistCategory)
gard_prep <- filter(gard_prep, !redlistCategory %in% c("Extinct","Extinct in the Wild"))
nrow(gard_prep) # 10055, odd


# with the IUCN Reptile data, I had to join all the polygons for a single species together to have one sf object for each one
# gard has one row for each species.
  
### what are the summary statistics? What is the median, 1st quartile, etc?
quantile(gard_prep$area_km2, probs = c(0.25, 0.5, 0.75)) 
quantile(gard_prep$Area, probs = c(0.25, 0.5, 0.75)) # basically the same, but use the area_km2 to be consistent across the taxa.
   
# 1st quartile: 1,865.698 km2 (rep_valid, iucn: 966.7065 km2)
# 2nd quartile: 31,426.023 km2 (rep_valid, iucn: 16,955.5827 km2)
# 3rd quartile: 285,647.991 km2 (rep_valid, iucn: 180,190.4067 km2)
   

# add column to put the species in order of range size, counting upwards from the smallest range, and add a second column dividing by the total number of species

gard_prep <- gard_prep %>%
  arrange(area_km2) %>%
  mutate(range_size_quantile = row_number()/max(row_number()))
nrow(gard_prep) # 10055 odd! 

gard_prep %>% 
  filter(range_size_quantile < 0.5) %>% # do <= if nrow is even, and < if nrow is odd.
  arrange(desc(area_km2)) %>%
  nrow() # 5027
nrow(amp_valid_summary)/2

gard_prep <- gard_prep %>% arrange(key)


# ------------------------------------------------------------
# calculate inverse_range_glob
gard_prep <- gard_prep %>% 
  mutate(inverse_range_glob = 1/area_km2) 
# note, can't add threat status weight to GARD, since I don't have threat status for most reptile species (based on Damania & Wheeler 2015, Veach et al. 2017)



### Now you can use it to filter to only "small-ranged species," those species with total range areas of less than the median (or the 1st quartile, whatever method you decide)
gard_prep %>% 
  st_drop_geometry() %>%
  filter(range_size_quantile < 0.5) %>% # do <= if nrow is even, and < if nrow is odd.
  arrange(desc(area_km2)) %>%
  as_tibble()

# ------------------------------------------------------------
save(gard_prep, file = "/Users/christophercrawford/Google Drive/_Projects/Zambia/agroEcoTradeoff/external/data_new/1_IUCN_dev/gard_prep.RData") # contains gard_prep, which is gard, made valid, joined to IUCN table, and prepped for use in small species, endemism, etc. This entailed joining the table of red list categories, changing some of the column names, adding a column for area, totalling area for parts of the range we're using, and adding a column ranking the range size to allow things to be subset for small ranged species analyses.


gard_prep
# --------------------------------------------------------------------------------
# clip to Zambia
gard_zam <- gard_prep %>% # gard_valid
  st_intersection(., st_union(msk_sf_ll_noholes)) %>%
  st_collection_extract(., "POLYGON") # extract only polygons

gard_zam
table(gard_zam$Group)

object_size(gard_zam)
plot(gard_zam$geometry)

unique(gard_zam$Binomial) # 226 unique species in Zambia
unique(rep_zambia$binomial) # 38 reptile species have been assessed by the IUCN in Zambia. After filtering, there are only 37 species left. 

plot(rep_zambia$geometry)

gard_zam %>% filter(is.na(redlistCategory)) # 178


# testing the threat status of the gard ranges. My decision is to use the iucn range maps for threatened species, to maintain consistency.
rep_zambia %>% st_drop_geometry() %>% select(binomial, category) %>% filter(category != "LC")
gard_zam %>% st_drop_geometry() %>% select(Binomial, redlistCategory) %>% filter(is.na(redlistCategory))
gard_zam %>% st_drop_geometry() %>% select(Binomial, redlistCategory) %>% filter(!is.na(redlistCategory), redlistCategory != "Least Concern")

plot(msk_sf_ll$geometry)
rep_valid %>% filter(binomial == "Cycloderma frenatum") %>% st_geometry() %T>% plot(add = TRUE)
rep_zambia %>% filter(binomial == "Cycloderma frenatum") %>% st_geometry() %T>% plot(add = TRUE)

gard_zam %>% filter(Binomial == "Cycloderma frenatum") %>% st_geometry() %T>% plot(add = TRUE, col = "red")
gard_valid %>% filter(Binomial == "Cycloderma frenatum") %>% st_geometry() %T>% plot()#add = TRUE, col = "blue")


plot(msk_sf_ll$geometry)
rep_valid %>% filter(binomial == "Mecistops cataphractus") %>% st_geometry() %T>% plot(add = TRUE)
rep_zambia %>% filter(binomial == "Mecistops cataphractus") %>% st_geometry() %T>% plot(add = TRUE)

gard_zam %>% filter(Binomial == "Mecistops cataphractus") %>% st_geometry() %T>% plot(add = TRUE, col = "red")
gard_valid %>% filter(Binomial == "Mecistops cataphractus") %>% st_geometry() %T>% plot()#add = TRUE, col = "blue")

# just plotting the threatened species
rep_zambia %>% filter(category != "LC") %>% st_geometry() %T>% plot()
gard_zam %>% filter(!is.na(redlistCategory), redlistCategory != "Least Concern") %>% 
  st_geometry() %T>% plot()

test <- fasterize(st_transform(gard_zam, aaeac), msk, field = NULL, fun = "sum")
test_t <- fasterize(st_transform(filter(gard_zam, redlistCategory %in% c("Endangered", "Critically Endangered")), aaeac), msk, field = NULL, fun = "sum")
gard_zam %>% st_drop_geometry() %>% select(Binomial, redlistCategory) %>% filter(redlistCategory %in% c("Endangered", "Critically Endangered"))

plot(test)
plot(test_t)


#####
# >>>> now, it's ready to be put through cc_make_raster
#####
test_t <- fasterize(st_transform(filter(gard_zam, redlistCategory %in% c("Endangered", "Critically Endangered")), aaeac), msk, field = NULL, fun = "sum")

gard_zam <- gard_zam %>%
  mutate(inverse_range_zam = 1,
         threat_weight = 1)
gard_list <- cc_make_raster8(input_sf = gard_zam, 
                             run_clip = FALSE, run_extract = FALSE,
                             clip_area = msk_sf_ll_noholes, 
                             odd_n_global = TRUE, odd_n_zam = FALSE,
                             filter_presence = FALSE, 
                             filter_origin = FALSE,
                             filter_marine = FALSE,
                             filter_seasonal = FALSE,
                             filter_EX_EW = FALSE,
                             filter_category = FALSE,
                             filter_range_size = TRUE, range_threshold = 0.5,
                             filter_range_size_zam = FALSE,
                             filter_both = FALSE
                             )

gard_list
plot(gard_list$brick$all_richness)
plot(log(gard_list$brick$endemism_richness))
plot(gard_list$brick$endemism_zam_richness)
plot(gard_list$brick$threat_richness)
plot(gard_list$brick$threat_weighted_richness)
plot(gard_list$brick$small_richness)
plot(gard_list$brick$small_zam_richness)
plot(gard_list$brick$small_threat_richness)


object_size(gard_list)
gard_list$filtered_threat <- NULL
gard_list$filtered_threat_small <- NULL
gard_list$filtered_small_zam <- NULL
gard_list$reprojected_threat <- NULL
gard_list$reprojected_small_zam <- NULL
gard_list$reprojected_threat_small <- NULL
gard_list$brick$endemism_zam_richness <- NULL
gard_list$brick$threat_richness <- NULL
gard_list$brick$small_zam_richness <- NULL
gard_list$brick$small_threat_richness <- NULL
gard_list$brick$threat_weighted_richness <- NULL

gard_list$brick <- dropLayer(gard_list$brick, c(3, 4, 5,7, 8))




# --------------------------------------------------------------------------------
# save

save(gard_list, file = "/Users/christophercrawford/Google Drive/_Projects/Zambia/agroEcoTradeoff/external/data_new/1_IUCN_dev/gard_list.RData")

gard_brick <- writeRaster(gard_list$brick, filename = fp(p_iucn_dev, "gard_brick.tif"), overwrite = TRUE)
names(gard_brick) <- names(gard_list$brick) # c("all_richness", "endemism_richness", "small_richness")



# --------------------------------------------------------------------------------
# load stuff back in

load(file = "/Users/christophercrawford/Google Drive/_Projects/Zambia/agroEcoTradeoff/external/data_new/1_IUCN_dev/gard_valid.RData", verbose = TRUE) # contains gard_valid

load(file = "/Users/christophercrawford/Google Drive/_Projects/Zambia/agroEcoTradeoff/external/data_new/1_IUCN_dev/gard_prep.RData", verbose = TRUE) # contains gard_prep, which is gard, made valid, joined to IUCN table, and prepped for use in small species, endemism, etc. This entailed joining the table of red list categories, changing some of the column names, adding a column for area, totaling area for parts of the range we're using, and adding a column ranking the range size to allow things to be subset for small ranged species analyses.

load(file = "/Users/christophercrawford/Google Drive/_Projects/Zambia/agroEcoTradeoff/external/data_new/1_IUCN_dev/gard_list.RData", verbose = TRUE)


# count the number of species in different groups, for the species occurrence table:
gard_list$filtered_all %>%
  st_drop_geometry() %>%
  select(Binomial) %>%
  unique() %>% nrow() # 226

gard_list$filtered_small %>%
  st_drop_geometry() %>%
  select(Binomial) %>%
  unique() %>% nrow() # 10

rep_list$filtered_threat %>%
  st_drop_geometry() %>%
  select(binomial) %>%
  unique() %>% nrow() # 3

# threatened rep:
# Malacochersus tornieri
# Cycloderma frenatum
# Mecistops cataphractus

# these three threatened species do not overlap with the 10 small-ranged species

gard_list$filtered_all %>% 
  filter(Binomial %in% c("Malacochersus tornieri", "Cycloderma frenatum", "Mecistops cataphractus"))


# note about what's driving the rep_endemism map
load(file = "/Users/christophercrawford/Google Drive/_Projects/Zambia/agroEcoTradeoff/external/data_new/1_IUCN_dev/gard_prep.RData", verbose = TRUE) # contains gard_prep, which is gard, made valid, joined to IUCN table, and prepped for use in small species, endemism, etc. This entailed joining the table of red list categories, changing some of the column names, adding a column for area, totalling area for parts of the range we're using, and adding a column ranking the range size to allow things to be subset for small ranged species analyses.

load(file = "/Users/christophercrawford/Google Drive/_Projects/Zambia/agroEcoTradeoff/external/data_new/1_IUCN_dev/gard_list.RData", verbose = TRUE)
gard_list$filtered_small %>%
  st_drop_geometry() %>%
  filter(range_size_quantile < 0.5) %>% # do <= if nrow is even, and < if nrow is odd.
  arrange(area_km2)

# Acontias schmitzi is a lizard endemic to Zambia, with a tiny range of basically 10 km2. It's only locality is from near Mongu, at 1523.015S, 2323.729E. 
# see: http://reptile-database.reptarium.cz/species?genus=Acontias&species=schmitzi

# plot
plot(vert_r$endemism_richness$rep, main = "rep_endemism")

ext <- drawExtent(show = TRUE, col = "red")
plot(vert_r$endemism_richness$rep, main = "rep_endemism", ext = ext)

# maximum cell values
cellStats(vert_r$endemism_richness$rep, "max") # 0.1001044
hist(vert_r$endemism_richness$rep, 
     main = "rep_endemism", maxpixels = maxpixels)


1/0.1001044 # = 9.9, corresponding to the range of Acontias schmitzi: http://reptile-database.reptarium.cz/species?genus=Acontias&species=schmitzi

# if you remove the values associated with Acontias schmitzi, the distribution of values looks much more "reasonable"
hist(vert_r$endemism_richness$rep[vert_r$endemism_richness$rep < 0.09])
max(vert_r$endemism_richness$rep[vert_r$endemism_richness$rep < 0.09]) # 0.000538

```


## All Vertebrates
```{r save_list_summaries}
# note: these lists were created using the function cc_make_raster8 on January 31st, 2020. 
save(mam_list, bird_list, amp_list, rep_list, file = fp(p_iucn_dev, "vert_lists.RData"))


# global totals
nrow(mam_valid_summary) # 5527 mammal species globally (odd)
nrow(mam_zambia_summary) # 252 mammal species in Zambia (even)

nrow(bird_valid_summary) # 10936 bird species globally (even)
nrow(bird_zambia_summary) # 738 bird species in Zambia (even)

nrow(amp_valid_summary) # 6593 amphibians species globally (odd)
nrow(amp_zambia_summary) # 94 amphibians species in Zambia (even)

nrow(rep_valid_summary) # 6358 reptile species globally (even)
nrow(rep_zambia_summary) # 37 reptile species in Zambia (odd)

save(mam_valid_summary,
     bird_valid_summary,
     amp_valid_summary,
     rep_valid_summary, 
     file = fp(p_datnew, "1_IUCN_dev/vert_valid_summaries.RData"))

save(mam_zambia_summary, 
     bird_zambia_summary, 
     amp_zambia_summary, 
     rep_zambia_summary,
     file = fp(p_datnew, "1_IUCN_dev/vert_zambia_summaries.RData"))


####
load(file = fp(p_iucn_dev, "vert_lists.RData"), verbose = TRUE)
load(file = fp(p_datnew, "1_IUCN_dev/vert_valid_summaries.RData"), verbose = TRUE)
load(file = fp(p_datnew, "1_IUCN_dev/vert_zambia_summaries.RData"), verbose = TRUE)

```


```{r prep-zambia}

r1 <- cc_prep_zambia(mam_zambia_threat_richness)
r2 <- cc_prep_zambia(bird_zambia_threat_richness)
r3 <- cc_prep_zambia(amp_zambia_threat_richness)
r4 <- cc_prep_zambia(rep_zambia_threat_richness)
v <- r1 + r2 + r3 + r4
plot(v)
plot(amp_zambia_threat_richness)
plot(test)

output_raster <- crop(output_raster, extent(msk))
output_raster[is.na(output_raster)] <- 0 # replace NAs with 0s
output_raster <- raster::mask(output_raster, msk)
```

```{r vert_bricks}
# Save the final versions of the four taxonomic groups. Note that this includes two versions for reptiles:
# rep which uses exclusively IUCN data
# gard, which uses the GARD database. 

save(mam_brick, bird_brick, amp_brick, rep_brick, gard_brick, file = fp(p_datnew, "vert_bricks.Rdata"))
load(file = fp(p_datnew, "vert_bricks.Rdata"), verbose = TRUE)
gard_brick

vert_bricks <- list(
  mam = mam_brick,
  bird = bird_brick,
  amp = amp_brick,
  rep = rep_brick,
  gard = gard_brick
)



plot(rep_brick$all_richness)
plot(gard_brick$all_richness)
plot(log(rep_brick$endemism_richness))
plot(log(gard_brick$endemism_richness))

plot(rep_brick$small_richness)
plot(gard_brick$small_richness)

plot(rep_brick$threat_richness)

```

```{r sum_norm_rescale_+_save}
# This script does four things: sum the vertebrate taxa, normalize them, rescale them, and finally save the bricks to file.
# This produces 8 multi layer raster bricks (.tif files) for the 8 richness metrics, each with multiple taxonomic groups, resolutions, and combinations.

# ---------------
# add vert rasters together -------------------------------------------------
# ---------------
# This involves three steps:
# 1. $sum, which is just the absolute sum of the four layers (mam, bird, amp, rep)
# 2. $sum_norm, which is $sum normalized to 0-1.
# 3. $norm_sum, which is calculated by individually normalizing the four layers, adding them together, and then renormalizing the sum.

# ------------------------------------------------------------------------------------
richness_names <- c("all_richness", "endemism_richness", "endemism_zam_richness", "threat_richness", "threat_weighted_richness", "small_richness", "small_zam_richness", "small_threat_richness")

names(mam_brick)


# ------------------------------------------------------------------------------------
# replace rep_brick layers with gard_brick layers, just for the purpose of running this code chunk (the rep_brick file continues to be just based on IUCN data)
rep_brick$all_richness <- gard_brick$all_richness
rep_brick$endemism_richness <- gard_brick$endemism_richness
rep_brick$small_richness <- gard_brick$small_richness

# to recreate this with the old reptile files, just use the unmodified rep_brick from load(file = fp(p_datnew, "vert_bricks.Rdata"), verbose = TRUE), which includes both GARD and the IUCN rep brick file. 


# rename, rescale, and combine 
# updated for loop:
for(i in seq_along(richness_names)) {
  
  brick <- brick()
  brick$mam <- mam_brick[[i]]
  brick$bird <- bird_brick[[i]]
  brick$amp <- amp_brick[[i]]
  brick$rep <- rep_brick[[i]]
  brick$sum <- 
    brick$mam +
    brick$bird +
    brick$amp +
    brick$rep
  
  brick$sum_norm <- 
    normalize(brick$sum)
  
  brick$norm_sum <- 
    normalize(
      normalize(brick$mam) + 
      normalize(brick$bird) + 
      normalize(brick$amp) + 
      normalize(brick$rep)
      )
  
  brick$mam_10 <- cc_rescale(brick$mam, factor = 10, mask = msk)
  brick$bird_10 <- cc_rescale(brick$bird, factor = 10, mask = msk)
  brick$amp_10 <- cc_rescale(brick$amp, factor = 10, mask = msk)
  brick$rep_10 <- cc_rescale(brick$rep, factor = 10, mask = msk)
  brick$norm_sum_10 <- 
    normalize(
      normalize(brick$mam_10) + 
      normalize(brick$bird_10) + 
      normalize(brick$amp_10) + 
      normalize(brick$rep_10)
      )
  
  brick$mam_110 <- cc_rescale(brick$mam, factor = 110, mask = msk)
  brick$bird_110 <- cc_rescale(brick$bird, factor = 110, mask = msk)
  brick$amp_110 <- cc_rescale(brick$amp, factor = 110, mask = msk)
  brick$rep_110 <- cc_rescale(brick$rep, factor = 110, mask = msk)
  brick$norm_sum_110 <- 
    normalize(
      normalize(brick$mam_110) + 
      normalize(brick$bird_110) + 
      normalize(brick$amp_110) + 
      normalize(brick$rep_110)
      )
names(brick)
  # save to file
  writeRaster(brick, filename = paste0(p_iucn_dev, "/", richness_names[i], ".tif"), overwrite = TRUE)
  }

```

```{r load_vert_layers}
# load in the final brick of all the vertebrate layers.
# create layer names object
layer_names <- c("mam", "bird", "amp", "rep", "sum", "sum_norm", "norm_sum", "mam_10", "bird_10", "amp_10", "rep_10", "norm_sum_10", "mam_110", "bird_110", "amp_110", "rep_110", "norm_sum_110")

richness_names <- c("all_richness", "endemism_richness", "endemism_zam_richness", "threat_richness", "threat_weighted_richness", "small_richness", "small_zam_richness", "small_threat_richness")

# load in as a list of all rasters
vert_r <- list(
  all_richness = brick(paste0(p_iucn_dev, "/", richness_names[1], ".tif")),
  endemism_richness = brick(paste0(p_iucn_dev, "/", richness_names[2], ".tif")),
  endemism_zam_richness = brick(paste0(p_iucn_dev, "/", richness_names[3], ".tif")),
  threat_richness = brick(paste0(p_iucn_dev, "/", richness_names[4], ".tif")),
  threat_weighted_richness = brick(paste0(p_iucn_dev, "/", richness_names[5], ".tif")),
  small_richness = brick(paste0(p_iucn_dev, "/", richness_names[6], ".tif")),
  small_zam_richness = brick(paste0(p_iucn_dev, "/", richness_names[7], ".tif")),
  small_threat_richness = brick(paste0(p_iucn_dev, "/", richness_names[8], ".tif"))
  )

# rename layers
for(i in seq_along(vert_r)) {
  names(vert_r[[i]]) <- layer_names
}


# to load in individually
# all_richness <- brick(paste0(p_iucn_dev, "/", richness_names[1], ".tif"))
# endemism_richness <- brick(paste0(p_iucn_dev, "/", richness_names[2], ".tif"))
# endemism_zam_richness <- brick(paste0(p_iucn_dev, "/", richness_names[3], ".tif"))
# threat_richness <- brick(paste0(p_iucn_dev, "/", richness_names[4], ".tif"))
# threat_weighted_richness <- brick(paste0(p_iucn_dev, "/", richness_names[5], ".tif"))
# small_richness <- brick(paste0(p_iucn_dev, "/", richness_names[6], ".tif"))
# small_zam_richness <- brick(paste0(p_iucn_dev, "/", richness_names[7], ".tif"))
# small_threat_richness <- brick(paste0(p_iucn_dev, "/", richness_names[8], ".tif"))

# ------------------------------------------------------------------------------------
```

```{r bilinear_and_coarser_fasterize}
# testing the bilinear interpolation method
# & testing directly fasterizing into a coarser resolution msk raster 

raster_rescaled <- raster::aggregate(vert_r$all_richness$mam, fact = 110, fun = mean)
mam_110_bilinear <- disaggregate(raster_rescaled, fact = 110, method = 'bilinear') %>%
  crop(extent(msk)) %>% raster::mask(msk)

plot(vert_r$all_richness$mam)
plot(raster_rescaled)
plot(mam_110_bilinear)

# testing directly fasterizing into a coarser resolution msk raster 
msk_110 <- raster::aggregate(msk, fact = 110, fun = mean)
msk_110 <- msk_110 %>% crop(extent(msk))
plot(msk_110)
mask_filled <- msk_110
  mask_filled[is.na(mask_filled)] <- 0 # replace NAs with 0s
plot(mask_filled)

mam_richness_110_manual <- 
  fasterize(mam_list$reprojected_all, mask_filled, field = NULL, fun = 'sum')

plot(mam_richness_110_manual)
plot(vert_r$all_richness$mam_110)

```





```{r vert-plots}

pdf(file = fp(p_plots,"vert_plots.pdf"), width = 9, height = 8)
#png(file = fp(p_plots,"Estes-plots_test.png"), width = 8, height = 9, units = "in", res = 100)
par(mfrow=c(4,4), mar=c(1,2,2,1), oma=c(1,1,1,1), cex.main=1) # setting the plot parameters. 

plot(vert_all_richness_brick$mam, box = F, axes = F, main = "Mammals: All sp."); plot(msk_shp, add=TRUE)
plot(vert_all_richness_brick$bird, box = F, axes = F, main = "Birds: All sp.", zlim = c(300,500)); plot(msk_shp, add=TRUE)
plot(vert_all_richness_brick$amp, box = F, axes = F, main = "Amphibians: All sp."); plot(msk_shp, add=TRUE)
plot(vert_all_richness_brick$rep, box = F, axes = F, main = "Reptiles: All sp."); plot(msk_shp, add=TRUE)

plot(vert_threat_richness_brick$mam, box = F, axes = F, main = "Mammals: Threatened sp."); plot(msk_shp, add=TRUE)
plot(vert_threat_richness_brick$bird, box = F, axes = F, main = "Birds: Threatened sp."); plot(msk_shp, add=TRUE)
plot(vert_threat_richness_brick$amp, box = F, axes = F, main = "Amphibians: Threatened sp."); plot(msk_shp, add=TRUE)
plot(vert_threat_richness_brick$rep, box = F, axes = F, main = "Reptiles: Threatened sp."); plot(msk_shp, add=TRUE)

plot(vert_small_richness_brick$mam, box = F, axes = F, main = "Mammals: Small-ranged sp."); plot(msk_shp, add=TRUE)
plot(vert_small_richness_brick$bird, box = F, axes = F, main = "Birds: Small-ranged sp."); plot(msk_shp, add=TRUE)
plot(vert_small_richness_brick$amp, box = F, axes = F, main = "Amphibians: Small-ranged sp."); plot(msk_shp, add=TRUE)
plot(vert_small_richness_brick$rep, box = F, axes = F, main = "Reptiles: Small-ranged sp."); plot(msk_shp, add=TRUE)

plot(vert_small_threat_richness_brick$mam, box = F, axes = F, main = "Mammals: Small-ranged or Threatened sp."); plot(msk_shp, add=TRUE)
plot(vert_small_threat_richness_brick$bird, box = F, axes = F, main = "Birds: Small-ranged or Threatened sp."); plot(msk_shp, add=TRUE)
plot(vert_small_threat_richness_brick$amp, box = F, axes = F, main = "Amphibians: Small-ranged or Threatened sp."); plot(msk_shp, add=TRUE)
plot(vert_small_threat_richness_brick$rep, box = F, axes = F, main = "Reptiles: Small-ranged or Threatened sp."); plot(msk_shp, add=TRUE)
dev.off()


```

```{r resolution-plots}
pdf(file = fp(p_plots,"resolution_plots.pdf"), width = 9, height = 6)
#png(file = fp(p_plots,"Estes-plots_test.png"), width = 8, height = 9, units = "in", res = 100)
par(mfrow=c(3,4), mar=c(1,2,2,1), oma=c(1, 1, 1, 1), cex.main=1) # setting the plot parameters. 

plot(vert_all_richness_brick$norm_sum, box = F, axes = F, main = "All vert. sp. richness"); plot(msk_shp, add=TRUE)
plot(vert_threat_richness_brick$norm_sum, box = F, axes = F, main = "Threatened vert. sp. richness"); plot(msk_shp, add=TRUE)
plot(vert_small_richness_brick$norm_sum, box = F, axes = F, main = "Small-ranged vert. sp. richness"); plot(msk_shp, add=TRUE)
plot(vert_small_threat_richness_brick$norm_sum, box = F, axes = F, main = "Small-ranged or threatened vert. sp. richness"); plot(msk_shp, add=TRUE)


plot(vert_all_richness_brick$norm_sum_10, box = F, axes = F, main = "10 km x 10 km"); plot(msk_shp, add=TRUE)
plot(vert_threat_richness_brick$norm_sum_10, box = F, axes = F, main = "10 km x 10 km"); plot(msk_shp, add=TRUE)
plot(vert_small_richness_brick$norm_sum_10, box = F, axes = F, main = "10 km x 10 km"); plot(msk_shp, add=TRUE)
plot(vert_small_threat_richness_brick$norm_sum_10, box = F, axes = F, main = "10 km x 10 km"); plot(msk_shp, add=TRUE)

plot(vert_all_richness_brick$norm_sum_110, box = F, axes = F, main = "110 km x 110 km"); plot(msk_shp, add=TRUE)
plot(vert_threat_richness_brick$norm_sum_110, box = F, axes = F, main = "110 km x 110 km"); plot(msk_shp, add=TRUE)
plot(vert_small_richness_brick$norm_sum_110, box = F, axes = F, main = "110 km x 110 km"); plot(msk_shp, add=TRUE)
plot(vert_small_threat_richness_brick$norm_sum_110, box = F, main = "110 km x 110 km", axes = F); plot(msk_shp, add=TRUE)
dev.off()
```


Note that the filtered lists (i.e. mam_list) are the ones I should use for this table. They've been filtered based on presence, origin, seasonal, etc., whereas the mam_zambia sf files haven't. 

```{r species-occurence-table}
load(file = fp(p_datnew, "vert_lists.RData"), verbose = TRUE)

# < when odd number of rows (mam), but <= for even rows (everything else)
mam_list$filtered_all %>%
  filter(range_size_quantile < 0.25)

drop.levels(filter(mam_list$filtered_all, range_size_quantile < 0.25)$binomial)

load(file = fp(p_datnew, "1_IUCN_dev/vert_zambia_summaries.RData"))


# number of species in various categories for Zambia. 
names(mam_zambia)
mam_zambia %>%
  st_drop_geometry() %>%
  filter(presence == 1,
         origin %in% c(1, 2), 
         seasonal %in% c(1, 2, 3),
         marine == "False", 
         !category %in% c("EW", "EX")) %>%
  #filter(category %in% c("CR", "EN", "VU")) %>%
  #filter(range_size_quantile <= 0.5) %>% # if even number of species, then <=, otherwise <
  #filter(range_size_quantile_zambia <= 0.5) %>% # median Zambian range
  filter(category %in% c("CR", "EN", "VU") | range_size_quantile < 0.5) %>%
  .$binomial %>% unique() %>% length()

mam_list$filtered_all %>% filter(binomial == "Loxodonta africana") %>% st_geometry() %T>% plot()

length(unique(mam_list$filtered_all$binomial))# 252
length(unique(mam_list$filtered_threat$binomial)) # 11
length(unique(mam_list$filtered_small$binomial)) # 17
length(unique(mam_list$filtered_threat_small$binomial)) #26
length(unique(mam_list$filtered_small_zam$binomial)) # 126 species
length(unique(filter(mam_list$filtered_all, range_size_quantile < 0.25)$binomial)) # 9, for just the smallest 25% of ranges in Zambia

length(unique(mam_list$filtered_small_zam$binomial)) # 126 species

length(unique(bird_list$filtered_all$binomial)) # 738
length(unique(bird_list$filtered_threat$binomial)) # 20
length(unique(bird_list$filtered_small$binomial)) # 67
length(unique(bird_list$filtered_threat_small$binomial)) # 82
length(unique(bird_list$filtered_small_zam$binomial)) # 369 species
length(unique(filter(bird_list$filtered_all, range_size_quantile < 0.25)$binomial)) # 12 for just the smallest 25% of ranges in Zambia

length(unique(amp_list$filtered_all$binomial)) # 94
length(unique(amp_list$filtered_threat$binomial)) # 1
length(unique(amp_list$filtered_small$binomial)) # 3
length(unique(amp_list$filtered_threat_small$binomial)) # 3
length(unique(amp_list$filtered_small_zam$binomial)) # 47 species
length(unique(filter(amp_list$filtered_all, range_size_quantile < 0.25)$binomial)) # 0, for just the smallest 25% of ranges in Zambia


length(unique(rep_list$filtered_all$binomial)) # 37
length(unique(rep_list$filtered_threat$binomial)) # 3
length(unique(rep_list$filtered_small$binomial)) # 3
length(unique(rep_list$filtered_threat_small$binomial)) # 6
length(unique(rep_list$filtered_small_zam$binomial)) # 18 species
length(unique(filter(rep_list$filtered_all, range_size_quantile < 0.25)$binomial)) # 0, for just the smallest 25% of ranges in Zambia

species_occurrence <- data.frame(
  taxa = c("mammals", "birds", "amphibians", "reptiles"),
  all_sp = c(252, 738, 94, 37),
  threat_sp = c(11, 20, 1, 3),
  small_ranged_sp = c(17, 67, 3, 3),
  small_ranged_threat_sp = c(26, 82, 3, 6))


ggpubr::ggtexttable(species_occurrence, rows = NULL)
```


Combining all four rasters into a single layer for use in the tradeoff model.
```{r}
# fancy, combining all the polygons prior to rasterizing them.
names(mam_list$reprojected_sf)
names(bird_list$reprojected_sf)
names(amp_list$reprojected_sf)
names(rep_list$reprojected_sf)
ncell(mam_list$reprojected_sf)
ncell(bird_list$reprojected_sf)
ncell(amp_list$reprojected_sf)
ncell(rep_list$reprojected_sf)

mam_pre_merge <- mam_list$reprojected_sf %>%
  mutate(family_name = NA, common_name = NA) %>%
  select(id_no, binomial, presence, origin, seasonal, compiler, citation, dist_comm, tax_comm, 
         kingdom, phylum, class, order_, family, family_name, genus, common_name, category, 
         marine, terrestial, freshwater, key)

amp_pre_merge <- amp_list$reprojected_sf %>% 
  mutate(family_name = NA, common_name = NA) %>%
  select(id_no, binomial, presence, origin, seasonal, compiler, citation, dist_comm, tax_comm, 
         kingdom, phylum, class, order_, family, family_name, genus, common_name, category, 
         marine, terrestial, freshwater, key)

rep_pre_merge <- rep_list$reprojected_sf %>%
  mutate(family_name = NA, common_name = NA) %>%
  select(id_no, binomial, presence, origin, seasonal, compiler, citation, dist_comm, tax_comm, 
         kingdom, phylum, class, order_, family, family_name, genus, common_name, category, 
         marine, terrestial, freshwater, key)

bird_pre_merge <- bird_list$reprojected_sf %>% 
  mutate(class = "AVES", genus = NA, kingdom = NA, phylum = NA, 
         marine = NA, terrestial = NA, freshwater = NA) %>%
  rename(id_no = SISID,
         # category = RedListCategory, presence = PRESENCE, origin = ORIGIN, seasonal = SEASONAL
         binomial = SCINAME, source = SOURCE, compiler = COMPILER, citation = CITATION, dist_comm = DIST_COM, 
         tax_comm = TAX_COM, order_ = Order_, family = FamilyName, family_name = Family, 
         common_name = CommonName, geometry = Shape) %>%
  select(id_no, binomial, presence, origin, seasonal, compiler, citation, dist_comm, tax_comm, 
         kingdom, phylum, class, order_, family, family_name, genus, common_name, category, 
         marine, terrestial, freshwater, key)

vert_merge <- rbind(mam_pre_merge, bird_pre_merge, amp_pre_merge, rep_pre_merge)
vert_merge %>% as_tibble()

# cc_make_raster vertebrates --- --- --- ---
vert_list <- cc_make_raster(input_sf = vert_merge, run_filter = FALSE, run_clip = FALSE, run_reproject = FALSE)
vert_zambia_r_test <- vert_list$output_raster

# Test that it's the same as the original rasters all added together. 
vert_add <- mam_zambia_threat_richness + bird_zambia_threat_richness + amp_zambia_threat_richness + rep_zambia_threat_richness
plot(vert_add)
plot(vert_zambia_r_test)
plot(vert_add - vert_zambia_r_test); freq(vert_add - vert_zambia_r_test)

rm(vert_zambia_r_test)
rm(vert_add)


vert_zambia_threat_richness <- vert_list$output_raster
plot(vert_zambia_threat_richness)
ncell(vert_zambia_threat_richness)
ncell(vert_zambia_threat_richness[!is.na(vert_zambia_threat_richness)])
ncell(msk[!is.na(msk)])
ncell(vert_add[!is.na(vert_add)])

# `cc_write_reload_raster` --------------------------------------
vert_zambia_threat_richness <- cc_write_reload_raster(vert_zambia_threat_richness, "vert_zambia_threat_richness", p_iucn_dev)
vert_zambia_threat_richness <- cc_write_reload_raster(vert_zambia_threat_richness, "vert_zambia_threat_richness", p_final_inputs)
```


Meta-data about the files created above. 
```{r}
####################
# threatened mammal terrestrial species richness
####################
mam_terr_threat <- st_read(fp(p_iucn_dev,"mam_terr_threat.shp")) # subset of mammal IUCN dataset, filtering by presence, origin, threatenedness, terrestrial, and full species. This recreates the Laurance et al. 2014 global dataset, though it includes near threatened (NT) species, not just threatened, vulnerable, and endangered species.
mam_terr_threat_richness <- raster(fp(p_iucn_dev,"mam_terr_threat_richness.tif")) # global richness map created using fasterize, 1 km resolution
mam_zambia_terr_threat_richness <- raster(fp(p_iucn_dev,"mam_zambia_terr_threat_richness.tif")) # richness map for threatened terrestrial mammal species, in Zambia, 1 km resolution
mam_terr_threat_richness_10km <- raster(fp(p_iucn_dev,"mam_terr_threat_richness_10km.tif")) # same as above, but 10 km resolution
mam_zambia_terr_threat_richness_10km <- raster(fp(p_iucn_dev,"mam_zambia_terr_threat_richness_10km.tif")) # same as above, but 10 km resolution
mam_terr_threat_richness_110km <- raster(fp(p_iucn_dev,"mam_terr_threat_richness_110km.tif")) # same as above, but 110 km resolution
mam_zambia_terr_threat_richness_110km <- raster(fp(p_iucn_dev,"mam_zambia_terr_threat_richness_110km.tif")) # same as above, but 110 km resolution


mam_terr_all_richness
mam_terr_small_richness

```


# 2. Plant Richness
"We used data on the estimated number of vascular plant species per terrestrial Ecoregion7 to assess global patterns of floristic diversity. We adjusted the values to account for varying Ecoregion area, as recommended8, using the formula S=CAz, where S=estimated species richness, C=a fitted constant, A=Ecoregion area, and z=slope of the log species-log area relationship. A z value of 0.24 was determined empirically by assessing the log area-log species richness relationship across all Ecoregions."
They cite: 
7. Kier, G. et al. Global patterns of plant diversity and floristic knowledge. J. Biogeogr. 32, 1107-1116 (2005). 
8. Moore, J. et al. Integrating costs into conservation planning across Africa. Biol. Conserv. 117, 343-350. (2004).

```{r plants-start}
plants <- st_read("/Users/christophercrawford/Google Drive/_Projects/data/Bd/Plant Richness (Kier et al. 2005)/data/commondata/data0/wwf_ecos_plant_spcs.shp")
plants_1 <- st_read("/Users/christophercrawford/Google Drive/_Projects/data/Bd/Number of Plant Species by Terrestrial Ecoregion/Number of Plant Species by Terrestrial Ecoregion/commondata/data0/wwf_ecos_plant_spcs.shp")

object_size(plants)
st_crs(plants)

load(file = fp(p_plants_dev, "plants_valid.RData"), verbose = TRUE) # this includes plants, which has been made valid.

load(file = fp(p_plants_dev, "plants_zambia.RData"), verbose = TRUE)
load(file = fp(p_plants_dev, "plants_zambia_4deg_buff.RData"), verbose = TRUE)
```

```{r plants-valid}
plants <- cc_make_valid(plants)
save(plants, file = fp(p_plants_dev, "plants_valid.RData")) 
load(file = fp(p_plants_dev, "plants_valid.RData"), verbose = TRUE) # this includes plants, which has been made valid.
levels(plants$post_fix_reasons)
```

```{r adj-richness}
# Adjust species richness by area -------------------------------
# --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- ---
# now, adjust the plant species richness per ecoregion to account for area affects. Laurance et al. 2014 followed methods from Moore et al. 2004, which utilized the species area relationship (S = cA^z), and a z value of 0.24 ("determined empirically by assessing the log area-log species richness relationship across all ecoregions." - Laurance et al. 2014, supplemental information.)
# So, what I want to do is create a new variable, w
plants <- plants %>%
  mutate(adj_richness = plant_spcs/(AREA^0.24)) #%>%
#  select(ECO_NAME, AREA, plant_spcs, adj_richness)

#test <- 
  plants %>%
  filter(plant_spcs >= 0) %>%
  st_intersection(msk_sf_ll_4deg_buff) %>% st_cast("MULTIPOLYGON") %>%
  #st_transform(aaeac) %>%
  st_geometry() %T>%
  plot()

# plot(test["plant_spcs"]) # or, plot(test, max.plot = 1)

# save prepped plants file

save(plants, file = "/Users/christophercrawford/Google Drive/_Projects/Zambia/agroEcoTradeoff/external/data_new/2_plants_dev/plants_prepped.RData") # contains plants_valid (71.3 mb), but prepped by cc_make_valid(), and adding a column for adj_richness. 
```

```{r plants-clip}
# ---- subset to Zambia
plants_zambia <- plants %>%
  st_intersection(., st_union(msk_sf_ll_noholes)) %>%
  #st_cast("MULTIPOLYGON") #%>% # also seems to work fine.
  st_collection_extract(., "POLYGON") # extract only polygons
plot(plants_zambia$geometry)


save(plants_zambia, file = "/Users/christophercrawford/Google Drive/_Projects/Zambia/agroEcoTradeoff/external/data_new/2_plants_dev/plants_zambia.RData") # includes plants_zambia, which has had a column for adj_richness added, been prepped, and then clipped to zambia


# clip to buffer
plants_zambia_4deg_buff <- plants %>%
  st_intersection(., st_union(msk_sf_ll_4deg_buff)) %>%
  st_collection_extract(., "POLYGON")
plot(plants_zambia_4deg_buff$geometry)
save(plants_zambia_4deg_buff, file = "/Users/christophercrawford/Google Drive/_Projects/Zambia/agroEcoTradeoff/external/data_new/2_plants_dev/plants_zambia_4deg_buff.RData") # includes plants_zambia, which has had area adj richness added, been prepped, and then clipped to zambia.

```


```{r manual-rasterization}
library(spatialEco)
norm1 <- normalize(plants_r)
norm2 <- raster.transformation(plants_r, trans = "norm") # checks out - normalize works as it should.
plot(norm1 - norm2); freq(norm1 - norm2, digits = 2)



# rasterize --- --- --- --- --- --- --- --- --- --- --- --- --- ---
plants_r <- plants %>%
#plants_r_adj <- plants %>%
  filter(plant_spcs >= 0) %>%
  st_intersection(st_union(africa)) %>% st_cast("MULTIPOLYGON") %>%
  st_transform(aaeac) %>%
  fasterize(., extend(msk, extent(.), value = 0), field = "plant_spcs", fun = 'last') #  raster(., res = 1)
#  fasterize(., extend(msk, extent(.), value = 0), field = "adj_richness", fun = 'last') #  raster(., res = 1)

plants_r <- plants_r %>% crop(extent(msk)) 
plants_r[is.na(plants_r)] <- 0 # replace NAs with 0s
plants_r <- plants_r %>% raster::mask(msk) # masking, in order to set all cells in hotspots_r to NA where msk is NA.



ncell(vert_zambia_threat_richness)
ncell(vert_zambia_threat_richness[!is.na(vert_zambia_threat_richness)])
ncell(msk[!is.na(msk)])
ncell(vert_add[!is.na(vert_add)])


plot(s2)
plot(s2_ZA_resample)
plot(plants_r)
cellStats(plants_r, "min")

plot(normalize(plants_r))
plants_r[plants_r == 0] <- -100
plot(plants_r)
freq(normalize(plants_r), value = 0)
freq(plants_r, digits = 10)
ncell()

plot(normalize(plants_r_adj))
plot(plants_list$output_raster)
ncell(plants_list$output_raster)



plot(plants_r)
plot(normalize(plants_r))
plot(s2)
freq(s2, digits = 2)
values(s2, row = 120)

```


```{r}
run_clip <- TRUE
clip_area <- msk_sf_ll_noholes
input_sf <- amp_valid

mask_filled <- msk
mask_filled[is.na(mask_filled)] <- 0 # replace NAs with 0s

msk_sf_ll_noholes
class(clip_area)

extent(msk_shp)

template_raster_extent <- 
    {if (run_clip) clip_area else input_sf} %>%
    st_transform(., aaeac) %>%
    {if (class(x)[1] == "sf") as_Spatial(.) else .} %>%
    extent(.)

template_raster <- extend(mask_filled, template_raster_extent, value = 0)


template_raster2 <- extend(mask_filled, value = 0,
                            extent(
                              as_Spatial(
                                st_transform(
                                  {if (run_clip) clip_area else input_sf}, aaeac)
                                )
                              )
                            )


```


```{r plants-final}
# `cc_make_raster` ---------------------------------------------
plants_list <- plants %>% 
  filter(plant_spcs >= 0) %>%
  cc_make_raster(input_sf = ., run_filter = FALSE, clip_area = msk_sf_ll_noholes, 
              fasterize_field = "plant_spcs", fasterize_fun = 'last', 
              run_mask = FALSE, prep_zambia = FALSE)

plot(plants_list$output_raster)

# optional: Zambia only, to run more quickly:

# plants_list <- plants_zambia %>% 
#   filter(plant_spcs >= 0) %>%
#   cc_make_raster(input_sf = ., run_filter = FALSE, run_clip = FALSE, 
#                  clip_area = msk_sf_ll_noholes, 
#                  fasterize_field = "plant_spcs", fasterize_fun = 'last', 
#                  run_mask = FALSE, run_extract = FALSE, prep_zambia = FALSE)


# spot checking, filling NA values around Lake Tanganyika ----------------------------------------------------
ext_tanganyika <- extent(c(546380.9, 670784.1, -1062930, -965184.5))

plot(plants_list$output_raster, ext = ext_tanganyika)
plants %>%
  st_geometry() %>%
  st_transform(aaeac) %T>%
  plot(border = "red",
       #xlim = ext_tanganyika[1:2], ylim = ext_tanganyika[3:4],
       add = T)

plot(msk_sf$geometry, add = T)

plants_zambia_r <- plants_list$output_raster
plot(plants_zambia_r, ext = ext_tanganyika)
ext_nv1 <- extent(c(552008.4, 592765.9, -1023444, -972497)) # drawExtent(show=T, col = "red")
plot(plants_zambia_r, ext = ext_nv1)

# fill NAs with 1000, the value of the closest adjancent ecoregion, and then mask by msk
plants_zambia_r[ext_nv1][is.na(plants_zambia_r[ext_nv1])] <- 1000
plants_zambia_r <- raster::mask(plants_zambia_r, msk)

# then fill all NAs with 3800, the value of the other closest ecoregion, and mask again. This should fix things. 
plants_zambia_r[ext_tanganyika][is.na(plants_zambia_r[ext_tanganyika])] <- 3800
plants_zambia_r <- raster::mask(plants_zambia_r, msk)
plot(plants_zambia_r, ext = ext_tanganyika)


ncell(msk)
ncell(plants_zambia_r)
ncell(msk[!is.na(msk)])
ncell(plants_zambia_r[!is.na(plants_zambia_r)])

test <- plants_list$output_raster %>%
  raster::mask(., msk)
ncell(test[!is.na(test)])




# ---------------------------------------------------------------------------

# save list, etc.
save(plants_list, file = "/Users/christophercrawford/Google Drive/_Projects/Zambia/agroEcoTradeoff/external/data_new/2_plants_dev/plants_list.RData")

# `cc_write_reload_raster` --------------------------------------
plants_zambia_r <- cc_write_reload_raster(plants_zambia_r, "plants_zambia_r", p_plants_dev)
plants_zambia_r <- cc_write_reload_raster(plants_zambia_r, "plants_zambia_r", p_final_inputs)
```

```{r species-area-exponent}
# check areas
summary(plants$AREA)
names(plants)
area_test <- plants %>%
  st_transform(crs_mollweide) %>%  # convert to moll projection, then calculate area from polygons in the Albers equal area projection
  mutate(., area_km2 = st_area(.["geometry"]) %>% units::set_units(km^2))

area_test %>%
  select(ECO_NAME, AREA, area_km2) %>%
  as_tibble()

plot(area_test[3,]$geometry, add = TRUE, col = "red", border = "red",  lwd = 2)
plot(st_transform(world$geometry, crs_mollweide), add = F)

plot(msk, col = viridis(100))

#####
# Now group by species, and calculate the sum of the various polygons, i.e. the total range area for each species. 
## due to polygons with self-intersections, first I implement a buffer of distance 0, to resolve that. 
area_summary_test <- area_test %>%
  group_by(ECO_NAME) %>% 
  dplyr::summarize(total_area_old = sum(AREA, na.rm = TRUE), 
                   total_area_new = sum(area_km2, na.rm = TRUE),
                   plant_spcs = min(plant_spcs),
                   n_polygons = n()) %>%
  st_drop_geometry()

View(area_summary_test)

dat <- area_summary_test %>%
  filter(plant_spcs >= 0)

plot(log(area_summary_test$plant_spcs) ~ log(area_summary_test$total_area_new))
plot(area_summary_test$plant_spcs ~ log(area_summary_test$total_area_old))
plot()


plants %>%
  arrange(ECO_NAME) %>%
  st_drop_geometry() %>%
  select(ECO_NAME, plant_spcs) %>%
  View()

summary(area_summary_test$plant_spcs)
names(plants)


exponential.model <- lm(log(plant_spcs) ~ log(total_area_old), data = dat)
summary(exponential.model)
plot(exponential.model)
```


# 4. BD hotspots

```{r hotspots}
###########
# read data
hotspots_sf <- st_read(fp(p_dat_hab, "CI_bd_hotspots_2011_zip/data/commondata/data0/hotspots_2011_polygons.shp"))
hotspots_sf <- cc_make_valid(hotspots_sf) # my created function, implementing st_make_valid with pre and post st_is_valid checks in columns
mapView(hotspots_sf)
plot(st_geometry(hotspots_sf))
names(hotspots_sf)

hotspots_af_test <- st_intersection(hotspots_sf, st_union(africa)) # this returns the geometries where the two sf objects overlap. The resulting object retains attributes from the feature listed first after st_intersection() 
plot(st_union(africa), border = "blue")
plot(hotspots_af_test$geometry, add = T, col = "red")
hotspots_africa <- hotspots_sf %>% st_intersection(st_union(africa)) 
  #filter(TYPE == "hotspot_area") %>% # alternatively, you can filter by hotspot_area, then by name.
  #filter(NAME %in% levels(hotspots_sf$NAME)[c(3, 8, 10, 12, 14, 18, 20, 21, 30)]) 

plot(st_union(africa), add = FALSE, border = "black")
hotspots_africa %>% st_geometry() %T>% plot(add = TRUE, border="red")
hotspots_sf %>% filter(NAME == "Eastern Afromontane") %>% st_geometry() %T>% plot(border="blue", add = TRUE)
hotspots_africa %>% filter(NAME == "Eastern Afromontane") %>% st_geometry() %T>% plot(border="green", add = TRUE)


###########
# run pipe
hotspots_africa_r <- 
  hotspots_sf %>% # take the data, THEN
  filter(TYPE == "hotspot_area") %>% # filter by hotspot_area
  filter(NAME %in% levels(hotspots_sf$NAME)[c(3, 8, 10, 12, 14, 18, 20, 21, 30)]) %>% # then filter specifically to only include 9 African hotspots
  st_transform(aaeac) %>% # then reproject
  fasterize(., extend(msk, extent(.), value = 0), fun = 'last')
  #fasterize(., raster(., res = 1000), fun = 'last') # then rasterize.

hotspots_africa_r <- cc_write_reload_raster(hotspots_africa_r, "hotspots_africa_r", p_hotspot_dev)

# writeRaster(hotspots_africa_r, fp(p_hotspot_dev,"hotspots_africa_r.tif"), overwrite=TRUE)
# rm(hotspots_africa_r)
# hotspots_africa_r <- raster(fp(p_hotspot_dev,"hotspots_africa_r.tif"))
plot(hotspots_africa_r, col = viridis(100))


###########
## final prep for toff
###########
hotspots_zambia_r <- crop(hotspots_africa_r, extent(msk))
hotspots_zambia_r[is.na(hotspots_zambia_r)] <- 0 # replace NAs with 0s
hotspots_zambia_r <- raster::mask(hotspots_zambia_r, msk) # masking, in order to set all cells in hotspots_r to NA where msk is NA.

plot(hotspots_zambia_r, col = viridis(100))


## spot checking - need to fill in the missing spot at Lake Tanganyika:
# zoom in on an extent with values to update:
plot(hotspots_zambia_r, col = viridis(100))
ext_newvals <- drawExtent()
plot(hotspots_zambia_r, col = viridis(100), ext = ext_newvals)
plot(tanganyika, add = T) # check out how Lake Tanganyika looks overlaid.

hotspots_zambia_r[ext_newvals][hotspots_zambia_r[ext_newvals] == 0] <- 1 # Select values of hotspots_zambia_r in the new extent, then select those values in that extent that are equal to 0, and update them to 1
plot(hotspots_zambia_r, col = viridis(100), ext = ext_newvals)
plot(hotspots_zambia_r, col = viridis(100)) # looking good!

hotspots_zambia_r <- cc_write_reload_raster(hotspots_zambia_r, "hotspots_zambia_r", p_hotspot_dev)

# writeRaster(hotspots_zambia_r, fp(p_hotspot_dev,"hotspots_zambia_r.tif"), overwrite=TRUE)
# rm(hotspots_zambia_r)

# ------------------------------------------------------
# Resulting raster files
# ------------------------------------------------------
hotspots_africa_r <- raster(fp(p_hotspot_dev,"hotspots_africa_r.tif")) # all African biodiversity hotspots
hotspots_zambia_r <- raster(fp(p_hotspot_dev,"hotspots_zambia_r.tif")) # Zambia raster - final, with 0s and 1s only.

plot(hotspots_africa_r, col = viridis(100))
plot(hotspots_zambia_r, col = viridis(100)) # looking good!

plot(s4, col = viridis(100)) # Laurance hotspots layer for comparison.
plot(msk_shp, add = T)
```

```{r hotspots-final}
# `cc_make_raster` ---------------------------------------------
hotspots_list <- cc_make_raster(input_sf = hotspots_sf, fasterize_fun = 'last',
                    run_filter = FALSE, 
                    run_clip = TRUE, clip_area = africa,
                    prep_zambia = TRUE)
hotspots_zambia_r_test <- hotspots_list$output_raster

# Test that it's the same as the original raster.
plot(hotspots_zambia_r_test, col = viridis(100))
plot(hotspots_zambia_r, col = viridis(100))

plot(hotspots_zambia_r_test - hotspots_zambia_r)
freq(hotspots_zambia_r_test - hotspots_zambia_r) # checks out (after doing the spot checking.
freq(hotspots_zambia_r_test) # checks out.
freq(hotspots_zambia_r) # checks out.

rm(hotspots_zambia_r_test)


hotspots_zambia_r <- hotspots_list$output_raster


## spot checking - need to fill in the missing spot at Lake Tanganyika:
# zoom in on an extent with values to update:
plot(hotspots_zambia_r, col = viridis(100))
ext_newvals <- drawExtent()
plot(hotspots_zambia_r, col = viridis(100), ext = ext_newvals)
plot(tanganyika, add = T) # check out how Lake Tanganyika looks overlaid.

hotspots_zambia_r[ext_newvals][hotspots_zambia_r[ext_newvals] == 0] <- 1 # Select values of hotspots_zambia_r in the new extent, then select those values in that extent that are equal to 0, and update them to 1
plot(hotspots_zambia_r, col = viridis(100), ext = ext_newvals)
plot(hotspots_zambia_r, col = viridis(100)) # looking good!


# `cc_write_reload_raster` --------------------------------------
hotspots_zambia_r <- cc_write_reload_raster(hotspots_zambia_r, "hotspots_zambia_r", p_hotspot_dev)
hotspots_zambia_r <- cc_write_reload_raster(hotspots_zambia_r, "hotspots_zambia_r", p_final_inputs)
```


```{r explore-data}
# load the data using rgdal's readOGR() function
ogrinfo(fp(p_dat_hab, "CI_bd_hotspots_2011_zip/data/commondata/data0/hotspots_2011_polygons.shp"))
hotspots <- readOGR(fp(p_dat_hab, "/CI_bd_hotspots_2011_zip/data/commondata/data0/hotspots_2011_polygons.shp"))

## checking the data out
class(hotspots)
mapview(hotspots) # viewing an interactive map of the hotspots in html window
plot(hotspots)

levels(hotspots$NAME)
## Subset Afromontane | creating a subset to test the rasterizing function on
Afromontane <- subset(hotspots, NAME == "Eastern Afromontane")
test <- subset(hotspots, NAME == "Maputaland-Pondoland-Albany")
plot(test)


levels(hotspots$NAME)[c(3, 8, 10, 12, 14, 18, 20, 21, 30)] # the African hotspots to subset
africa_hotspots <- subset(hotspots, 
                          (NAME == "Cape Floristic Region") |
                          (NAME == "Coastal Forests of Eastern Africa") |
                          (NAME == "Eastern Afromontane") |
                          (NAME == "Guinean Forests of West Africa") |
                          (NAME == "Horn of Africa") |
                          (NAME == "Madagascar and the Indian Ocean Islands") |
                          (NAME == "Maputaland-Pondoland-Albany") |
                          (NAME == "Mediterranean Basin") |
                          (NAME == "Succulent Karoo")
                          )
plot(africa_hotspots)
africa_hotspots_terr <- subset(africa_hotspots, TYPE == "hotspot_area")
plot(africa_hotspots_terr)


#### not necessary
# reading the file in using sf
htspt <- read_sf(fp(p_dat_hab, "/CI_bd_hotspots_2011_zip/data/commondata/data0/hotspots_2011_polygons.shp"))
class(htspt)
AF2 <- subset(htspt, NAME == "Atlantic Forest")
plot(AF2["NAME"])
#####


# checking out Afromontane_WGS
Afromontane
plot(Afromontane)
Afromontane@bbox # this is the extent of the polygon for the Eastern Afromontane area
msk_shp@bbox # totally different, since they're in a different projection
crs(msk_shp)
crs(Afromontane)
```


```{r fasterize-hotspots}
install.packages("fasterize")
library(fasterize)

###########
#### load in as sf
hotspots_sf <- st_read(fp(p_dat_hab, "CI_bd_hotspots_2011_zip/data/commondata/data0/hotspots_2011_polygons.shp"))
mapView(hotspots_sf)


###########
#### subset
levels(hotspots_sf$NAME)[c(3, 8, 10, 12, 14, 18, 20, 21, 30)] # the African hotspots to subset

Afromontane_sf <- hotspots_sf[hotspots_sf$NAME == "Eastern Afromontane", ]
plot(Afromontane_sf["NAME"])

names(hotspots_sf)
mapView(filter(hotspots_sf, NAME == "Mountains of Southwest China"))
mapView(filter(hotspots_sf, TYPE == "hotspot_area"))

hotspots_sf$TYPE
hotspots_sf_terr <- subset(hotspots_sf, TYPE == "hotspot_area")
plot(hotspots_sf_terr["NAME"])

test <- filter(hotspots_sf, NAME %in% levels(hotspots_sf$NAME)[c(3, 8, 10, 12, 14, 18, 20, 21, 30)]) # the African hotspots to subset
plot(test["NAME"])

c("Cape Floristic Region", "Coastal Forests of Eastern Africa", "Eastern Afromontane", "Guinean Forests of West Africa", "Horn of Africa", "Madagascar and the Indian Ocean Islands", "Maputaland-Pondoland-Albany", "Mediterranean Basin",  "Succulent Karoo")
africa_hotspots_sf <- subset(hotspots_sf, 
                          (NAME == "Cape Floristic Region") |
                          (NAME == "Coastal Forests of Eastern Africa") |
                          (NAME == "Eastern Afromontane") |
                          (NAME == "Guinean Forests of West Africa") |
                          (NAME == "Horn of Africa") |
                          (NAME == "Madagascar and the Indian Ocean Islands") |
                          (NAME == "Maputaland-Pondoland-Albany") |
                          (NAME == "Mediterranean Basin") |
                          (NAME == "Succulent Karoo")
                          )

africa_hotspots_sf_terr <- subset(hotspots_sf_terr, 
                          (NAME == "Cape Floristic Region") |
                          (NAME == "Coastal Forests of Eastern Africa") |
                          (NAME == "Eastern Afromontane") |
                          (NAME == "Guinean Forests of West Africa") |
                          (NAME == "Horn of Africa") |
                          (NAME == "Madagascar and the Indian Ocean Islands") |
                          (NAME == "Maputaland-Pondoland-Albany") |
                          (NAME == "Mediterranean Basin") |
                          (NAME == "Succulent Karoo")
                          )
plot(africa_hotspots_sf["NAME"])
plot(africa_hotspots_sf_terr["NAME"])

#alternatively, you can just plot the geometries of the sf objects
plot(st_geometry(africa_hotspots_sf_terr))

# this is convenient because you can add these to existing plot() calls, using add = TRUE
plot(africa_hotspots_r)

plot(st_geometry(africa_hotspots_sf_terr_aea))


###########
#### reproject sf file
africa_hotspots_sf_terr_aea <- st_transform(africa_hotspots_sf_terr, crs(msk_shp))
plot(africa_hotspots_sf_terr_aea["NAME"])

# how different are the files produced in sf than those produced in sp?
africa_hotspots_terr_aea_sf_test <- st_read(fp(p_hotspot_dev,"africa_hotspots_terr_aea.shp"))
head(africa_hotspots_terr_aea_sf_test)
head(africa_hotspots_sf_terr_aea)
plot(africa_hotspots_terr_aea_sf_test["NAME"])

#they plot slightly differently, one with an automatic legend, but i can't quite figure out why.


###########
#### fasterize()
africa_hotspots_r_fast <- fasterize(africa_hotspots_sf_terr_aea, africa_r, fun = 'count') #
plot(africa_hotspots_r_fast)
plot(africa_hotspots_r) # this is the one made from fun = 'last', with the filled Lake Tanganyika.
plot(africa_hotspots_r_fast, ext = ext)
plot(msk_shp, add = T)
plot(msk_shp)
plot(africa_hotspots_r_fast, add = T, ext = extent(msk_shp))
plot(africa_hotspots_terr_aea)


###########
#### converting sf to sp
plot(africa_hotspots_sf_terr_aea["NAME"])

# see https://r-spatial.github.io/sf/reference/coerce-methods.html
africa_hotspots_sf_terr_aea$NAME
test_sp_sf <- as_Spatial(africa_hotspots_sf_terr_aea, IDs = africa_hotspots_sf_terr_aea$NAME)

plot(test_sp_sf)
plot(msk_shp, add = T)


###########
#### write to file
writeRaster(africa_hotspots_r_fast,fp(p_datnew,"africa_hotspots_r_fast.tif"), overwrite=TRUE)
rm(africa_hotspots_r_fast)
africa_hotspots_r_fast <- raster(fp(p_datnew,"africa_hotspots_r_fast.tif"))
```


# 5. Bird habitats (IBAs + EBAs)
Laurance et al. 2014 combined IBAs and EBAs into a single layer
```{r ibas-ebas}
iba_sf <- st_read(fp(p_dat_hab, "Birdlife-IBAs/IBAsGlobal_2019_March_01/IbaGlobal_2019_March_01_POL.shp"))
eba_sf <- st_read(fp(p_dat_hab, "Birdlife-EBAs/EBA/EbaMapGlobal.shp"))
msk_sf <- st_read(fp(p_datnew,"msk.shp"))

iba_sf <- cc_make_valid(iba_sf)
eba_sf <- cc_make_valid(eba_sf)
names(iba_sf)
names(eba_sf)
table(eba_sf$EBADATABAS)
nrow(eba_sf)
levels(eba_sf$EBADATABAS)
levels(eba_sf$EBANAME)


# ------------------------------------------------------
# IBAs
# ------------------------------------------------------
levels(iba_sf$Country) # 240 levels: Zambia is one of them

iba_z <- iba_sf %>%
  filter(Country == "Zambia") %>% # filter by country
  st_transform(crs(msk_shp)) # reproject

african_countries <- levels(iba_sf$Country)[c(3, 6, 23, 29, 35:36, 38, 40, 42:43, 49:51, 54, 61, 65, 67:68, 70, 79:80, 83, 91:92, 110, 117:119, 125:126, 129, 133:134, 142:143, 145, 152:153, 178, 180, 182, 184:185, 191:192, 195, 204, 207, 213, 216, 220, 224, 239:240)] # selection of African countries in IBA sf object.

iba_africa <- iba_sf %>% # all IBAs in Africa
  #filter(Country %in% african_countries) #%>% # filter by african countries
  st_intersection(st_union(africa)) %>% st_cast("MULTIPOLYGON") # alternatively, just clip to African continent
  #st_transform(crs(msk_shp)) # reproject
iba_africa1 <- iba_sf %>% st_intersection(st_union(africa))

plot(st_union(africa))
plot(st_simplify(iba_africa$geometry, dTolerance = 1000, preserveTopology = TRUE), border = "red", add = T)
plot(st_simplify(iba_africa1$geometry, dTolerance = 1000, preserveTopology = TRUE), border = "blue", add = T)


plot(msk_sf$geometry)
tic(); plot(st_simplify(iba_africa$geometry, dTolerance = 1000, preserveTopology = TRUE), border = "red", add = T); toc()


# exploratory plots
plot(s5); plot(msk_shp, add = T) # original Laurance datasets
plot(st_geometry(iba_z), border="red", add = T) # Zambia subset of the IBAs
plot(st_geometry(iba_africa), border="red", add = T) # African IBAs
plot(pas, add = T, col = adjustcolor("dark green", 0.2)) # the adjustcolor command is to set polygon transparency
plot(iba_zambia_r, add = T)

# ------------------------------------------------------
# EBAs
# ------------------------------------------------------
glimpse(eba_sf) # 218 polygons
tic(); plot(st_simplify(eba_sf$geometry, dTolerance = 100000, preserveTopology = TRUE), border = "red"); toc()
names(eba_sf)

eba_africa <- 
  eba_sf %>% # all EBAs in Africa
  st_intersection(st_union(africa)) %>% st_cast("MULTIPOLYGON") #%>%  # using the intersection method
  #st_transform(crs(msk_shp)) # reproject

plot(msk_sf$geometry)
tic(); plot(eba_africa$geometry, border = "blue", add = T); toc()
tic(); plot(st_simplify(eba_africa$geometry, dTolerance = 1000, preserveTopology = TRUE), border = "red", add = T); toc() # in this case, simplifying the polygons actually takes more time than just plotting them outright.

# are there any EBAs in Zambia?
s5_Af_aaeac <- projectRaster(s5_Af, crs = crs(msk))
msk_sf_10kmbuff <- st_buffer(msk_sf, units::set_units(100, km)) # st_buffer's default dist units seem to be in meters.
plot(s5_Af_aaeac, ext = extent(msk_sf_10kmbuff)); plot(msk_shp, add = T)


# -------------------------------
# Pipe and fasterize IBAs
# -------------------------------
iba_africa_r <- 
  iba_sf %>% # all IBAs in Africa
  filter(Country %in% african_countries) %>% # filter by african countries
  #st_intersection(st_union(africa)) %>% st_cast("MULTIPOLYGON") %>%  # using the intersection method
  st_transform(crs(msk_shp)) %>% # reproject
  fasterize(., extend(msk, extent(.), value = 0), fun = 'last') # then rasterize.

eba_africa_r <- 
  eba_sf %>% # all EBAs in Africa
  st_intersection(st_union(africa)) %>% st_cast("MULTIPOLYGON") %>%  # using the intersection method
  st_transform(crs(msk_shp)) %>% # reproject
  fasterize(., extend(msk, extent(.), value = 0), fun = 'last') # then rasterize.

# view results
plot(iba_africa_r, col = viridis(100), ext = extent(msk_shp))
plot(st_geometry(iba_africa), border="red", add = T) # African IBAs
plot(eba_africa_r, col = viridis(100), ext = extent(msk_shp))
plot(st_geometry(eba_africa), border="red", add = T) # African EBAs
plot(msk_shp, add = T)


# save results
iba_africa_r <- cc_write_reload_raster(iba_africa_r, "iba_africa_r", p_IBA_dev)
eba_africa_r <- cc_write_reload_raster(eba_africa_r, "eba_africa_r", p_IBA_dev)


# writeRaster(iba_africa_r, fp(p_IBA_dev,"iba_africa_r.tif"), overwrite=TRUE)
# rm(iba_africa_r)
# iba_africa_r <- raster(fp(p_IBA_dev,"iba_africa_r.tif"))
# 
# writeRaster(eba_africa_r, fp(p_IBA_dev,"eba_africa_r.tif"), overwrite=TRUE)
# rm(eba_africa_r)
# eba_africa_r <- raster(fp(p_IBA_dev,"eba_africa_r.tif"))

###########
## final prep for toff, iba
###########
iba_zambia_r <- crop(iba_africa_r, extent(msk)) # crop to (almost) the right extent
iba_zambia_r[is.na(iba_zambia_r)] <- 0 # replace NAs with 0s
iba_zambia_r <- raster::mask(iba_zambia_r, msk) # masking, in order to set all cells in hotspots_r to NA where msk is NA.
plot(iba_zambia_r); plot(msk_shp, add = T)

iba_zambia_r <- cc_write_reload_raster(iba_zambia_r, "iba_zambia_r", p_IBA_dev)
# writeRaster(iba_zambia_r, fp(p_IBA_dev,"iba_zambia_r.tif"), overwrite=TRUE)
# rm(iba_zambia_r)
# iba_zambia_r <- raster(fp(p_IBA_dev,"iba_zambia_r.tif"))

###########
## final prep for toff, eba
###########
eba_zambia_r <- crop(eba_africa_r, extent(msk)) # crop to (almost) the right extent
eba_zambia_r[is.na(eba_zambia_r)] <- 0 # replace NAs with 0s
eba_zambia_r <- raster::mask(eba_zambia_r, msk) # masking, in order to set all cells in hotspots_r to NA where msk is NA.
plot(eba_zambia_r); plot(msk_shp, add = T)

eba_zambia_r <- cc_write_reload_raster(eba_zambia_r, "eba_zambia_r", p_IBA_dev)
# writeRaster(eba_zambia_r, fp(p_IBA_dev,"eba_zambia_r.tif"), overwrite=TRUE)
# rm(eba_zambia_r)
# eba_zambia_r <- raster(fp(p_IBA_dev,"eba_zambia_r.tif"))

###########
## combining IBA and EBA
###########
iba_eba_zambia_r <- iba_zambia_r + eba_zambia_r
plot(iba_eba_zambia_r) # need to fix the 2s
freq(iba_eba_zambia_r)
iba_eba_zambia_r[iba_eba_zambia_r == 2] <- 1 # replace 2s with 1s

iba_eba_zambia_r <- cc_write_reload_raster(iba_eba_zambia_r, "iba_eba_zambia_r", p_IBA_dev)
# writeRaster(iba_eba_zambia_r, fp(p_IBA_dev,"iba_eba_zambia_r.tif"), overwrite=TRUE)
# rm(iba_eba_zambia_r)
# iba_eba_zambia_r <- raster(fp(p_IBA_dev,"iba_eba_zambia_r.tif"))


# ----------------------------
# Resulting raster files
# ----------------------------
iba_africa_r <- raster(fp(p_IBA_dev,"iba_africa_r.tif")) # all African IBAs - Important Bird Areas
iba_zambia_r <- raster(fp(p_IBA_dev,"iba_zambia_r.tif")) # Zambia raster of IBAs, with 0s and 1s only.
eba_africa_r <- raster(fp(p_IBA_dev,"eba_africa_r.tif")) # all African EBAs - Endemic Bird Areas
eba_zambia_r <- raster(fp(p_IBA_dev,"eba_zambia_r.tif")) # just Zambian EBAs, 0s and 1s.
iba_eba_zambia_r <- raster(fp(p_IBA_dev,"iba_eba_zambia_r.tif")) # combined raster of Zambian IBAs and EBAs, 0s and 1s, ready for the tradeoff model.


plot(iba_eba_zambia_r)
plot(s5) # Laurance hotspots layer for comparison.

plot(st_geometry(iba_africa), border="red", add = T) # African IBAs
plot(st_geometry(eba_africa), border="blue", add = T) # African EBAs
plot(msk_shp, add = T)







################################
# ------------------------------
# Extras
# ------------------------------
ncell(msk) # has 1,362,244 cells
ncell(msk[!is.na(msk)]) # has 742,821 cells with values (i.e. that are not NA)
ncell(msk[msk>=0]) # 742,821 cells with values (greater than or equal to 0)
ncell(msk[msk==0]) # has 0 cells with a value of 0.

ncell(iba_zambia_r) # has 1,362,244 cells
ncell(iba_zambia_r[!is.na(iba_zambia_r)]) # has 742,821 cells with values (i.e. that are not NA)
ncell(iba_zambia_r[iba_zambia_r>=0]) # 742,821 cells with values (greater than or equal to 0)
ncell(iba_zambia_r[iba_zambia_r==0]) # has 0 cells with a value of 0.

# simplifying the geometries
iba_simpl <- st_simplify(iba_sf, dTolerance = 0.5, preserveTopology = TRUE)
eba_simpl <- st_simplify(eba_sf, dTolerance = 0.5, preserveTopology = TRUE)
plot(st_geometry(iba_simpl))

# transforming msk_shp to latlong
msk_ll <- st_transform(msk_sf, wgs$prj4)
plot(st_geometry(msk_ll))
plot(st_geometry(iba_sf), add = T)


# alternative to filtering by country: 
# clip to Zambia shapefile
msk_sf <- st_read(fp(p_datnew,"msk.shp"))

iba_zam_test <- iba_sf %>%
  st_buffer(0.0) %>% # run a buffer with distance of 0.
  st_intersection(msk_sf) # this returns the geometries where the two sf objects overlap.

valid <- st_make_valid(iba_sf) # this makes the geometries "valid", as an alternative to running the buffer
iba_zam_test1 <- valid %>% # one 
  st_intersection(msk_ll) # this returns the geometries where the two sf objects overlap.



iba_zam_test1 %>%
  st_transform(crs(msk_shp)) %>%
  st_geometry() %T>%
  plot(col="blue")
plot(st_geometry(iba_zam_test1))
plot(st_geometry(msk_sf), add = T)
plot(st_geometry(iba_zam_test))
plot(st_geometry(iba_z), border="red", add = T) # Zambia subset of the IBAs
```

```{r merge_ibas_ebas}
names(iba_sf)
iba_sf %>% select(Country, NatName, IntName, Source, DelTxt, DelGeom) %>% as_tibble()
iba_sf$IntName[1:20]
levels(iba_sf$NatName)

# add new column to identify features as IBAs, rename some columns, and then select only four columns.
iba_pre_merge <- iba_sf %>%
  mutate(type = "iba") %>%
  rename(name = IntName,
         country = Country) %>%
  select(type, key, name, country)

names(eba_sf)
eba_sf %>% select(EBANS, EBALON, EBALAT, EBAAREA, EBAALTMIN, EBAALTMAX) %>% as_tibble()
eba_sf %>% select(EBARECID, EBANAME, EBADATABAS, EBATYPE, EBABOOKCOD, EBAFOXCODE) %>% as_tibble()

eba_pre_merge <- eba_sf %>%
  mutate(type = "eba", country = NA) %>%
  rename(name = EBANAME) %>%
  select(type, key, name, country)

iba_pre_merge %>% as_tibble()
eba_pre_merge %>% as_tibble()
names(iba_pre_merge)
names(eba_pre_merge)

iba_eba_merge <- rbind(iba_pre_merge, eba_pre_merge)
```


```{r iba_eba-final}
# 1. Following original manual method below.
# 2. Using cc_make_raster, then adding them together
# `cc_make_raster` ---------------------------------------------
iba_list <- cc_make_raster(input_sf = iba_sf, fasterize_fun = 'last',
                    run_filter = FALSE, 
                    run_clip = TRUE, clip_area = africa,
                    prep_zambia = TRUE)
iba_zambia_r_test <- iba_list$output_raster

eba_list <- cc_make_raster(input_sf = eba_sf, fasterize_fun = 'last',
                    run_filter = FALSE, 
                    run_clip = TRUE, clip_area = africa,
                    prep_zambia = TRUE)
eba_zambia_r_test <- eba_list$output_raster

plot(iba_zambia_r_test - iba_zambia_r); freq(iba_zambia_r_test - iba_zambia_r)
plot(eba_zambia_r_test - eba_zambia_r); freq(eba_zambia_r_test - eba_zambia_r) # checks out

# add them together 
iba_eba_zambia_r_test2 <- iba_zambia_r_test + eba_zambia_r_test
plot(iba_eba_zambia_r_test2) # need to fix the 2s
freq(iba_eba_zambia_r_test2)
iba_eba_zambia_r_test2[iba_eba_zambia_r_test2 == 2] <- 1 # replace 2s with 1s

plot(iba_zambia_r_test - iba_zambia_r); freq(iba_zambia_r_test - iba_zambia_r)
plot(eba_zambia_r_test - eba_zambia_r); freq(eba_zambia_r_test - eba_zambia_r)
plot(iba_eba_zambia_r_test2 - iba_eba_zambia_r); freq(iba_eba_zambia_r_test2 - iba_eba_zambia_r) # checks out.

# 3.  Using the merged sf object pre-rasterization
# version 3 - merged pre-rasterization.
iba_eba_list <- cc_make_raster(input_sf = iba_eba_merge, fasterize_fun = 'last',
                            run_filter = FALSE, 
                            run_clip = TRUE, clip_area = africa,
                            prep_zambia = TRUE)
iba_eba_zambia_r_test <- iba_eba_list$output_raster

plot(iba_eba_zambia_r); freq(iba_eba_zambia_r) # no need to fix the 2s, because of the way the rasterization works. it just chooses the "last" polygon.
# no need for this: iba_eba_zambia_r_test3[iba_eba_zambia_r_test3 == 2] <- 1 # replace 2s with 1s

plot(iba_eba_zambia_r_test - iba_eba_zambia_r)
freq(iba_eba_zambia_r_test - iba_eba_zambia_r) # checks out. Sweet!!



iba_eba_zambia_r <- iba_eba_list$output_raster
# `cc_write_reload_raster` --------------------------------------
iba_eba_zambia_r <- cc_write_reload_raster(iba_eba_zambia_r, "iba_eba_zambia_r", p_IBA_dev)
iba_eba_zambia_r <- cc_write_reload_raster(iba_eba_zambia_r, "iba_eba_zambia_r", p_final_inputs)
```

```{r kba}
kba_sf <- st_read("/Users/christophercrawford/Google Drive/_Projects/data/Habitats/BirdLife-KBAs/KBAsGlobal_2019_March_01/KbaGlobal_2019_01_March_POL.shp")
msk_sf <- st_read(fp(p_datnew,"msk.shp"))

kba_sf <- cc_make_valid(kba_sf)
names(kba_sf)
table(kba_sf$EBADATABAS)
nrow(kba_sf)
levels(kba_sf$EBANAME)


# ------------------------------------------------------
# KBAs
# ------------------------------------------------------
sort(unique(kba_sf$Country)) # 241 levels: Zambia is one of them

kba_z <- kba_sf %>%
  filter(Country == "Zambia") %>% # filter by country
  st_transform(crs(msk_shp)) # reproject

object_size(kba_z)
plot(kba_z$geometry, border = "orange", add = TRUE)

plot(iba_eba_zambia_r)
env_size(ls())
```


# 6. WWF Global 200 ecoregions
```{r g200-ecoregions}
ecoregions_sf <- st_read(fp(p_dat_hab, "global200ecoregions/g200_terr.shp"))
ecoregions_sf <- cc_make_valid(ecoregions_sf)
msk_sf <- st_read(fp(p_datnew,"msk.shp"))

# exploring the datasets, ecoregions_sf
ecoregions_sf
names(ecoregions_sf)
object_size(ecoregions_sf)
levels(as.factor(ecoregions_sf$G200_BIOME)) # 14 levels of regions. 

ecoregions_sf %>%
  st_drop_geometry() %>%
  arrange(G200_BIOME)

# exploratory plots
plot(ecoregions_sf$geometry)
plot(s6); plot(msk_shp, add = T) # original Laurance datasets
s6_Af_aaeac <- projectRaster(s6_Af, crs = crs(msk))
plot(s6_Af_aaeac, ext = extent(msk_sf_10kmbuff)); plot(msk_shp, add = T)

plot(msk_sf$geometry)


```


```{r clip-ecoregions}
# ---- subset to Zambia
ecoregions_zambia <- ecoregions_sf %>%
  st_intersection(., st_union(msk_sf_ll_noholes)) %>%
  #st_cast("MULTIPOLYGON") #%>% # also seems to work fine.
  st_collection_extract(., "POLYGON") # extract only polygons
plot(ecoregions_zambia$geometry)
plot(msk_sf_ll$geometry, add = T, border = "red")

p_ecoreg_dev
save(ecoregions_zambia, file = fp(p_ecoreg_dev, "ecoregions_zambia.RData")) # includes ecoregions_zambia, which has been made valid, been prepped, and then clipped to zambia


# clip to buffer
ecoregions_zambia_4deg_buff <- ecoregions_sf %>%
  st_intersection(., st_union(msk_sf_ll_4deg_buff)) %>%
  st_collection_extract(., "POLYGON")
plot(ecoregions_zambia_4deg_buff$geometry)
save(ecoregions_zambia_4deg_buff, file = fp(p_ecoreg_dev, "ecoregions_zambia_4deg_buff.RData")) # includes plants_zambia, which has had area adj richness added, been prepped, and then clipped to zambia.


ecoregions_africa <- ecoregions_sf %>%
  st_intersection(st_union(africa)) %>% st_cast("MULTIPOLYGON") #%>%  # using the intersection method
  #st_transform(crs(msk_shp)) 

ecoregions_africa %>%
  st_geometry() %T>% # reproject
  plot(border = "blue")

```

```{r manual-testing}
# -------------------------------
# Pipe and fasterize ecoregions
# -------------------------------
ecoregions_africa_r <- 
  ecoregions_sf %>% # all ecoregions
  st_intersection(st_union(africa)) %>% st_cast("MULTIPOLYGON") %>%  # using the intersection method
  st_transform(aaeac) %>% # reproject
  fasterize(., extend(msk, extent(.), value = 0), fun = 'last') # then rasterize.
  

# view results
plot(ecoregions_africa_r)
ecoregions_africa %>%
  st_transform(aaeac) %>%
  st_geometry() %T>%
  plot(border="blue", add = T) # African g200 ecoregions
plot(msk_shp, add = T)

# save results
ecoregions_africa_r <- cc_write_reload_raster(ecoregions_africa_r, "ecoregions_africa_r", p_ecoreg_dev)
# writeRaster(ecoregions_africa_r, fp(p_ecoreg_dev,"ecoregions_africa_r.tif"), overwrite=TRUE)
# rm(ecoregions_africa_r)
# ecoregions_africa_r <- raster(fp(p_ecoreg_dev,"ecoregions_africa_r.tif"))

###########
## final prep for toff, ecoregions
###########
ecoregions_zambia_r <- crop(ecoregions_africa_r, extent(msk)) # crop to (almost) the right extent
ecoregions_zambia_r[is.na(ecoregions_zambia_r)] <- 0 # replace NAs with 0s
ecoregions_zambia_r <- raster::mask(ecoregions_zambia_r, msk) # masking, in order to set all cells in hotspots_r to NA where msk is NA.
plot(ecoregions_zambia_r); plot(msk_shp, add = T)
plot(s6)

ecoregions_zambia_r <- cc_write_reload_raster(ecoregions_zambia_r, "ecoregions_zambia_r", p_ecoreg_dev)
# writeRaster(ecoregions_zambia_r, fp(p_ecoreg_dev,"ecoregions_zambia_r.tif"), overwrite=TRUE)
# rm(ecoregions_zambia_r)
# ecoregions_zambia_r <- raster(fp(p_ecoreg_dev,"ecoregions_zambia_r.tif"))

plot(ecoregions_africa_r)
plot(ecoregions_zambia_r)
plot(msk_shp, add = T)
```

```{r inverse_ecoregion_size}
# load in all 814 something ecoregions:
ecoregions_all <- st_read("/Users/christophercrawford/Google Drive/_Projects/data/Habitats/terr-ecoregions-TNC/tnc_terr_ecoregions.shp")

# make them valid
ecoregions_all <- cc_make_valid(ecoregions_all)

# clip them to Zambia
ecoregions_all_zambia <- ecoregions_all %>%
  st_intersection(., st_union(msk_sf_ll_noholes)) %>%
  #st_cast("MULTIPOLYGON") #%>% # also seems to work fine.
  st_collection_extract(., "POLYGON") # extract only polygons



plot(ecoregions_all_zambia$geometry)

# list the ecoregions in Zambia:
ecoregions_all_zambia$ECO_NAME %>%
  unique()
ecoregions_zam_select <- ecoregions_all %>%
  filter(ECO_NAME %in% ecoregions_all_zambia$ECO_NAME)

plot(ecoregions_zam_select$geometry)
plot(msk_sf_ll$geometry, add = T, border = "red")

ecoregions_zam_select$ECO_NAME


# calculate area of each ecoregion
# area, caluclated from polygons in long lat projection
# add column that is inverse of ecoregion_area

ecoregions_zam_select <- ecoregions_zam_select %>%
  mutate(area_km2 = st_area(.["geometry"]) %>% units::set_units(km^2),
         inverse_area = 1/area_km2) 

ecoregions_weighted_rarity <- ecoregions_zam_select %>%
  st_intersection(., st_union(msk_sf_ll_noholes)) %>%
  st_collection_extract(., "POLYGON") %>% # extract only polygons
  st_transform(aaeac) %>%
  fasterize(., raster = msk_filled, field = 'inverse_area', fun = 'last') %>%
  raster::mask(msk)

# check it out to test 
ecoregions_zam_select_clipped <- ecoregions_zam_select %>%
  st_intersection(., st_union(msk_sf_ll_noholes)) %>%
  st_collection_extract(., "POLYGON")

mapView(ecoregions_zam_select_clipped["ECO_NAME"])

plot(ecoregions_zam_select["inverse_area"])
plot(ecoregions_zam_select_clipped["inverse_area"])

plot(ecoregions_weighted_rarity)


# save file: 

ecoregions_weighted_rarity <- cc_write_reload_raster(ecoregions_weighted_rarity, "ecoregions_weighted_rarity", p_ecoreg_dev)
ecoregions_weighted_rarity <- cc_write_reload_raster(ecoregions_weighted_rarity, "ecoregions_weighted_rarity", p_final_inputs)




```


```{r ecoregions-final}
# `cc_make_raster` ---------------------------------------------
ecoregions_list <- cc_make_raster(input_sf = ecoregions_sf, fasterize_fun = 'last',
                    run_filter = FALSE, 
                    run_clip = TRUE, run_extract = TRUE, clip_area = africa,
                    prep_zambia = TRUE)

ecoregions_zambia_r <- ecoregions_list$output_raster
plot(ecoregions_list$output_raster)
plot(ecoregions_list$output_raster, ext = ext_eco)

# spot checking, filling in values around Lake Tanganyika ----------------------------------------------------
ext_eco <- extent(c(595063.2, 641692.9, -1047208, -1005969)) # drawExtent(show=T, col = "red")

plot(ecoregions_zambia_r)
plot(ecoregions_zambia_r, ext = ext_eco)
plot(st_transform(ecoregions_zambia_4deg_buff$geometry, aaeac), border = "blue", 
     #xlim = ext_eco[1:2], ylim = ext_eco[3:4],
     add = T)
plot(msk_sf$geometry, 
     #xlim = ext_tanganyika[1:2], ylim = ext_tanganyika[3:4]
     add = TRUE)

# fill 0s with 1s, the value of the closest adjancent ecoregion, and then mask by msk
ecoregions_zambia_r[ext_eco][ecoregions_zambia_r[ext_eco] == 0] <- 1
ecoregions_zambia_r <- raster::mask(ecoregions_zambia_r, msk)

plot(ecoregions_zambia_r, ext = ext_eco)
plot(ecoregions_zambia_r, ext = ext_tanganyika)


ncell(msk)
ncell(ecoregions_zambia_r)
ncell(msk[!is.na(msk)])
ncell(ecoregions_zambia_r[!is.na(ecoregions_zambia_r)])


# save list, etc.

save(ecoregions_list, file = fp(p_ecoreg_dev, "ecoregions_list.RData"))

# `cc_write_reload_raster` --------------------------------------
ecoregions_zambia_r <- cc_write_reload_raster(ecoregions_zambia_r, "ecoregions_zambia_r", p_ecoreg_dev)
ecoregions_zambia_r <- cc_write_reload_raster(ecoregions_zambia_r, "ecoregions_zambia_r", p_final_inputs)
```

# 7. Wilderness + Frontier Forests
```{r wilderness}
hbwa_sf <- st_read(fp(p_dat_hab, "D-HighBdWildernessAreas/HBWA_poly/HBWA_poly.shp"))
frontier_forests_sf <- st_read(fp(p_dat_hab, "D-FrontierForests/GFW_Frontier_Forests/data/commondata/data0/frontier.shp"))
hbwa_sf <- cc_make_valid(hbwa_sf)
frontier_forests_sf <- cc_make_valid(frontier_forests_sf)

hbwa_sf %>% filter(ID == 3) %>% st_geometry() %>% st_transform(aaeac) %T>% plot()
plot(msk_sf$geometry, add= T, border = "red")

msk_sf <- st_read(fp(p_datnew,"msk.shp"))

# exploring the datasets
s7_globe <- raster("/Users/christophercrawford/Google Drive/_Projects/Zambia/agroEcoTradeoff/external/data_new/Laurance_et_al_rasters/s7/w001001.adf")
plot(s7_globe)
# s7_globe_aaeac <- projectRaster(s7_globe, crs = crs(msk)) # ok, there is no input projection. And, even when I do the reprojection with the raster cropped to Africa, it doesn't quite work. 
plot(s7); plot(msk_shp, add = T) # original Laurance datasets
s7_Af_aaeac <- projectRaster(s7_Af, crs = crs(msk))

plot(s7_Af_aaeac, ext = extent(msk_sf_10kmbuff));  plot(msk_shp, add = T)

st_crs(frontier_forests_sf)

# -------------------------------
# exploratory plots
# -------------------------------
plot(msk_shp, add = F)
africa %>%
  st_union()
  #st_transform(crs(msk_shp)) %>%
  st_geometry() %T>%
  plot(border = "black", 
       xlim = ext[1:2], ylim = ext[3:4],
       add = F)

plot(hbwa_sf["WA_NAME"], add = FALSE)
hbwa_sf %>%
  st_transform(crs(msk_shp)) %>%
  st_geometry() %T>%
  plot(col = adjustcolor("red", 0.2), 
       border = "blue",
       add = T)

ext <- drawExtent(show=TRUE, col = "red")

# -------------------------------
# Plotting frontier forests, with nice colors
# -------------------------------
names(frontier_forests_sf)
levels(as.factor(frontier_forests_sf$THREAT_DES))
forest_table <- as_tibble(st_drop_geometry(frontier_forests_sf))
forest_table$THREAT_COD <- as.factor(forest_table$THREAT_COD)

plot(st_transform(frontier_forests_sf, crs(hbwa_sf))["THREAT_COD"], add = T)

forest_table %>% # drop geometries and then summarize, counting the number of polygons in each category
  group_by(THREAT_COD, THREAT_DES) %>% # first group by threat_cod and threat_des (or by the new one I make below, threat_new)
  dplyr::summarize(num_poly = n()) %>%
  print()

frontier_forests_sf <- frontier_forests_sf %>% # renaming factor levels
  mutate(threat_new = fct_recode(as.factor(THREAT_COD),
                               "Unassessed" = "-99",
                               "Low or No Threat (0)" = "0",
                               "Low or No Threat (1)" = "1",
                               "Medium or High Threat (2)" = "2",
                               "Medium or High Threat (3)" = "3"))

forest_colors <- rev(heat.colors(5)) # or colorRampPalette(c("yellow", "red"))(5)
forest_colors_all <- forest_colors[frontier_forests_africa$threat_new]
frontier_forests_sf %>%
  st_transform(st_crs(africa)) %>%
  st_intersection(st_union(africa)) %>% st_cast("MULTIPOLYGON") %>% 
  st_geometry() %T>%
  plot(col = forest_colors_all) # note that adding to an existing plot with 
     
legend("bottom", legend = levels(frontier_forests_sf$threat_new),
       fill = forest_colors)
africa %>% st_union() %T>% plot(add = TRUE)
africa %>% st_union() %>% st_graticule() %>% st_geometry() %T>% plot(add = TRUE)


# next steps:
# 1. select just African HBWAs and Frontier Forests, creating two new shapefiles
# 2. add these together.
# 3. rasterize these.
# 4. explore why the layer is different for s7

# -------------------------------
# cropping datasets to Africa 
# -------------------------------
frontier_forests_africa <- frontier_forests_sf %>% 
  st_transform(crs(africa)) %>% 
  st_intersection(st_union(africa)) %>% st_cast("MULTIPOLYGON") #%>% 
  #st_transform(aaeac)

plot(frontier_forests_africa$geometry)

hbwa_africa <- hbwa_sf %>% 
  st_intersection(st_union(africa)) %>% st_cast("MULTIPOLYGON") #%>% 
  #st_transform(aaeac)

hbwa_africa$WA_NAME <- droplevels(hbwa_africa$WA_NAME)
colors <- c("red", "green")
plot(hbwa_africa$geometry, border = colors[hbwa_africa$WA_NAME])
legend("bottom", legend = levels(hbwa_africa$WA_NAME),
       fill = colors)

plot(msk_sf$geometry, add = T)

# resulting sf objects
frontier_forests_africa
hbwa_africa

plot(hbwa_africa$geometry, 
     border = c("brown", "dark green")[hbwa_africa$WA_NAME], lwd = 3, 
     col = adjustcolor(c("brown", "dark green")[hbwa_africa$WA_NAME], 0.4))
plot(frontier_forests_africa$geometry, col = adjustcolor("blue", 0.4), add = T)

# merge datasets (Note: st_combine just condenses multiple features within a single sf object into one feature, it doesn't combine two sf objects)
# actually, it doesn't really make sense to combine the two sf objects. They would need to have the same column numbers and names, in order for it to make sense to combine them with something like rbind. See merge_frontier_hbwas below.

# -------------------------------
# Pipe and fasterize frontier forests and high biodiversity wilderness areas
# -------------------------------
hbwa_africa_r <- 
  hbwa_sf %>% # all high biodiversity wilderness areas
  st_intersection(st_union(africa)) %>% st_cast("MULTIPOLYGON") %>%  # using the intersection method
  st_transform(crs(msk_shp)) %>% # reproject
  fasterize(., extend(msk, extent(.), value = 0), fun = 'last') # then rasterize.

frontier_forests_africa_r <- 
  frontier_forests_sf %>%
  st_transform(crs(hbwa_sf)) %>% # reproject to same crs as africa_u
  st_intersection(st_union(africa)) %>% st_cast("MULTIPOLYGON") %>%  #clip to Africa using africa_u
  st_transform(aaeac) %>% # reproject
  fasterize(., extend(msk, extent(.), value = 0), fun = 'last') # then rasterize.


# view results
plot(hbwa_africa_r); plot(hbwa_africa$geometry, add = T)
plot(frontier_forests_africa_r, col = "green", add = T); plot(frontier_forests_africa$geometry, add = T)
plot(msk_shp, add = T)

# save results
hbwa_africa_r <- cc_write_reload_raster(hbwa_africa_r, "hbwa_africa_r", p_wilder_dev)
frontier_forests_africa_r <- cc_write_reload_raster(frontier_forests_africa_r, "frontier_forests_africa_r", p_wilder_dev)

# writeRaster(hbwa_africa_r, fp(p_wilder_dev,"hbwa_africa_r.tif"), overwrite=TRUE)
# rm(hbwa_africa_r)
# hbwa_africa_r <- raster(fp(p_wilder_dev,"hbwa_africa_r.tif"))
# 
# writeRaster(frontier_forests_africa_r, fp(p_wilder_dev,"frontier_forests_africa_r.tif"), overwrite=TRUE)
# rm(frontier_forests_africa_r)
# frontier_forests_africa_r <- raster(fp(p_wilder_dev,"frontier_forests_africa_r.tif"))

resample
# -------------------------------
# final prep for model
# -------------------------------
# high biodiversity wilderness areas
hbwa_zambia_r <- crop(hbwa_africa_r, extent(msk)) # crop to (almost) the right extent
hbwa_zambia_r[is.na(hbwa_zambia_r)] <- 0 # replace NAs with 0s
hbwa_zambia_r <- raster::mask(hbwa_zambia_r, msk) # masking, in order to set all cells in hotspots_r to NA where msk is NA.
plot(hbwa_zambia_r); plot(msk_shp, add = T)
zoom <- drawExtent(show = T, col = "red")
plot(hbwa_zambia_r, ext = zoom); plot(msk_shp, add = T)

hbwa_zambia_r <- cc_write_reload_raster(hbwa_zambia_r, "hbwa_zambia_r", p_wilder_dev)
# writeRaster(hbwa_zambia_r, fp(p_wilder_dev,"hbwa_zambia_r.tif"), overwrite=TRUE)
# rm(hbwa_zambia_r)
# hbwa_zambia_r <- raster(fp(p_wilder_dev,"hbwa_zambia_r.tif"))

###########
## final prep for toff, frontier forests
###########
# note that this piece is not necessary, as of right now, because there are no frontier forests in Zambia. 
frontier_forests_zambia_r <- crop(frontier_forests_africa_r, extent(msk)) # crop to (almost) the right extent
frontier_forests_zambia_r[is.na(frontier_forests_zambia_r)] <- 0 # replace NAs with 0s
frontier_forests_zambia_r <- raster::mask(frontier_forests_zambia_r, msk) # masking, in order to set all cells in hotspots_r to NA where msk is NA.
plot(frontier_forests_zambia_r); plot(msk_shp, add = T)
freq(frontier_forests_zambia_r) # all 0s.

frontier_forests_zambia_r <- cc_write_reload_raster(frontier_forests_zambia_r, "frontier_forests_zambia_r", p_wilder_dev)
# writeRaster(frontier_forests_zambia_r, fp(p_wilder_dev,"frontier_forests_zambia_r.tif"), overwrite=TRUE)
# rm(frontier_forests_zambia_r)
# frontier_forests_zambia_r <- raster(fp(p_wilder_dev,"frontier_forests_zambia_r.tif"))

###########
## combining frontier forests and high biodiversity wilderness areas; not needed, actually.
###########
wilderness_zambia_r <- hbwa_zambia_r + frontier_forests_zambia_r
plot(wilderness_zambia_r) 
freq(wilderness_zambia_r)
# wilderness_zambia_r[wilderness_zambia_r == 2] <- 1 # replace 2s with 1s, not needed. Not sure why I had this here.

wilderness_zambia_r <- cc_write_reload_raster(wilderness_zambia_r, "wilderness_zambia_r", p_wilder_dev)
# writeRaster(wilderness_zambia_r, fp(p_wilder_dev,"wilderness_zambia_r.tif"), overwrite=TRUE)
# rm(wilderness_zambia_r)
# wilderness_zambia_r <- raster(fp(p_wilder_dev,"wilderness_zambia_r.tif"))


# ----------------------------
# Resulting raster files
# ----------------------------
hbwa_africa_r <- raster(fp(p_wilder_dev,"hbwa_africa_r.tif")) # all African IBAs - Important Bird Areas
hbwa_zambia_r <- raster(fp(p_wilder_dev,"hbwa_zambia_r.tif")) # Zambia raster of IBAs, with 0s and 1s only.
frontier_forests_africa_r <- raster(fp(p_wilder_dev,"frontier_forests_africa_r.tif")) # all African EBAs - Endemic Bird Areas

# Note: there are no frontier forests in Zambia. 
frontier_forests_zambia_r <- raster(fp(p_wilder_dev,"frontier_forests_zambia_r.tif")) # just Zambian EBAs, 0s and 1s.
wilderness_zambia_r <- raster(fp(p_wilder_dev,"wilderness_zambia_r.tif")) # combined raster of Zambian HBWAs and Frontier Forests, 0s and 1s, ready for the tradeoff model.


plot(s4)
plot(hotspots_zambia_r)

plot(s5)
plot(iba_eba_zambia_r)

plot(s6)
plot(ecoregions_zambia_r)

plot(s7); plot(msk_shp, add = T)
plot(wilderness_zambia_r); plot(msk_shp, add = T)
```

```{r merge_frontier_hbwas}
names(hbwa_sf)
names(frontier_forests_sf)
hbwa_sf %>% select(ID, WA_NAME, TYPE) %>% as_tibble()

frontier_forests_sf %>% select(Country, NatName, IntName, Source, DelTxt, DelGeom) %>% as_tibble()
iba_sf$IntName[1:20]
levels(iba_sf$NatName)

# add new column to identify features as IBAs, rename some columns, and then select only four columns.
iba_pre_merge <- iba_sf %>%
  mutate(type = "iba") %>%
  rename(name = IntName,
         country = Country) %>%
  select(type, key, name, country)

eba_sf %>% select(EBANS, EBALON, EBALAT, EBAAREA, EBAALTMIN, EBAALTMAX) %>% as_tibble()
eba_sf %>% select(EBARECID, EBANAME, EBADATABAS, EBATYPE, EBABOOKCOD, EBAFOXCODE) %>% as_tibble()

eba_pre_merge <- eba_sf %>%
  mutate(type = "eba", country = NA) %>%
  rename(name = EBANAME) %>%
  select(type, key, name, country)

iba_pre_merge %>% as_tibble()
eba_pre_merge %>% as_tibble()
names(iba_pre_merge)
names(eba_pre_merge)

iba_eba_merge <- rbind(iba_pre_merge, eba_pre_merge)
```


```{r wilderness-final}
# `cc_make_raster` ---------------------------------------------
frontier_forests_list <- cc_make_raster(input_sf = st_transform(frontier_forests_sf, crs_longlat), fasterize_fun = 'last',
                    run_filter = FALSE, 
                    run_clip = TRUE, clip_area = africa,
                    prep_zambia = TRUE)
frontier_forests_zambia_r_test <- frontier_forests_list$output_raster

# Test that it's the same as the original raster.
plot(frontier_forests_zambia_r_test - frontier_forests_zambia_r)
freq(frontier_forests_zambia_r_test - frontier_forests_zambia_r)
rm(frontier_forests_zambia_r_test)


frontier_forests_zambia_r <- frontier_forests_list$output_raster
# `cc_write_reload_raster` --------------------------------------
frontier_forests_zambia_r <- cc_write_reload_raster(frontier_forests_zambia_r, "frontier_forests_zambia_r", p_wilder_dev)
frontier_forests_zambia_r <- cc_write_reload_raster(frontier_forests_zambia_r, "frontier_forests_zambia_r", p_final_inputs)



# `cc_make_raster` ---------------------------------------------
hbwa_list <- cc_make_raster(input_sf = hbwa_sf, fasterize_fun = 'last',
                    run_filter = FALSE, 
                    run_clip = TRUE, clip_area = africa,
                    prep_zambia = TRUE)
hbwa_zambia_r_test <- hbwa_list$output_raster

# Test that it's the same as the original raster.
plot(hbwa_zambia_r_test - hbwa_zambia_r)
freq(hbwa_zambia_r_test - hbwa_zambia_r)
rm(hbwa_zambia_r_test)


hbwa_zambia_r <- hbwa_list$output_raster
# `cc_write_reload_raster` --------------------------------------
hbwa_zambia_r <- cc_write_reload_raster(hbwa_zambia_r, "hbwa_zambia_r", p_wilder_dev)
hbwa_zambia_r <- cc_write_reload_raster(hbwa_zambia_r, "hbwa_zambia_r", p_final_inputs)


# create wilderness_r, then `cc_write_reload_raster` --------------------------------------
wilderness_zambia_r <- hbwa_zambia_r + frontier_forests_zambia_r
plot(wilderness_zambia_r); freq(wilderness_zambia_r)

wilderness_zambia_r <- cc_write_reload_raster(wilderness_zambia_r, "wilderness_zambia_r", p_wilder_dev)
wilderness_zambia_r <- cc_write_reload_raster(wilderness_zambia_r, "wilderness_zambia_r", p_final_inputs)

```

# Final Products

```{r vertebrate-files}
save(mam_pre_merge, bird_pre_merge, amp_pre_merge, rep_pre_merge,
     vert_merge, vert_list, vert_zambia_threat_richness,
     file = fp(p_datnew,"vertebrate-files.RData"))

save(mam_zambia_all_richness,
     mam_zambia_threat_richness,
     mam_zambia_small_richness,
     mam_zambia_small_or_threat_richness,
     
     bird_zambia_all_richness,
     bird_zambia_threat_richness,
     bird_zambia_small_richness,
     bird_zambia_small_or_threat_richness,
     
     amp_zambia_all_richness,
     amp_zambia_threat_richness,
     amp_zambia_small_richness,
     amp_zambia_small_or_threat_richness,
     
     rep_zambia_all_richness,
     rep_zambia_threat_richness,
     rep_zambia_small_richness,
     rep_zambia_small_or_threat_richness,
     
     vert_zambia_all_richness,
     vert_zambia_threat_richness,
     vert_zambia_small_richness,
     vert_zambia_small_or_threat_richness,
     file = fp(p_datnew,"vertebrate-rasters-zambia.RData"))

# save(mam_list, bird_list, amp_list, rep_list, vert_list,
#      file = fp(p_datnew,"vertebrate-lists-zambia.RData"))


```


```{r save-habitat-polys}
# note that all of these shapefiles have been made valid using my function make_valid()
save(hotspots_sf, hotspots_africa, #  hotspots_sf, global and africa
     iba_sf, eba_sf, iba_africa, eba_africa,# ibas and ebas, global and clipped to Africa
     ecoregions_sf, ecoregions_africa, # ecoregions, global and clipped to Africa
     hbwa_sf, hbwa_africa, # hbwa
     frontier_forests_sf, frontier_forests_africa, # frontier forests
     file = fp(p_datnew,"habitat_polys.RData"))

save(hotspots_zambia_r,
     iba_zambia_r,
     eba_zambia_r,
     iba_eba_zambia_r,
     ecoregions_zambia_r,
     hbwa_zambia_r,
     frontier_forests_zambia_r,
     wilderness_zambia_r,
     file = fp(p_datnew,"habitat_rasters_zambia.RData"))

save(hotspots_list,
     iba_list,
     eba_list,
     iba_eba_list,
     ecoregions_list,
     hbwa_list,
     frontier_forests_list, 
     file = fp(p_datnew,"habitat_lists.RData"))
```

```{r habitat-plots}
pdf(file = fp(p_plots,"vert_plots.pdf"), width = 9, height = 8)
#png(file = fp(p_plots,"Estes-plots_test.png"), width = 8, height = 9, units = "in", res = 100)
par(mfrow=c(4,4), mar=c(1,1,2,1), omi=c(0.1,0.1,0.1,0.1), cex.main=1) # setting the plot parameters. 

plot(vert_all_richness_brick$mam); plot(msk_shp, add=TRUE)
plot(vert_all_richness_brick$bird); plot(msk_shp, add=TRUE)
plot(vert_all_richness_brick$amp); plot(msk_shp, add=TRUE)
plot(vert_all_richness_brick$rep); plot(msk_shp, add=TRUE)

plot(vert_threat_richness_brick$mam); plot(msk_shp, add=TRUE)
plot(vert_threat_richness_brick$bird); plot(msk_shp, add=TRUE)
plot(vert_threat_richness_brick$amp); plot(msk_shp, add=TRUE)
plot(vert_threat_richness_brick$rep); plot(msk_shp, add=TRUE)

plot(vert_small_richness_brick$mam); plot(msk_shp, add=TRUE)
plot(vert_small_richness_brick$bird); plot(msk_shp, add=TRUE)
plot(vert_small_richness_brick$amp); plot(msk_shp, add=TRUE)
plot(vert_small_richness_brick$rep); plot(msk_shp, add=TRUE)

plot(vert_small_threat_richness_brick$mam); plot(msk_shp, add=TRUE)
plot(vert_small_threat_richness_brick$bird); plot(msk_shp, add=TRUE)
plot(vert_small_threat_richness_brick$amp); plot(msk_shp, add=TRUE)
plot(vert_small_threat_richness_brick$rep); plot(msk_shp, add=TRUE)
dev.off()
```


```{r intermediary-vert-products}
# a collection of intermediary data produced throughout this .Rmd file.

# vertebrate files -------------------------------------------------------------------------------------
# valid sf files, made valid, and prepped for use in small ranged species analyses
load(file = fp(p_iucn_dev,"mam_valid_prepped.RData"), verbose = TRUE)
load(file = fp(p_iucn_dev,"bird_valid_prepped.RData"), verbose = TRUE)
load(file = fp(p_iucn_dev,"amp_valid_prepped.RData"), verbose = TRUE)
load(file = fp(p_iucn_dev,"rep_valid_prepped.RData"), verbose = TRUE)

# vert zambia sf files, prepped and valid
load(file = fp(p_iucn_dev, "mam_zambia.RData"), verbose = TRUE) # includes mam_zambia, which has had area added, been prepped, and then clipped to zambia
load(file = fp(p_iucn_dev, "bird_zambia.RData"), verbose = TRUE) # includes bird_zambia, which has had area added, been prepped, and then clipped to zambia
load(file = fp(p_iucn_dev, "amp_zambia.RData"), verbose = TRUE) # includes amp_zambia, which has had area added, been prepped, and then clipped to zambia
load(file = fp(p_iucn_dev, "rep_zambia.RData"), verbose = TRUE) # includes rep_zambia, which has had area added, been prepped, and then clipped to zambia


# vertebrate lists (only using IUCN data)
load(file = fp(p_iucn_dev, "vert_lists.RData"), verbose = TRUE) # updated jan. 31 2020 
# note: these lists were created using the function cc_make_raster8 on January 31st, 2020. 

# summary tables (only using IUCN data)
load(file = fp(p_datnew, "1_IUCN_dev/vert_valid_summaries.RData"), verbose = TRUE) # mam_valid_summary,  bird_valid_summary, amp_valid_summary, rep_valid_summary
load(file = fp(p_datnew, "1_IUCN_dev/vert_zambia_summaries.RData"), verbose = TRUE) # mam_zambia_summary,  bird_zambia_summary, amp_zambia_summary, rep_zambia_summary


load(file = fp(p_iucn_dev, "mam_list.RData"))  # updated jan. 31 2020 
load(file = fp(p_iucn_dev, "bird_list.RData"))  # updated jan. 31 2020 
load(file = fp(p_iucn_dev, "amp_list.RData"))  # updated jan. 31 2020 
load(file = fp(p_iucn_dev, "rep_list.RData"))  # updated jan. 31 2020 
# note, this rep_list file includes only data from IUCN, not from GARD. See GARD list for the most up to date files. The richness metric .tifs have all been updated to use GARD (or IUCN in the case of threatened species richness). These are the finaly data files used in the analysis.

load(file = "/Users/christophercrawford/Google Drive/_Projects/Zambia/agroEcoTradeoff/external/data_new/1_IUCN_dev/gard_list.RData", verbose = TRUE) #



# load-vert-bricks -------------------------------------------------------------------------------
load(file = fp(p_datnew, "vert_bricks.Rdata"), verbose = TRUE) # this includes all four taxonomic groups, including both GARD and the IUCN rep brick file. This is the most up to date version, from May 2020.
```


```{r final-input-datasets}
# ----------------------------------------------------------------------------
# load final input datasets
# ----------------------------------------------------------------------------

# load-vert-bricks -----------------

# create layer names object
layer_names <- c("mam", "bird", "amp", "rep", "sum", "sum_norm", "norm_sum", "mam_10", "bird_10", "amp_10", "rep_10", "norm_sum_10", "mam_110", "bird_110", "amp_110", "rep_110", "norm_sum_110")

richness_names <- c("all_richness", "endemism_richness", "endemism_zam_richness", "threat_richness", "threat_weighted_richness", "small_richness", "small_zam_richness", "small_threat_richness")

# load in as a list of all rasters - final datafiles.
vert_r <- list(
  all_richness = brick(paste0(p_iucn_dev, "/", richness_names[1], ".tif")),
  endemism_richness = brick(paste0(p_iucn_dev, "/", richness_names[2], ".tif")),
  endemism_zam_richness = brick(paste0(p_iucn_dev, "/", richness_names[3], ".tif")),
  threat_richness = brick(paste0(p_iucn_dev, "/", richness_names[4], ".tif")),
  threat_weighted_richness = brick(paste0(p_iucn_dev, "/", richness_names[5], ".tif")),
  small_richness = brick(paste0(p_iucn_dev, "/", richness_names[6], ".tif")),
  small_zam_richness = brick(paste0(p_iucn_dev, "/", richness_names[7], ".tif")),
  small_threat_richness = brick(paste0(p_iucn_dev, "/", richness_names[8], ".tif"))
  )

# rename layers
for(i in seq_along(vert_r)) {
  names(vert_r[[i]]) <- layer_names
}


# plants ------------------------------------------------------------------------
plants_zambia_r <- raster(fp(p_plants_dev, "plants_zambia_r.tif"))


# habitats rasters -----------------------------------------------------------------------------
load(file = fp(p_datnew,"habitat_rasters_zambia.RData"), verbose = TRUE)

ecoregions_weighted_rarity <- raster(fp(p_ecoreg_dev, "ecoregions_weighted_rarity.tif"))




# load plants ----------------------------------------------------------------------------
load(file = "/Users/christophercrawford/Google Drive/_Projects/Zambia/agroEcoTradeoff/external/data_new/2_plants_dev/plants_list.RData", verbose = TRUE)
load(file = fp(p_plants_dev, "plants_valid.RData"), verbose = TRUE) # this includes plants, which has been made valid.

load(file = fp(p_plants_dev, "plants_zambia.RData"), verbose = TRUE)

load(file = fp(p_plants_dev, "plants_zambia_4deg_buff.RData"), verbose = TRUE)

plants_zambia_r <- raster(fp(p_plants_dev, "plants_zambia_r.tif"))


# habitats files --------------------------------------------------------------------------------------
# sf files, polygons
load(fp(p_datnew,"habitat_polys.RData"), verbose = TRUE) # all valid. includes: hotspots_sf, global and africa; ibas and ebas, global and Africa; ecoregions, global and Africa; # hbwa global and africa; frontier forests global and africa

load(file = fp(p_datnew,"habitat_rasters_zambia.RData"), verbose = TRUE)

load(file = fp(p_datnew,"habitat_lists.RData"), verbose = TRUE) # hotspots_list, iba_list, eba_list, iba_eba_list, ecoregions_list, hbwa_list, frontier_forests_list.


# final zambia rasters:
load(file = fp(p_datnew,"final-rasters-zambia.RData"), verbose = TRUE)
```


# Methods

## Testing rescaling methods

There are three methods I used to rescale the resolution of the rasters so that they are appropriate for use. 
1. (The method I use): aggregating from the global scale, 1 km resolution map, using the function `aggregate()`
2. (Alt 1): directly in fasterize, by changing the resolution of the raster that is being written into.
3. (Alt 2): aggregating directly from the masked Zambia raster, at 1 km resolution.

This chunk just summarizes the results of those tests below:

```{r rescaling-method-comparison}
# 1. (The method I use): aggregating from the global scale, 1 km resolution map, using the function `aggregate()` - results from above:
plot(mam_zambia_terr_threat_richness, col = viridis(100))
plot(mam_zambia_terr_threat_richness_10km, col = viridis(100))
plot(mam_zambia_terr_threat_richness_110km, col = viridis(100))

# 2. (Alt 1): changing the resolution in fasterize() directly in the function, by changing the resolution of the raster that is being written into:
plot(mam_zambia_terr_threat_richness, col = viridis(100))
plot(mam_zambia_terr_threat_richness_10km_alt1, col = viridis(100))
plot(mam_zambia_terr_threat_richness_110km_alt1, col = viridis(100))

# 3. (Alt 2): aggregating directly from the masked Zambia raster, at 1 km resolution:
plot(mam_zambia_terr_threat_richness, col = viridis(100))
plot(mam_zambia_terr_threat_richness_10km_alt2, col = viridis(100))
plot(mam_zambia_terr_threat_richness_110km_alt2, col = viridis(100))


plot(mam_zambia_terr_threat_richness_110km -
       mam_zambia_terr_threat_richness_110km_alt1, col = viridis(100))
plot(mam_zambia_terr_threat_richness_110km -
       mam_zambia_terr_threat_richness_110km_alt2, col = viridis(100))
plot(mam_zambia_terr_threat_richness_110km_alt1 -
       mam_zambia_terr_threat_richness_110km_alt2, col = viridis(100))

# thoughts at the end of this exercise: which option is better? Hard to say. Ask Lyndon. 
# But, my guess is that aggregating from the 1km global map might make the most sense. 
# The other two options are to aggregate directly from the Zambia map, or to burn  onto a coarser raster in the fasterize().
```

Here are the methods for the two alternative methods.
Alt 1: Using `fasterize()` on a coarser resolution raster.

```{r rescale-alt1}
##### 10 km x 10 km

####################
# mammal terrestrial threatened species richness, at 10 km x 10 km resolution:
####################
mam_terr_threat_richness_10km_alt1 <- mam_sf %>%   # assign mam_sf to a new object, to then be modified
  filter(presence == 1) %>%   # only records with Code 1 (Extant)
  filter(origin == 1) %>%     # only native species (Code 1)
  filter(marine == "False") %>%   # removing all marine species
  filter(category %in% c("CR", "EN", "VU")) %>%   # choosing threatened species
  st_transform(crs(msk_shp)) %>%   # reproject shapefiles to Albers Equal Area projection
  fasterize(., raster(., res = 1000*10), fun = 'sum') # change resolution here to make coarser

plot(mam_terr_threat_richness_10km_alt1, ext = extent(msk_shp), col = viridis(100))
plot(msk_shp, add = T, border = "red")

####################
# Save global file
####################
writeRaster(mam_terr_threat_richness_10km_alt1, fp(p_iucn_dev,"mam_terr_threat_richness_10km_alt1.tif"), overwrite=TRUE)
rm(mam_terr_threat_richness_10km_alt1)
mam_terr_threat_richness_10km_alt1 <- raster(fp(p_iucn_dev,"mam_terr_threat_richness_10km_alt1.tif"))

####################
# Mask to Zambia for tradeoff model
####################
mam_terr_threat_richness_10km_alt1 <- disaggregate(mam_terr_threat_richness_10km_alt1, fact = 10) # has to be disaggregated, so that there are 10 x 10 cells in each cell, all with the same value. This is so that it can be masked, and so there is a value for each cell to be run through the tradeoff model.
mam_zambia_terr_threat_richness_10km_alt1 <- crop(mam_terr_threat_richness_10km_alt1, extent(msk)) # crop to (almost) the right extent
mam_zambia_terr_threat_richness_10km_alt1@extent <- extent(msk) # still slightly off, so forcing the extents to be the same
mam_zambia_terr_threat_richness_10km_alt1 <- raster::mask(mam_zambia_terr_threat_richness_10km_alt1, msk) # masking, in order to set all cells in hotspots_r to NA where msk is NA.

plot(mam_zambia_terr_threat_richness_10km_alt1, col = viridis(100))

####################
# Save final Zambia file
####################
writeRaster(mam_zambia_terr_threat_richness_10km_alt1, fp(p_iucn_dev,"mam_zambia_terr_threat_richness_10km_alt1.tif"), overwrite=TRUE)
rm(mam_zambia_terr_threat_richness_10km_alt1)
mam_zambia_terr_threat_richness_10km_alt1 <- raster(fp(p_iucn_dev,"mam_zambia_terr_threat_richness_10km_alt1.tif"))




##### 110 km x 110 km

####################
# mammal terrestrial threatened species richness, at 110 km x 110 km resolution:
####################
mam_terr_threat_richness_110km_alt1 <- mam_sf %>%   # assign mam_sf to a new object, to then be modified
  filter(presence == 1) %>%   # only records with Code 1 (Extant)
  filter(origin == 1) %>%     # only native species (Code 1)
  filter(marine == "False") %>%   # removing all marine species
  filter(category %in% c("CR", "EN", "VU")) %>%   # choosing threatened species

  #filter(island == "Madagascar") %>%   # subset
  #filter(SHAPE_Area < median(mam_sf$SHAPE_Area))   # selecting only "small-ranged" species
  st_transform(crs(msk_shp)) %>%   # reproject shapefiles to Albers Equal Area projection
  fasterize(., raster(., res = 1000*110), fun = 'sum') # change resolution here to make coarser

plot(mam_terr_threat_richness_110km_alt1, ext = extent(msk_shp), col = viridis(100))
plot(msk_shp, add = T, border = "red")

####################
# Save global file
####################
writeRaster(mam_terr_threat_richness_110km_alt1, fp(p_iucn_dev,"mam_terr_threat_richness_110km_alt1.tif"), overwrite=TRUE)
rm(mam_terr_threat_richness_110km_alt1)
mam_terr_threat_richness_110km_alt1 <- raster(fp(p_iucn_dev,"mam_terr_threat_richness_110km_alt1.tif"))

####################
# Mask to Zambia for tradeoff model
####################
mam_terr_threat_richness_110km_alt1 <- disaggregate(mam_terr_threat_richness_110km_alt1, fact = 110) # has to be disaggregated, so that there are 110 x 110 cells in each cell, all with the same value. This is so that it can be masked, and so there is a value for each cell to be run through the tradeoff model.
mam_zambia_terr_threat_richness_110km_alt1 <- crop(mam_terr_threat_richness_110km_alt1, extent(msk)) # crop to (almost) the right extent
mam_zambia_terr_threat_richness_110km_alt1@extent <- extent(msk) # still slightly off, so forcing the extents to be the same
mam_zambia_terr_threat_richness_110km_alt1 <- raster::mask(mam_zambia_terr_threat_richness_110km_alt1, msk) # masking, in order to set all cells in hotspots_r to NA where msk is NA.

plot(mam_zambia_terr_threat_richness_110km_alt1, col = viridis(100))

####################
# Save final Zambia file
####################
writeRaster(mam_zambia_terr_threat_richness_110km_alt1, fp(p_iucn_dev,"mam_zambia_terr_threat_richness_110km_alt1.tif"), overwrite=TRUE)
rm(mam_zambia_terr_threat_richness_110km_alt1)
mam_zambia_terr_threat_richness_110km_alt1 <- raster(fp(p_iucn_dev,"mam_zambia_terr_threat_richness_110km_alt1.tif"))
```

Alt 2: Aggregating from the Zambia cropped file.
```{r rescale-alt2}
####################
# Aggregate to 10km x 10km
####################
mam_zambia_terr_threat_richness_10km_alt2 <- aggregate(mam_zambia_terr_threat_richness, fact = 10)
mam_zambia_terr_threat_richness_10km_alt2 <- disaggregate(mam_zambia_terr_threat_richness_10km_alt2, fact = 10)
mam_zambia_terr_threat_richness_10km_alt2 <- crop(mam_zambia_terr_threat_richness_10km_alt2, extent(msk)) # crop to (almost) the right extent
#test_10km_dis@extent <- extent(msk) # still slightly off, so forcing the extents to be the same
mam_zambia_terr_threat_richness_10km_alt2 <- raster::mask(mam_zambia_terr_threat_richness_10km_alt2, msk) # mask, i.e. set all cells in hotspots_r to NA where msk is NA.

plot(mam_zambia_terr_threat_richness_10km_alt2, col = viridis(100))
plot(mam_zambia_terr_threat_richness_10km_alt, col = viridis(100))

writeRaster(mam_zambia_terr_threat_richness_10km_alt2, fp(p_iucn_dev,"mam_zambia_terr_threat_richness_10km_alt2.tif"), overwrite=TRUE)
rm(mam_zambia_terr_threat_richness_10km_alt2)
mam_zambia_terr_threat_richness_10km_alt2 <- raster(fp(p_iucn_dev,"mam_zambia_terr_threat_richness_10km_alt2.tif"))

####################
# Aggregate to 110km x 110km
####################
mam_zambia_terr_threat_richness_110km_alt2 <- aggregate(mam_zambia_terr_threat_richness, fact = 110)
mam_zambia_terr_threat_richness_110km_alt2 <- disaggregate(mam_zambia_terr_threat_richness_110km_alt2, fact = 110)
mam_zambia_terr_threat_richness_110km_alt2 <- crop(mam_zambia_terr_threat_richness_110km_alt2, extent(msk)) # crop to (almost) the right extent
#test_110km_dis@extent <- extent(msk) # still slightly off, so forcing the extents to be the same
mam_zambia_terr_threat_richness_110km_alt2 <- raster::mask(mam_zambia_terr_threat_richness_110km_alt2, msk) # mask, i.e. set all cells in hotspots_r to NA where msk is NA.

plot(mam_zambia_terr_threat_richness, col = viridis(100))
plot(mam_zambia_terr_threat_richness_110km, col = viridis(100))
plot(mam_zambia_terr_threat_richness_110km_alt, col = viridis(100))
plot(mam_zambia_terr_threat_richness_110km_alt2, col = viridis(100))

writeRaster(mam_zambia_terr_threat_richness_110km_alt2, fp(p_iucn_dev,"mam_zambia_terr_threat_richness_110km_alt2.tif"), overwrite=TRUE)
rm(mam_zambia_terr_threat_richness_110km_alt2)
mam_zambia_terr_threat_richness_110km_alt2 <- raster(fp(p_iucn_dev,"mam_zambia_terr_threat_richness_110km_alt2.tif"))
```



